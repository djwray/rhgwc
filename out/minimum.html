<SCRIPT LANGUAGE="JavaScript">
<!--
var originalUrl="http://i.loveruby.net/ja/rhg/book/minimum.html";
var originalLp ="JAEN";
var originalDis="";
if (self.parent.excite_header.display) {
self.parent.excite_header.display.wb_url.value = originalUrl;
self.parent.excite_header.display.wb_lp.value = originalLp;
}
//-->
</SCRIPT>
<SCRIPT LANGUAGE="JavaScript">
<!--
if (top.excite_header)
{
// ok
}
else
{
top.location.href = "http://www.excite-webtl.jp/world/english/web/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fminimum.html&wb_lp=JAEN&wb_dis=";
}
//-->
</SCRIPT>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP"> <head><base href=http://i.loveruby.net/ja/rhg/book/minimum.html> <meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"> <meta http-equiv="Content-Language" content="ja-JP"> <link rel="stylesheet" type="text/css" href="rhg.css"> <link rev="made" href="mailto:aamine@loveruby.net"> <title>Chapter 1 Ruby language minimum</title></head> <body> <h1>Chapter 1 Ruby language minimum</h1> <p>It easily explains only knowledge necessary to understand the first of the Ruby language now. Programming..technique..note..one..at all..point out..this..chapter..read..program..write.This chapter might already fly and it be unquestionable for the reader who experiences the Ruby language. </p> <p>Because the grammar moreover is spoken in the unpleasantness secondarily, it has it in detail about the grammar in this chapter ..no barriers... The mark with the variation like the hush literal etc. shows only the one multiused most. The one that it is possible to omit it is shown without omitting it in principle. The reason for that is that the syntactic rule becomes simple. It is not separately said, "It is omissible". </p> <h2>Object</h2> <h3>Character string</h3> <p>The one that the Ruby program can be operated are all objects. <code>Int</code> of Java There is no "Basic model (primitive)" like <code>long</code>. For instance, it is a character string object (<code>String</code> object) with the content of <code>"content"</code> when writing as follows. </p> <pre class="emlist">
"content" </pre> <p>This is "Expression" that generates the character string object if it says accurately though only called a character string object. Therefore, another character string object is generated in every case if it writes many times. </p> <pre class="emlist">
"content" "content" "content" </pre> <p>Three character string objects with the content of <code>"content"</code> are generated here. </p> <p>By the way, only the object is there and the programmer is not seen. I will teach the method of displaying the object in the terminal. </p> <pre class="emlist">
P("content") It is displayed, #"Content". </pre> <p><code>"#"</code> The comment from now on. The result will be put as a comment in the future. </p> <p><code>"p(……)"</code><code></code> is function <code>p</code> call. An arbitrary object is displayed in" "Like it. It is basically a function for debugging. </p> <p>Strictly speaking, you may think the function now though there is no function in Ruby. The function can be used wherever it is. </p> <h3>Various literal</h3> <p>Well, I will explain the expression (literal) that generates the object directly a little more. In a general point, it is an integer first of all and decimal. </p> <pre class="emlist">
# Integer
1 2 100 9999999999999999999999999 # can be used even by a very big number. # Decimal
1.0 99.999 1.3e4 # 1.3×10^4 </pre> <p>I want you not to forget it is an expression with which this also generates all objects. There is no "Basic model" in Ruby though it repeats. </p> <p>The following expressions generate the array object. </p> <pre class="emlist">
[1, 2, 3] </pre> <p>This program is integer 1 2 The array with three of three as an element in the order is generated. Because an arbitrary object can be used for the array element, these kind of things can be done. </p> <pre class="emlist">
[1, "string", 2, ["nested", "array"]] </pre> <p>In addition, the following expressions generate the hush table. </p> <pre class="emlist">
{"key"=&gt;"value", "key2"=&gt;"value2", "key3"=&gt;"value3"} </pre> <p>The hush table is a structure to show one a couple of correspondence of an arbitrary object. The table that memorizes the following relations can be done by writing as stated above. </p> <pre class="emlist">
"key" → "value" "key2" → "value2" "key3" → "value3" </pre> <p>It can be taught, "It is <code>"Value"</code>" if it is heard, "What is it that is associated with <code>"Key"</code>?" from the hush table object that is done so and made. How do you hear it?The method is used for it. </p> <h3>Method call</h3> <p>The method can be called for the object. It is a member function in the C++ term. It easily explains only the notation something with the method because it thinks it to be need not an explanation. </p> <pre class="emlist">
"content".upcase()
</pre> <p>The <code>upcase</code> method is called here for the character string object (The content is "content"). Because <code>upcase</code> is a method of returning a new character string that makes the small letter of the alphabet a capital letter, it becomes the following results. </p> <pre class="emlist">
P("content".upcase()) It is displayed, #"CONTENT". </pre> <p>The method call is chain [shiteyoi]. </p> <pre class="emlist">
"content".upcase().downcase()
</pre> <p>In this case, it comes for the object of the return value of <code>"Content".upcase()</code> to call the <code>downcase</code> method. </p> <p>Moreover, there is no field of opening to the public (member variable) such as Java and C++. The interface of the object is only a method. </p> <h2>Program</h2> <h3>Top-level</h3> <p>If the expression is suddenly written in Ruby, it is programmed. <code>Main()</code> need not be defined like C++ and Java, etc.</p> <pre class="emlist">
p("content")
</pre> <p>It is Ruby program concluded only by this. It is possible to execute it from the command line as follows by putting this list in the file named <code>first.rb</code>. </p> <pre class="screen">
% ruby first.rb "content" </pre> <p><code>- of the <code>ruby</code> command There is even no necessity for separately making a file if optional e</code> is used. </p> <pre class="screen">
% ruby -e 'p("content")' "content" </pre> <p>By the way, the place where <code>p</code> is written is called "Top-level" the lowest the nest level of the program and programming it in a word because". There is a top level a big feature as the script language of Ruby. </p> <p>In Ruby, the line is one basically sentence. The semicolon in the terminal etc. are unnecessary. Therefore, the following programs are interpreted as three sentences. </p> <pre class="emlist">
p("content") p("content".upcase()) p("CONTENT".downcase())
</pre> <p>It becomes it so if it executes it. </p> <pre class="screen">
% ruby second.rb "content" "CONTENT" "content" </pre> <h3>Local variable</h3> <p>The variable and the constant maintain all references <code>(reference)</code> to the object in Ruby. Therefore, the copy doesn't happen only because it substitutes it for another variable. If it is an object type variable, and C++ in case of Java, it is likely to only have to think about the pointer to the object. However, the value of the pointer is not revokable. </p> <p>The type of the variable (scope) is understood from the first character of the variable identifier in Ruby. Starting in an alphabetic small letter or under a bar is a local variable. And, substitution can be written by using <code>"="</code>. </p> <pre class="emlist">
str = "content" arr = [1,2,3] </pre> <p>Because the first substitution holds the variable declaration concurrently, it is not necessary to declare. Moreover, what kind of object it is, possible to substitute it indiscriminately because there is no type in the variable. The following programs are quite lawful. </p> <pre class="emlist">
lvar = "content" lvar = [1,2,3] lvar = 1 </pre> <p>However and [rerukara] and [i] need not be done. It is the one that puts various kinds of objects in one variable mixed and comes not to usually read easily. It is to actually program Ruby, this is rarely done. This is an example to the end for the example. </p> <p>The variable reference is a very commonsense notation. </p> <pre class="emlist">
str = "content" P(str) #"Content" is displayed. </pre> <p>After that, I will see the point that the variable maintains the reference in the example. </p> <pre class="emlist">
a = "content" b = a c = b </pre> <p>After executing this program, it is Figure 1 that <code>a b c3</code> local variable indicates that is the character string object ..same object.. generated with <code>"Content"</code> of the line. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_reference.jpg" alt="(reference)"><br>Figure 1: The variable of Ruby maintains the reference to the object. </p> <p>By the way, this range cannot be said if not becoming for a while though it must have to be local because it is said it is local compared with somewhere. For the time being a top level is one "Local" scope, and I will say. </p> <h3>Constant</h3> <p>It is a constant that the variable identifier starts by the capital letter. It is the one that can be substituted only once because it is said the constant (beginning). </p> <pre class="emlist">
Const = "content" PI = 3.1415926535 P(Const) It is displayed, #"Content". </pre> <p>It becomes an error if it substitutes it twice. It doesn't actually become an error because of warning alone though I want to say. The purpose of this is to make it not become an error when the same file is loaded twice in the application that operates the Ruby program , for instance, the development setting etc.I want to make it to the error in a word in reality only by the unavoidable admission for practical use. Even version 1.1 was actually an error. </p> <pre class="emlist">
C = 1 C = 2 # makes an error as an idea only though warning actually goes out. </pre> <p>Well, the constant is a meaning "When the object indicated once is memorized, never change it" though the person taken in by the word constant is a lot of. The object deflecting that the constant indicates changes. Read only might show the intention more better than constant if it says in English (Figure 2. )By the way, another method named <code>freeze</code> is used for the direction that the object is not changed. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_const.jpg" alt="(const)"><br>Figure 2: The constant is a meaning of read only. </p> <p>And, the scope of the constant cannot be spoken actually yet. It binds with the class by the following paragraph and it will speak. </p> <h3>Control structure</h3> <p>Because Ruby is serious only the abundant arrays of the control structure, <code>if</code> and <code>while</code> mean only that it is for the time being. </p> <pre class="emlist">
if i &lt; 10 then # Main body
end while i &lt; 10 do # Main body
end </pre> <p>Only two objects named <code>false</code> and <code>nil</code> are imitations in the conditional expression, and all objects of the remainder truly become it. Of course, 0 and the null character string are the truth. </p> <p>There is incidentally <code>true</code> only by <code>false</code> with it because installing is bad, too. Naturally, this is the truth. </p> <h2>Class and method</h2> <h3>Class</h3> <p>The method is originally the one in an object-oriented system that belongs to the object. However, it is a perfect world to the end. The method that can be called in each object foolish and honestly is memorized because there are a lot of objects with sets of the same methods and it grows serious if it is a usual program. Because then, repetition of definition is lost by usually using mechanism like method of class or multi-</p> <p>In Ruby, the concept of traditional "Class" is adopted as a mechanism that the object ties to the method. That is, all objects belong to only one class, and decide the method that can be called in the class. At this time, the object was said, "** instance (instance) of the class". </p> <p>For instance, the character string <code>"Str"</code> is an instance of the <code>String</code> class. And, that Because like all the character string objects seem to be able to react to these methods because additionally ..<code>upcase</code>, <code>downcase</code>, and <code>strip</code>.. various methods are defined in the <code>String</code> class. </p> <pre class="emlist">
# Because everyone belongs to the String class, the same method is defined. "content".upcase() "This is a pen.".upcase() "chapter II".upcase() "content".length() "This is a pen.".length() "chapter II".length() </pre> <p>By the way, how do it become it if the call method is not defined?When executing it, it becomes an exception in Ruby though it becomes a compile error if it is a static language. Let's actually try. <code>- if it is such length Passing is convenient in e</code>. program</p> <pre class="screen">
% ruby -e '"str".bad_method()' -e:1: undefined method `bad_method' for "str":String (NoMethodError)
</pre> <p>It seems to become an error named <code>NoMethodError</code> when the method is not found. <p>Saying separately, "<code>Upcase</code> method of <code>String</code>" etc. will prepare a special notation because it is annoyed at it and the end. "<code>Upcase</code> method defined in the <code>String</code> class" will be shown by <code>"String#upcase"</code>. </p> <p>By the way, it completely has another meaning in the world of Ruby when writing <code>"String.upcase"</code>. What meaning is it?It explains it in the following paragraph. </p> <h3>Class definition</h3> <p>Even here was a story of the class that had already been defined. Of course, an original class can also define it. The <code>class</code> sentence is used to define the class. </p> <pre class="emlist">
class C end </pre> <p>This is a definition of new class <code>C</code>. It is possible to use it as follows when defining it. </p> <pre class="emlist">
class C end c = C.new() The instance of # class C is made and it substitutes it for variable c. </pre> <p>Attention of no <code>new C</code> notation that makes instance. Well, somehow The reader of the notation named <code>C.new()</code> who thought as the method is called is sharp. The expression that generates the object is a mere method call in Ruby. </p> <p>First of all, it is synonymous with the constant name in Ruby with the class name. Then, what there in the constant of the class name and the same name by you?Actually, there is a class. Naturally, because the one that the program can be touched in Ruby were all objects, the class is expressed as a target. I will call this a class object. All the class objects are instances of the <code>Class</code> class. </p> <p>The <code>class</code> sentence is making a new class object, and the substitution of it for the constant of the class name and the same name, ,in a word,, operations. On the other hand, the generation of the instance is an operation of calling the method (It is usually <code>new</code>) for the object referring to the constant. If the following examples are seen, it might be understood well that the generation of the instance of anything is a usual method call and is steady. </p> <pre class="emlist">
S = "content" class C end S.upcase() The object that # constant S indicates is obtained and method upcase is called. C.new() The object that # constant C indicates is obtained and method new is called. </pre> <p><code>New</code> is not a reserved word in Ruby because of this. </p> <p>After that, I will write that <code>p</code> can do even by the instance of the class of the making setting up. </p> <pre class="emlist">
class C end c = C.new() p(c) # #&lt;C:0x2acbd7e4&gt; </pre> <p>Internal ID is displayed though it is not possible to display beautifully indeed like the character string and the integer, etc. as the belonging class. By the way, this ID is a value of the pointer that indicates the object. </p> <p>..method.. ..name.. ..notation.. ..putting out.. . though forgotten completely so often. <code>"Object.new"</code> becomes a meaning of method <code>new</code> of calling class object <code>Object</code> it. Because <code>"Object#new"</code> and <code>"Object.new"</code> are completely different things, it is necessary to distinguish strictly. </p> <pre class="emlist">
obj = Object.new() # Object.new obj.new() # Object#new </pre> <p>It actually makes an error of this program by the second line because the <code>Object#new</code> method is not defined. I want you to receive it to the end as a mark example. </p> <h3>Method definition</h3> <p>When the method cannot be defined even if the class can define it, it is not significant. Let's define the method in our class <code>C</code>. </p> <pre class="emlist">
class C def myupcase( str ) return str.upcase() end end </pre> <p>The <code>def</code> sentence is used to define the method. The method named <code>myupcase</code> was defined in this example. In the parameter, the name is <code>str</code> by one. The type of the parameter variable and the return value need not be written as well as the time of the variable. Moreover, many numbers of parameters are good. </p> <p>The definition method is used. The method can be called from the outside by default. </p> <pre class="emlist">
c = C.new() Result = c.myupcase("content") p(result) #"CONTENT" is displayed. </pre> <p>It is not necessary to substitute it separately if becoming accustomed of course. It is the same even if it writes as follows. </p> <pre class="emlist">
P(C.new().myupcase("content")) Similarly, "CONTENT" is displayed as for #. </pre> <h3><code>self</code></h3> <p>Information who oneself (instance that the method is called) is always is preserved, and the information can be taken with <code>self</code> while executing the method. It is <code>this</code> if it says by C++ and Java. Let's confirm it. </p> <pre class="emlist">
class C def get_self() return self end end c = C.new() p(c) # #&lt;C:0x40274e44&gt; p(c.get_self()) # #&lt;C:0x40274e44&gt; </pre> <p>As you see, two expressions return quite the same object. It was able to be confirmed that <code>self</code> was <code>c</code> at in a word, being in the method call to <code>c</code>. </p> <p>Then, is it good when doing very for oneself to call the method?First of all, the method of calling by way of <code>self</code> is devised. </p> <pre class="emlist">
class C def my_p( obj ) Self.real_my_p(obj) The method is called for # oneself End. def real_my_p( obj ) p(obj) end end C.new().my_p(1) # One is displayed. </pre> <p>However, having to specify, "Myself" purposely to call own method is troublesome. It ..<code>self</code>.. calls and and it is omissible ..the object of the object that calls the method (receiver receiver)... </p> <pre class="emlist">
class C def my_p( obj ) Real_my_p(obj) It is possible to call without # receiver specification End. def real_my_p( obj ) p(obj) end end C.new().my_p(1) # One is displayed. </pre> <h3>Instance variable</h3> <p>It is so useless only to be able to define the method by there is an expression that the object is data + code, too. Data should be able to be memorized in each object. That is, it is an instance variable. It is a member variable if it says with C++. </p> <p>The first character decides the type according to the variable identifier rule of Ruby. The instance variable <code>"@"</code>, ..putting out.. .</p> <pre class="emlist">
class C def set_i(value) @i = value end def get_i() return @i end end c = C.new() c.set_i("ok") P(c.get_i()) #"Ok" is displayed. </pre> <p>The instance variable can be referred to by having changed it for a moment with a current variable even if it doesn't substitute it (Even if you do not define it). These kind of things were tried as continuation of the code at the previous state of …… how it became it in that case. </p> <pre class="emlist">
c = C.new() P(c.get_i()) # It is displayed as nil. </pre> <p>When <code>get</code> was done without doing <code>set</code>, it was displayed as <code>nil</code>. <code>Nil</code> is an object that means "It is not". It cannot be helped as such though it is mysterious though there is an object there either. </p> <p> <code>Nil</code> can be used like literal. </p> <pre class="emlist">
P(nil) # It is displayed as nil. </pre> <h3><code>initialize</code></h3> <p>If <code>new</code> is called, the class of just the definition as seeing up to now can make the instance. It will want to be likely to do peculiar initialization to the class though it is certainly so. <code>New</code> is not changed but the method named <code>initialize</code> is defined at such time. Then, it is called in <code>new</code>. </p> <pre class="emlist">
class C def initialize() @i = "ok" end def get_i() return @i end end c = C.new() P(c.get_i()) It is displayed, #"Ok". </pre> <p>However, this is a specification of the method named <code>new</code> to the end and saying strictly not a specification of the language. </p> <h3>Succession</h3> <p>The class can succeed to other classes. For instance, the <code>String</code> class has succeeded to the <code>Object</code> class. This relation is written by the arrow of length in this book as shown in Figure 3. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_supersub.jpg" alt="(supersub)"><br>Figure 3: Succession</p> <p>Class <code>(Object)</code> of succession for this figure calls a super-class or high-ranking class. Class <code>(String)</code> that succeeds to calls the subclass or the descendent class. Because the term is different from this respect C++, I want you to note it. It is the same as Java. </p> <p>Anyway, let's try. The class that we established is made to succeed to other classes, too. It writes as follows to succeed to and to establish the class (To specify a super-class). </p> <pre class="emlist">
class C &lt; SuperClassName end </pre> <p>Implicitly when a super-class is omitted and written up to now The class named <code>Object</code> becomes a super-class. </p> <p>Well, the purpose is to succeed the method of course if why it succeeds to is said. To succeed is to work like repeating the method definition in a super-class again in the subclass. Let's try this. </p> <pre class="emlist">
class C def hello() return "hello" end end class Sub &lt; C end sub = Sub.new() P(sub.hello()) #"Hello" is displayed. </pre> <p>It was possible to call for the instance of the <code>Sub</code> class though <code>hello</code> was a method defined in class <code>C</code>. It is not necessary to substitute it for the variable of course this time. It is the same even if it writes as follows. </p> <pre class="emlist">
p(Sub.new().hello())
</pre> <p>If the method of the same name is defined, override can be done. C++ Override is possible in Ruby though only the method to specify by reserved word <code>virtual</code> etc. specifying it is good at Object Pascal(Delphi) at override unconditional all methods. </p> <pre class="emlist">
class C def hello() return "Hello" end end class Sub &lt; C def hello() return "Hello from Sub" end end P(Sub.new().hello()) #"Hello from Sub" is displayed p(C.new().hello()) #"Hello" is displayed. </pre> <p>Moreover, the class may succeed to steps how many. For instance, to the way of Figure 4. Because in this case, <code>Fixnum</code> succeeds all methods of <code>Object</code>, <code>Numeric</code>, and <code>Integer</code>The method of a nearer class is given to priority when there is a method of the same name. Because the overload doesn't have the one at all, the condition is very simple by the type. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_multiinherit.jpg" alt="(multiinherit)"><br>Figure 4: Succession of multistep</p> <p>In Ruby though the class that doesn't succeed to anything can be made when it is it, and C++ It is necessary to succeed to the <code>Object</code> class indirectly directly. If figure related to succession is written in a word, it becomes one tree that makes <code>Object</code> the top. For instance, when the succession relation of an important class in a basic library is made a tree, it is feeling as shown in Figure 5. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_classtree.jpg" alt="(classtree)"><br>Figure 5: Class tree of Ruby</p> <p>A super-class is never changed only by it afterwards when deciding it once (When defining it). Even if a new class is added to the class tree in a word, the position doesn't move and be deleted. </p> <h3>Succession of variable ……?</h3> <p>The variable (instance variable) is not the one succeeding to in Ruby. It is because there is no information in the class what variable of used to succeed to in the class. </p> <p>However, substitution for the instance variable happens as long as the method is succeeded to when the method is called succession that (In the instance of the descendent class). In a word, it is defined. It comes to be able to access the name space of the instance variable when might from the method of which class because it is completely in each instance flat if it does so. </p> <pre class="emlist">
class A Def initialize() # It is called by the process of new. @i = "ok" end end class B &lt; A def print_i() p(@i) end end B.new().print_i() It is displayed, #"Ok". </pre> <p>It is good when thinking succession to be a class by crushing if this behavior cannot be consented. It thinks by assuming that all the methods of a super-class of <code>C</code> are first defined in <code>C</code> if there is instance <code>obj</code> of class <code>C</code>. Let's neatly consider the rule of override of course. And, the method of <code>C</code> is joined to <code>obj</code> this time (Figure 6). This strong "Mono-feeling" is a feature of object-oriented of Ruby. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_objimage.jpg" alt="(objimage)"><br>Figure 6: Image of object of Ruby</p> <h3>Module</h3> <p>A super-class was able to specify only one. In a word, Ruby looks like the single inheritance of wanting seeing. However, it actually has an equal ability with the multiple inheritance so that there is a module. Next, let's explain the module. </p> <p>It is a class that cannot specify a super-class in a word, and cannot make the instance as for the module. The definition is written as follows. </p> <pre class="emlist">
module M end </pre> <p>Module <code>M</code> was defined by this. The method can be defined quite thoroughly to the class. </p> <pre class="emlist">
module M def myupcase( str ) return str.upcase() end end </pre> <p>However, because the instance cannot be made, it is not possible to call it directly. Then, "Include" is done to other classes when how it costs it is said and it uses it. Then, it comes to be able to treat as if the class succeeded to the module. </p> <pre class="emlist">
module M def myupcase( str ) return str.upcase() end end class C include M end P(C.new().myupcase("content")) It is displayed, #"CONTENT". </pre> <p><code>Myupcase</code> was able to be called though the method was not defined in class <code>C</code>. This was to have done the method of module <code>M</code> in a word in "Succession". Include is quite the same as succession functionally. Neither the method definition nor any access of the instance variable are limited. </p> <p>If another module is done in include, it is possible to do though the module was said that it cannot specify a super-class. </p> <pre class="emlist">
module M end module M2 include M end </pre> <p>It is in a word functionally ..this.. equal to can the specification of a super-class. However, only the class's coming to the high rank doesn't decide it. Only the module is permitted on the module to the end. </p> <p>The example including the succession of the method is shown below. </p> <pre class="emlist">
module OneMore def method_OneMore() p("OneMore") end end module M include OneMore def method_M() p("M") end end class C include M end C.new().method_M() #"M" is displayed. C.new().method_OneMore() #"OneMore" is displayed. </pre> <p>If succession is written just like the class, it becomes as shown in Figure 7. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_modinherit.jpg" alt="(modinherit)"><br>Figure 7: Include of multistep</p> <p>By the way, how does the relation between it and the module become it though class <code>C</code> also includes a super-class?For instance, let's think in the following cases. </p> <pre class="emlist">
# modcls.rb class Cls def test() return "class" end end module Mod def test() return "module" end end class C &lt; Cls include Mod end p(B.new().test()) # "class"? "module"?
</pre> <p><code>Cls</code> is succeeded to, and include does <code>Mod</code> to <code>C</code>. In this case, will will it be <code>"Class"</code> to be displayed or it will be <code>"Module. "</code>?Which the module or the class is "or more It is near. " in a word?Ruby can be heard from Ruby, and executed. </p> <pre class="screen">
% ruby modcls.rb "module" </pre> <p>Modules seem to be given to priority more than super-classes. </p> <p>Generally speaking, when the module is done in include in Ruby, it succeeds to in the shape got in to "Among" of the class and a super-class. It is likely to be able to write as shown in Figure 8 if it makes it to the picture. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_modclass.jpg" alt="(modclass)"><br>Figure 8: Class and correlation of module</p> <p>Moreover, it thinks about the module that include is done and it becomes a module as shown in Figure 9. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_modclass2.jpg" alt="(modclass2)"><br>Figure 9: Class and correlation of module(2) </p> <h2>Program(II)</h2> <p>Attention. It explains the regret element in familiarity for the programmer who has used only a very important, static language recently. Another wants a diagonal reading, and only here wants you to read carefully. It explains comparatively politely. </p> <h3>Nest of constant</h3> <p>First of all, the constant is reviewed. It was able to be defined to start from the capital letter by the constant as follows. </p> <pre class="emlist">
Const = 3 </pre> <p>And, to refer to this constant was to have done as follows. </p> <pre class="emlist">
P(Const) # Three is displayed. </pre> <p>This can be actually written as follows. </p> <pre class="emlist">
P(::Const) Similarly, # displays three. </pre> <p>When <code>::</code> adheres to the head, "It is a constant defined top-level" is shown. It is good when comparing it to passing the filesystem. Let's assume that there was a file named <code>vmunix</code> in the root directory. It is possible to access it if it is only written <code>vmunix</code> when is in<code>/</code>Moreover, it can be specified<code>/vmunix</code> in the full path. <code>Const</code> and <code>:: Const</code> are also the same as the relation. You may only write <code>Const</code>, and you may write <code>:: Const</code> while it is top-level in the full path. </p> <p>Then, what is the one that hits the directory of the filesystem in Ruby?It is a class definition sentence and a module definition sentence. However, it will represent it collectively thereafter by the class definition sentence because it is long and troublesome when there are two. The constant level goes up in the class definition sentence (Enter the directory). </p> <pre class="emlist">
class SomeClass Const = 3 end P(::SomeClass::Const) # It is displayed as three p( SomeClass::Const) # is the same. It is displayed as three. </pre> <p>It is possible to refer even if it is only written <code>SomeClass</code> because <code>SomeClass</code> is a class defined top-level, that is, the constant or writes <code>:: SomeClass</code>. And, it becomes in the class definition and constant <code>Const</code> that is the nest becomes <code>:: SomeClass::Const</code> by "It is in <code>SomeClass</code>" <code>Const</code>. </p> <p>To make the directory again in the directory, the class can be established in the class. For instance, like this. </p> <pre class="emlist">
class C # ::C class C2 # ::C::C2 class C3 # ::C::C2::C3 end end end </pre> <p>By the way, in the full path, should I always write the constant defined in the class definition sentence?Of course, there is no such a thing. It is possible to refer in case of being in "Inside" of the class definition sentence at a level that is the same as the comparison of the filesystem, the same without <code>::</code>. In a word, this. </p> <pre class="emlist">
class SomeClass Const = 3 P(Const) # It is displayed as three. end </pre> <p>Did not you think [are]?Very, when it might be a class definition sentence inside, the executed program can be written. I think that this is considerably unexpected when it is a person who is accustomed to a static language (Hold). When the author also saw for the first time, it made it to [gyo]. </p> <p>Of course, when it kicks and [kanada] is gotten, [ichiou] [duki] sees the constant from among the method. The reference rule is quite the same in the class definition sentence (outside of the method). </p> <pre class="emlist">
class C Const = "ok" def test() p(Const) end end C.new().test() #"Ok" is displayed. </pre> <h3>Everything is executed. </h3> <p>I will write one staring at the whole here. Most parts of the program are "It is executed. " in Ruby. The thing the constant definition, the class definition sentence, the method definition sentence, and additionally almost is executed in order as seeing it. </p> <p>For instance, I want you to see the following code. The structure that had been used before was variously used. </p> <pre class="emlist">
1: p("first") 2:
3: class C &lt; Object 4: Const = "in C" 5:
6: p(Const) 7:
8: def myupcase(str) 9: return str.upcase() 10: end 11: end 12:
13: p(C.new().myupcase("content"))
</pre> <p>This program is executed in the following order. </p> <table> <tr><td><code>1: p("first")</code><td><td>It is displayed, <code>"First"</code>. <td></tr> <tr><td><code>3: &lt; Object</code><td><td>Class object <code>Object</code> is obtained referring to constant <code>Object</code>. <td></tr> <tr><td><code>3: class C</code><td><td>A new class object that makes <code>Object</code> a super-class is generated, and it substitutes it for constant <code>C</code>. <td></tr> <tr><td><code>4: Const = "in C"</code><td><td>::<code>C::Const</code> is defined. The value is <code>"In C. "</code><td></tr> <tr><td><code>6: p(Const)</code><td><td>::<code>C::Const</code> is displayed. <code>"In C"</code> is displayed. <td></tr> <tr><td><code>8: def myupcase(...)...end</code><td><td>Method <code>C#myupcase</code> is defined. <td></tr> <tr><td><code>13: C.new().myupcase(...)</code><td><td><code>New</code> is called, and, in addition, <code>myupcase</code> is called on the other hand for it referring to constant <code>C</code>. <td></tr> <tr><td><code>9: return str.upcase()</code><td><td><code>"CONTENT"</code> is returned. <td></tr> <tr><td><code>13: p(...)</code><td><td><code>"CONTENT"</code> is displayed. <td></tr> </table> <h3>Scope of local variable</h3> <p>At last, the scope of the local variable can be spoken by this. </p> <p>It has independent local variable scope in complete ..peel.. [re] ..[so] it.. top-level and the main body of the method in the module definition sentence in the class definition sentence. <code>Lvar</code> that exists in the following program are another entire variables, and, in a word, do not have coming and going in each other. </p> <pre class="emlist">
lvar = 'toplevel' class C lvar = 'in C' def method() lvar = 'in C#method' end end P(lvar) It is displayed, #"Toplevel". module M lvar = 'in M' end P(lvar) It is displayed, #"Toplevel". </pre> <h3><code>Self</code> as context</h3> <p>Oneself (object that had called the method) : while executing the method before It was said that it would become <code>self</code>. There is only a half though it is correct. <code>Self</code> is set to be actually while executing the Ruby program where. There is <code>self</code> also in the class definition sentence in a word top-level. </p> <p>For instance, there is <code>self</code> even if it is top-level. <code>Self</code> of top-level is called <code>main</code>. It is an instance of what <code>Object</code> class of common. Only <code>main</code> is prepared to set <code>self</code> for the time being, and there is no too deep meaning in it. </p> <p>It becomes possible to call the method of <code>Object</code> even if it is top-level because it is an instance of <code>Object</code> because of this <code>self</code> of top-level, that is, <code>main</code>. And, The module named <code>Kernel</code> is done include, and, then, to <code>Object</code> "Method of the function style" such as <code>p</code> and <code>puts</code> is defined (Figure 10. )<code>p</code> even if it is top-level and <code>puts</code> can be called. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_Kernel.jpg" alt="(Kernel)"><br>Figure 10: <code>Main</code>, <code>Object</code>, and <code>Kernel</code></p> <p>Therefore, <code>p</code> is not a function but a method in reality. "Myself. " what the class of <code>self</code> is in a word ..however for be because of being defined by <code>Kernel</code> where.. It is possible to call as a method like the function. Therefore, "Function" in a true meaning doesn't exist in Ruby. It is only a method that it is. </p> <p>By the way, to such a method of the function style besides <code>p</code> and <code>puts</code> A lot of things of the name seen somewhere as <code>print puts printf sprintf gets fork exec</code><code></code><code></code><code></code><code></code><code></code><code></code> etc. exist. When you see those who choose about the name around here Be not imaginable somehow the character of Ruby. </p> <p>Well, <code>self</code>'s anywhere being set is sure to have <code>self</code> similarly also in the class definition sentence. <code>Self</code> defining the class is the class It is (class object. )Therefore, it becomes it in this way. </p> <pre class="emlist">
class C p(self) # C end </pre> <p>This might be on earth useful ..what... An example that is very useful actually already is seen. It is this. </p> <pre class="emlist">
module M end class C include M end </pre> <p>This <code>include</code> is actually a call of the method to class object <code>C</code>. Parentheses of the method call are omissible in Ruby though it has not said yet. Because the story of the class definition sentence had not ended up to now, parentheses were removed to daring do not see the method call. </p> <h3>Loading</h3> <p>When the library is loaded in Ruby and everything is executed, it is done. It writes so usually. </p> <pre class="emlist">
require("library_name")
</pre> <p>It is not betrayed to want to see and <code>require</code> is a method. There is not a reserved word either. Loading is executed in the place written so when writing so, and execution moves to the library (..drinking.. code). Because there is no concept like the package of Java in Ruby, the file is put in the directory and it separates to separate the name space of the library name. </p> <pre class="emlist">
require("somelib/file1") require("somelib/file2")
</pre> <p>Because and, it usually has in <code>class</code> sentence and <code>module</code> sentence and class etc. are defined in libraryThe constant scope of top-level sees the class that the file defined with another file because it is another and is regardless but it is flat from the beginning. To separate the name space of the class name, it ..module.. ..nest.. has it following and specifying it. </p> <pre class="emlist">
# Example of separating net library name space
module Net class SMTP # ...
end class POP # ...
end class HTTP # ...
end end </pre> <h2>The class further</h2> <h3>Story of constant that still continues</h3> <p>The scope of the constant has been compared to the filesystem up to now, and I would like you to forget completely here as for the comparison. </p> <p>There is still beginning in the constant. First of all, the constant that exists in the class of "Outside" can be seen, too. </p> <pre class="emlist">
Const = "ok" class C P(Const) #"Ok" is displayed. end </pre> <p>It is because of convenience when it says to become it so why to the use of the module as the name space. Let's explain by what added to the example of <code>net</code> library a little while ago a little what it is. </p> <pre class="emlist">
module Net class SMTP # Net::SMTPHelper is used by the method. end Class SMTPHelper # class that assists Net::SMTP End end
</pre> <p>Isn't it convenient to be able to refer only by writing <code>SMTPHelper</code> in such a case from among the <code>SMTP</code> class?Then, because of becoming conclusion "It is convenient to see the class". </p> <p>The class of "Outside" can refer in case of steps even of the nest it how many. When the constant of the same name is defined at two or more nest levels, what is sequentially seen from the inside and found first must be referred to. </p> <pre class="emlist">
Const = "far" class C Here "Near" # Const = is nearer than Const in the above Class C2. class C3 P(Const) #"Near" is displayed. end end end </pre> <p>Moreover, there is a retrieval passing of another one in the constant. The constant of my super-class in addition is seen when not found even if going to a top level looking for the class on the outside fast. </p> <pre class="emlist">
class A Const = "ok" end class B &lt; A P(Const) #"Ok" is displayed. end </pre> <p>[Uenai] of ..confusing.. [ikotoko] at all. </p> <p>Let's bring it together. It first looks for the class on the outside and, next, it looks for a super-class when looking for the constant. For instance, it is assumed that the following class hierarchies existed though the considerable deliberation. </p> <pre class="emlist">
class A1 end class A2 &lt; A1 end class A3 &lt; A2 class B1 end class B2 &lt; B1 end class B3 &lt; B2 class C1 end class C2 &lt; C1 end class C3 &lt; C2 p(Const) end end end </pre> <p>When constant <code>Const</code> is referred with <code>C3</code>, it is retrieved in order of Figure 11. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_constref.jpg" alt="(constref)"><br>Figure 11: Retrieval sequence of constant</p> <p>One point attention. A super-class of the class on the outside , for instance, no <code>A1</code> and no <code>B2</code> is completely retrieved. It is only a direction of a super-class that retrieves if it is seeing, and it is a super-class to the end if it is the outside toward the direction of the outside. Unexpected..number..class..retrieve..so much..complex..one..behavior..predictable.</p> <h3>Meta class</h3> <p>It was said that the method was able to be called if it was an object. The method that was able to be called was said that it would decide in the class of an object. Then, is there "The class" also in the class object (Figure 12)?</p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_classclass.jpg" alt="(classclass)"><br>Figure 12: Does the class of the class :?</p> <p>It is possible to actually confirm it in Ruby at such time. It is because there is "Method of returning the class (class object) to which I belong" <code>Object#class</code>. </p> <pre class="emlist">
P("string".class()) # It was displayed as String p(String.class()) # It was displayed as Class p(Object.class()) # It was displayed as Class. </pre> <p> <code>String</code> seems to belong to the class named <code>Class</code>. Then, what is the class of <code>Class</code> further?</p> <pre class="emlist">
P(Class.class()) # It was displayed as Class. </pre> <p>Moreover, it seems to be <code>Class</code>. In a word, what kind of object it is. <code>Class().class().class()</code> ……, and it arrives at <code>Class</code>, and, then, tracing is [hamattedondumarininaru] (Figure 13) to the loop. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_ccc.jpg" alt="(ccc)"><br>Figure 13: …… of class of class of class</p> <p> <code>Class</code> is a class of the class. It is "Meta class. " ..: of <code>Class</code> because of saying of it, "Meta **".. though it has the recursion structure "** of **" and. </p> <h3>Meta object</h3> <p>Then, it thinks about the module by changing the object this time. There must quite similarly to the class be "The class" because the module is also an object. Let's see. </p> <pre class="emlist">
module M end P(M.class()) # It is displayed as Module. </pre> <p>The class of the module object seems to say <code>Module</code>. Then, what is the class of the <code>Module</code> class?</p> <pre class="emlist">
p(Module.class()) # Class </pre> <p>It is this and <code>Class</code>. </p> <p>If so, the direction is changed this time and the succession relation is examined. What is a super-class of <code>Class</code> and <code>Module</code>? It is examined with <code>Class#superclass</code> in Ruby. </p> <pre class="emlist">
p(Class.superclass()) # Module p(Module.superclass()) # Object p
(Object.superclass()) # nil </pre> <p>Very, <code>Class</code> was a descendent class of <code>Module</code>. When the relation of an important class of Ruby is shown from these facts in the figure, it becomes as shown in Figure 14. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_minimum_metaobjects.jpg" alt="(metaobjects)"><br>Figure 14: Relation of important class of Ruby</p> <p>There is not an explanation either at last, it can up to now explain true colors by this though <code>new</code> and <code>include</code> have been used. <code>New</code> is a method actually defined in the <code>Class</code> class. Because therefore, any class (Because it is an instance of <code>Class</code>) can suddenly use <code>new</code>. However, because <code>new</code> is not defined in <code>Module</code>, the instance cannot be made. Moreover, Because <code>include</code> is defined in the <code>Module</code> class, <code>include</code> can be called for the module or the class. </p> <p>These three class, <code>Object</code>, <code>Module</code>, and <code>Class</code> are objects who support the basis of Ruby. Because these three objects describe the object world of Ruby if it saysIt is an object that describes the object in a word. Then, <code>Object Module Class</code> is "Meta object. " of Ruby. </p> <h3>Peculiar method</h3> <p>It was said that the method was able to be called if it was an object. The method that was able to be called was said that it would decide in the class of an object. However, I think that I said the method belonging to the object as an idea. To the end when the class is beginning to save time when the same method is defined many times. </p> <p>Then, ..putting out.. .. There is actually a mechanism that the method is defined in an object (instance) that is regardless but individual in Ruby with the class, too. It writes in it so. </p> <pre class="emlist">
obj = Object.new() def obj.my_first() Puts("My first singleton method") end obj.my_first() # My first singleton method and display
</pre> <p><code>Object</code> is a route of all classes as known. To such an important class The method such as <code>my_first</code> won't be defined. And, <code>obj</code> is an instance of <code>Object</code>. However, the method named <code>my_first</code> can be called for <code>obj</code>. A quite unrelated quite at all method is defined as the class that is in a word correct, and belongs. Such a method of the definition of each object is called peculiar method (singleton method). </p> <p>When is a peculiar method used?It is time when it first defines the one like a static method of saying with Java and C++. It is a method that can be used even if the instance is not generated in a word. Such a method is expressed as a peculiar method of the class object in Ruby. </p> <p>For instance, there is a system call named <code>unlink</code> of UNIX. It is an instruction that deletes the entry of the file from the filesystem. This can be used directly as peculiar method <code>unlink</code> of the <code>File</code> class in Ruby. Let's use it. </p> <pre class="emlist">
File.unlink("core") # core dump is erased. </pre> <p>Hereafter, it will be only written as <code>"File.unlink"</code> to say, "Peculiar method <code>unlink</code> of the <code>File</code> object" separately because it is troublesome. "Method <code>write</code> defined by <code>File</code>. " in the opposite ..The mistake write <code>"File#unlink"</code>, and.. I want you not to write with <code>"File.write"</code>. </p> <p class="caption">- Summary of method notation</p> <table> <tr><td>Notation<td><td>Object that can be called<td><td>Call example<td></tr> <tr><td><code>File.unlink</code><td><td>The <code>File</code> class<td><td><code>File.unlink("core")</code><td></tr> <tr><td><code>File#write</code><td><td>Instance of <code>File</code><td><td><code>f.write("str")</code><td></tr> </table> <h3>Class variable</h3> <p>The class variable is comparatively a novel function that joined from <code>ruby 1.6</code>. It belongs to the class as well as the constant, and it is possible to substitute and to refer from both the class and the instance. Let's see the example. The one that the head of the variable identifier was made <code>@@</code> is a class variable. </p> <pre class="emlist">
class C @@cvar = "ok" P(@@cvar) #"Ok" is displayed. def print_cvar() p(@@cvar) end end C.new().print_cvar() #"Ok" is displayed. </pre> <p>It also makes an error also of the class variable when executing it if referring before it substitutes it as follows because the first substitution holds the definition concurrently. Behavior is different from the instance variable though only <code>@</code> adheres. </p> <pre class="screen">
% ruby -e ' class C @@cvar end '
-e:3: uninitialized class variable @@cvar in C (NameError)
</pre> <p><code>- ..putting on side for a moment here.. The program ..optional e</code> it.. was given. Three lines enclosed with<code>'</code> are ..<code>'</code>.. programs. </p> <p>Moreover, the class variable is succeeded to. The class variable of a high-ranking class can be substituted and be referred to by changing those who say according to the descendent class. </p> <pre class="emlist">
class A @@cvar = "ok" end class B &lt; A P(@@cvar) #"Ok" is displayed Def print_cvar. () p(@@cvar) end end B.new().print_cvar() #"Ok" is displayed. </pre> <h2>Global variable</h2> <p>Finally, there is [ichiou] [gu] low British anti-lewisite variable, too. It is a global variable to be able to substitute and to refer to the program from anywhere. It is a global variable to have made the first character of the variable identifier <code>$</code></p> <pre class="emlist">
$gvar = "global variable" P($gvar) #"Global variable" and display
</pre> <p>The global variable can be considered to have been defined before all names substitute it as well as the instance variable. Even if you refer before it substitutes it in a word Only <code>nil</code> is returned and it doesn't become an error. <hr> <p>The point of an opinion, an impression, and a mis-plant etc. are <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fmailto%3Aaamine%40loveruby.net&wb_lp=JAEN&wb_dis=2">[mine**] Aoki Thank you very much even for &lt; aamine@loveruby.net &gt;</a>. </p> <p> <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fdirect.ips.co.jp%2Fdirectsys%2Fgo_x_TempChoice.cfm%3Fsh_id%3DEE0040%26amp%3Bspm_id%3D1%26amp%3BGM_ID%3D1721&wb_lp=JAEN&wb_dis=2">It is possible to reserve ..direct ..'Ruby source code complete explanation'.. IMPRESS it.. and to buy it (Fly to the book introduction page. )</a> </p> <p>Copyright (c) 2002-2004 Minero Aoki, All rights reserved.</p> </body> </html>
<script src="http://rep.excite-webtl.jp/urchin.js" type="text/javascript"></script>
<script type="text/javascript">
_udn="excite-webtl.jp";
urchinTracker();
</script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-400370-52");
pageTracker._initData();
pageTracker._trackPageview();
</script>
