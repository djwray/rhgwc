<SCRIPT LANGUAGE="JavaScript">
<!--
var originalUrl="http://i.loveruby.net/ja/rhg/book/method.html";
var originalLp ="JAEN";
var originalDis="";
if (self.parent.excite_header.display) {
self.parent.excite_header.display.wb_url.value = originalUrl;
self.parent.excite_header.display.wb_lp.value = originalLp;
}
//-->
</SCRIPT>
<SCRIPT LANGUAGE="JavaScript">
<!--
if (top.excite_header)
{
// ok
}
else
{
top.location.href = "http://www.excite-webtl.jp/world/english/web/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fmethod.html&wb_lp=JAEN&wb_dis=";
}
//-->
</SCRIPT>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP"> <head><base href=http://i.loveruby.net/ja/rhg/book/method.html> <meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"> <meta http-equiv="Content-Language" content="ja-JP"> <link rel="stylesheet" type="text/css" href="rhg.css"> <link rev="made" href="mailto:aamine@loveruby.net"> <title>Chapter 15 Method</title></head> <body> <h1>Chapter 15 Method</h1> <p>The search and the start of the method are spoken in this chapter. </p> <h2>Search for method</h2> <h3>Term</h3> <p>Very various "Argument" comes out in this chapter by both of stories of the method call and the method definition done relations. Then, the term will be strictly decided here so as not to become confusing. </p> <pre class="emlist">
Usually..argument..array..argument."Block argument"
Usually..parameter..optional..parameter..the..default value..parameter."
Block parameter"
</pre> <p>"Argument" receiving everything are to put all adjectives respectively by "Parameter" according to the kind when passing it to [yousuru]. </p> <p>However, "Block argument" and "Block parameter" will be treated by the next chapter 'Block' while having enumerated it here. </p> <h3>Investigation</h3> <p class="caption">- Source program</p> <pre class="longlist">
obj.method(7,8)
</pre> <p class="caption">- and done syntax tree for</p> <pre class="longlist">
NODE_CALL nd_mid = 9049 (method) nd_recv: NODE_VCALL nd_mid = 9617 (obj) nd_args: NODE_ARRAY [ 0:
NODE_LIT nd_lit = 7:Fixnum 1:
NODE_LIT nd_lit = 8:Fixnum ]
</pre> <p>The node of the method call is <code>NODE_CALL</code>. The argument is stored in <code>nd_args</code> as a list of <code>NODE_ARRAY</code>. </p> <p>With <code>NODE_FCALL</code> as a method call node ..it.. besides this There is <code>NODE_VCALL</code>, too. <code>NODE_FCALL</code> corresponds and <code>NODE_VCALL</code> corresponds to the call of the form of same <code>"method"</code> as the local variable in the form of <code>"method(args)"</code>. Actually Because the code to prepare the argument at <code>VCALL</code> is unnecessary, it is distinguished only to save the memory and the time of the amount though <code>FCALL</code> and <code>VCALL</code> can be brought together in one. </p> <p>Then, let's see the handler of <code>NODE_CALL</code> in <code>rb_eval()</code>. </p> <p class="caption">- <code>rb_eval()</code>-<code>NODE_CALL</code></p> <pre class="longlist">
2745 case NODE_CALL: 2746 { 2747 VALUE recv; 2748 int argc; VALUE *argv; /* used in SETUP_ARGS */ 2749 TMP_PROTECT; 2750 2751 BEGIN_CALLARGS; 2752 recv = rb_eval(self, node-&gt;nd_recv); 2753 SETUP_ARGS(node-&gt;nd_args); 2754 END_CALLARGS; 2755 2756 SET_CURRENT_SOURCE(); 2757 result = rb_call(CLASS_OF(recv),recv,node-&gt;nd_mid,argc,argv,0); 2758 } 2759 break; (eval.c)
</pre> <p>Problems three are macros, and <code>BEGIN_CALLARGS SETUP_ARGS() It might be END_CALLARGS</code>. What do you do that the argument might be evaluated in these three macros as a matter of fact because <code>rb_eval()</code> seems to be a method start of <code>rb_call()</code> by the evaluation of the receiver though it is imaginable somehow?Because it is not easy to understand if the story of [itere-ta] is not told, it explains <code>BEGIN_CALLARGS</code> and <code>END_CALLARGS</code> again by the next chapter 'Block'. I will investigate only <code>SETUP_ARGS()</code> here. </p> <h3><code>SETUP_ARGS()</code></h3> <p> <code>SETUP_ARGS()</code> is a macro that evaluates the argument part of the method. Because the variable named <code>argc</code> and <code>argv</code> is used, it is necessary to define it beforehand as being also in the comment on the former program in this macro. Moreover, Because <code>TMP_ALLOC()</code> is used, it is necessary to use <code>TMP_PROTECT</code>. Therefore, it is a fixed form to do as follows. </p> <pre class="emlist">
int argc; VALUE *argv; /* used in SETUP_ARGS */ TMP_PROTECT; SETUP_ARGS(args_node);
</pre> <p> <code>Args_node</code> changes into the array of the value in which it is evaluated by the argument of the method (node that expresses [wo]), and it stores it in <code>argv</code>. Then, let's see. </p> <p class="caption">- <code>SETUP_ARGS()</code></p> <pre class="longlist">
Argument..usually..argument..argument..provide. Argument..array..
argument..block..argument.(0) (eval.c) </pre> <p>I am not scared actually very much because it has clearly diverged to three though it is long for a moment. The meaning of each branch is as putting it in the comment. </p> <p>When there was no argument, it was assumed it was trivial, and looked like on two branches of the remainder. Doing is three stages when roughly saying. </p> <ol> <li>The area where the argument is put is secured. </li> <li>The expression of the argument is evaluated. </li> <li>The value is copied onto the variable area. </li> </ol> <p>[Dearu]. It is a long ages when writing it in the code (Underwent plastic operation for a moment incidentally. )</p> <pre class="emlist">
/***** Paragraph else if and argc. =0 *****/ int i; n = anode; argv = TMP_ALLOC(argc); /* 1 */ for (i = 0; i &lt; argc; i++) { argv[i] = rb_eval(self, n-&gt;nd_head); /* 2,3 */ n = n-&gt;nd_next; }
/***** Paragraph else *****/
VALUE args = rb_eval(self, n); /* 2 */ if (TYPE(args) != T_ARRAY) args = rb_ary_to_ary(args); argc = RARRAY(args)-&gt;len; argv = ALLOCA_N(VALUE, argc); /* 1 */ MEMCPY(argv, RARRAY(args)-&gt;ptr, VALUE, argc); /* 3 */ </pre> <p> It is [ro] ..putting out.. ..floatage.. . to use alloca() ALLOCA_N() </code>,in a word, usual why. <code></code><code></code><code></code> <code><code></code>Isn't <code>alloca()</code> dangerous in ..<code>C_ALLOCA</code>.. environment because it is equal to <code>malloc()</code>?</p> <p>In this respect, "There is a value of the argument also in <code>args</code> on the <code>else</code> side" is a point. It becomes as shown in Figure 1 if it makes it to figure. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_method_anchor.jpg" alt="(anchor)"><br>Figure 1: It is safe even in case of being in the heap. </p> <p>It is marked in the chain via there if there is as much as one <code>VALUE</code> in the stack. <code>Such..other..stack..grow thick..stop..anchor..role..accomplish..that is..become.</code><code></code><code></code><code>Args</code> is <code>anchor VALUE</code> on the <code>else</code> side. </p> <p>By the way, <code>anchor VALUE</code> is coinage made now. </p> <h3><code>rb_call()</code></h3> <p>If anything, <code>SETUP_ARGS()</code> is a sideway. Let's get back to the main subject here. It is function <code>rb_call()</code> that starts the method. Everything is omitted according to the example though there is a code in which the exception is raised when not found in the real thing. </p> <p class="caption">- <code>rb_call()</code>(abridgment version)</p> <pre class="longlist">
static VALUE rb_call(klass, recv, mid, argc, argv, scope) VALUE klass, recv; ID mid; int argc; const VALUE *argv; int scope; {
NODE *body; int noex; ID id = mid; struct cache_entry *ent; /* The method cash is retrieved */ ent = cache + EXPR1(klass, mid); if (ent-&gt;mid == mid &amp;&amp; ent-&gt;klass == klass) { /* */ that becomes a hit to cash klass = Ent-&gt; origin; id = ent-&gt;mid0; noex = ent-&gt;noex; body = ent-&gt;method; }
else { /* Cash mistake. It honestly retrieves it */ body = Rb_get_
method_body(&klass, &id, &noex); }
/*…… The visibility is checked ……*/. return rb_call0(klass, recv, mid, id, argc, argv, body, noex &amp; NOEX_UNDEF);
}
</pre> <p>The basic method search method was spoken by 'Object' Chapter 2. It only has to retrieve <code>m_tbl</code> while tracing a super-class. Doing it It was <code>search_method()</code>. </p> <p>The speed is too slow to do and to pull and to have retrieved the hush to an actual oak many times at each method call when becoming executed steps though the principle is the street. To improve this, the method of the call once is cached in <code>ruby</code>. It is often called at once again, and it is known ..experience.. for a fact, and the hit rate of this cash is high. the method of calling once</p> <p>It is rope [iteiruno] the cash and the first half of <code>rb_call()</code>. [Kono]</p> <pre class="emlist">
ent = cache + EXPR1(klass, mid);
</pre> <p>It drinks and cash is retrieved only by the line. I will see the mechanism later in detail. </p> <p>When cash comes off, the class tree is honestly retrieved with the following <code>rb_get_method_body()</code>, and the result is cached incidentally. If the flow of the entire retrieval is made figure, it is feeling as shown in Figure 2. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_method_msearch.jpg" alt="(msearch)"><br>Figure 2: Method search</p> <h3>Method cash</h3> <p>Next, let's see the structure of the method cash in detail. </p> <p class="caption">- Method cash</p> <pre class="longlist">
180 #define CACHE_SIZE 0x800 181 #define CACHE_MASK 0x7ff 182 #
define EXPR1(c,m) ((((c)&gt;&gt;3)^(m))&amp;CACHE_MASK) 183 184 struct cache_entry { /* method hash table. */ 185 ID mid; /* method'
s id */ 186 ID mid0; /* method's original id */ 187 VALUE klass; /* receiver's class */ 188 VALUE origin; /* where method defined */ 189 NODE *method; 190 int noex; 191 }; 192 193 static struct cache_entry cache[CACHE_SIZE]; (eval.c)
</pre> <p>In a word, it is a hush table as for the mechanism. It converted in the principle and [hayousuru] of the hush table and the table retrieval was converted into the indexing of the array. The one needed at that time is three. It is an array, a key, and a hash function in which data is stored. </p> <p>First of all, the array is an array of <code>struct cache_entry</code> here. And, because the method is uniquely decided the class only by the method name, this two becomes keys to the hush calculation. It only has to make the hash function in which index <code>(0x000-0x7ff)</code><code></code> of the cash array is generated from the key. It is <code>EXPR1()</code>. The class do ..<code>c</code> of the argument.. object, and <code>m</code> is a method name (..drinking.. <code>ID</code>)(Figure 3). </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_method_mhash.jpg" alt="(mhash)"><br>Figure 3: Method cash</p> <p>However, a different method can generate the same index to the perfect hash function by chance as for <code>EXPR1()</code> because it is nothing. However, there is no problem even if colliding because this is cash to the end. However, operation only slows a little. </p> <h4>Effect of method cash</h4> <p>By the way, how much is the method cash actually effective? It is not possible to consent even if said, "…… It is known". It is a measurement by I. </p> <table> <tr><td>Kind<td><td>Program<td><td>Hit rate<td></tr> <tr><td>LALR(1) parser generation<td><td><code>racc ruby.y</code><td><td>99.9%<td></tr> <tr><td>Mail thread generation<td><td>Certain [me-ra]<td><td>99.1%<td></tr> <tr><td>Document generation<td><td><code>rd2html rubyrefm.rd</code><td><td>97.8%<td></tr> </table> <p>Very, the hit rate 95% or more was recorded by all of the three experimented examples. This is terrible. Apparently, the effect of "…… It is known" seems to be preeminent. </p> <h2>Start</h2> <h3><code>rb_call0()</code></h3> <p>It is re-..this <code>rb_call0()</code>.. ..deca.. ..saying.. . because it reached the method start at last for various reasons at last. Do it become 5 and page 6 200 lines or more on the page?It will see while dividing in detail because it becomes a miserable thing if it arranges it with paper at any rate at a dash if it is a viewer. First of all, from [**katachi]. </p> <p class="caption">- <code>rb_call0()</code>([**katachi])</p> <pre class="longlist">
4482 static VALUE 4483 rb_call0(klass, recv, id, oid, argc, argv, body, nosuper) 4484 VALUE klass, recv; 4485 ID id; 4486 ID oid; 4487 int argc; /* OK */ 4488 VALUE *argv; /* OK */ 4489 NODE *body; /* OK */ 4490 int nosuper; 4491 { 4492 NODE *b2; /* OK */ 4493 volatile VALUE result = Qnil; 4494 int itr; 4495 static int tick; 4496 TMP_PROTECT; 4497 4498 switch (ruby_iter-&gt;iter) { 4499 case ITER_PRE: 4500 itr = ITER_CUR; 4501 break; 4502 case ITER_CUR: 4503 default: 4504 itr = ITER_NOT; 4505 break; 4506 } 4507 4508 if ((++tick &amp; 0xff) == 0) { 4509 CHECK_INTS; /* better than nothing */ 4510 stack_check(); 4511 } 4512 PUSH_ITER(itr); 4513 PUSH_FRAME(); 4514 4515 ruby_frame-&gt;last_func = id; 4516 ruby_frame-&gt;orig_func = oid; 4517 ruby_frame-&gt;last_class = nosuper?0:klass; 4518 ruby_frame-&gt;self = recv; 4519 ruby_frame-&gt;argc = argc; 4520 ruby_frame-&gt;argv = argv; 4521 4522 switch (nd_type(body)) { /*…… This processing ……*/
4698 4699 default: 4700 rb_bug("unknown node type %d", nd_type(body)); 4701 break; 4702 } 4703 POP_FRAME(); 4704 POP_ITER(); 4705 return result; 4706 } (eval.c)
</pre> <p>It is finally first decided whether this method is [itere-ta] piling up <code>ITER</code>. <code>PUSH_ITER()</code> should be ahead of that because the value is used at once with <code>PUSH_FRAME()</code> afterwards. <code>PUSH_FRAME()</code> will be seen later soon. </p> <p>And, it divides into here according to the following nodes when the story in "…… this processing ……" is previously told and the start processing is done respectively. </p> <table> <tr><td><code>NODE_CFUNC</code><td><td>Method defined by C<td></tr> <tr><td><code>NODE_IVAR</code><td><td><code>attr_reader</code><td></tr> <tr><td><code>NODE_ATTRSET</code><td><td><code>attr_writer</code><td></tr> <tr><td><code>NODE_SUPER</code><td><td><code>super</code><td></tr> <tr><td><code>NODE_ZSUPER</code><td><td><code>Super</code> without argument<td></tr> <tr><td><code>NODE_DMETHOD</code><td><td>Start of <code>UnboundMethod</code><td></tr> <tr><td><code>NODE_BMETHOD</code><td><td>Start of <code>Method</code><td></tr> <tr><td><code>NODE_SCOPE</code><td><td>Method defined by Ruby<td></tr> </table> <p>You may disregard it because all are pierced and it is not important though there is the one doesn't explain in this book either. The important one is only <code>NODE_ZSUPER</code> in <code>NODE_CFUNC</code>, <code>NODE_SCOPE</code>, and it. </p> <h3><code>PUSH_FRAME()</code></h3> <p class="caption">- <code>PUSH_FRAME() POP_FRAME()</code></p> <pre class="longlist">
536 #define PUSH_FRAME() do { \ 537 struct FRAME _frame; \ 538 _
frame.prev = ruby_frame; \ 539 _frame.tmp = 0; \ 540 _frame.node = ruby_current_node; \ 541 _frame.iter = ruby_iter-&gt;iter; \ 542 _
frame.cbase = ruby_frame-&gt;cbase; \ 543 _frame.argc = 0; \ 544 _
frame.argv = 0; \ 545 _frame.flags = FRAME_ALLOCA; \ 546 ruby_frame = &amp;_frame 548 #define POP_FRAME() \ 549 ruby_current_node = _frame.node; \ 5
50 ruby_frame = _frame.prev; \ 551 } while (0) (eval.c)
</pre> <p>First of all, I want to confirm <code>FRAME</code> is securing putting [sutakkubeta]. Here It is the same as <code>module_setup()</code>. Basically usual initialization is only done. </p> <p>Will if only one is added, the flag named <code>FRAME_ALLOCA</code> be [kurai] ..showing.. as for those who allocate it about <code>FRAME</code>?Of course, <code>FRAME_ALLOCA</code> shows "It is in the stack". </p> <h3><code>rb_call0()</code>-<code>NODE_CFUNC</code></h3> <p>Most : though it writes variously in a code here when the real thing is seen A substantial code ends by the following lines because it is <code>trace_func</code> relation. </p> <p class="caption">- <code>rb_call0()</code>-<code>NODE_CFUNC</code>(abridgment version)</p> <pre class="longlist">
case NODE_CFUNC: result = call_cfunc(body-&gt;nd_cfnc, recv, len, argc, argv); break;
</pre> <p>Ignorance …… <code>call_cfunc()</code> [hato] [i] then</p> <p class="caption">- <code>call_cfunc()</code>(abridgment version)</p> <pre class="longlist">
4394 static VALUE 4395 call_cfunc(func, recv, len, argc, argv) 4396 VALUE (*func)(); 4397 VALUE recv; 4398 int len, argc; 4399 VALUE *argv; 4400 { 4401 if (len &gt;= 0 &amp;&amp; argc != len) { 4402 rb_raise(rb_eArgError, "
wrong number of arguments(%d for %d)", 4403 argc, len); 4404 } 4405 4406 switch (len) { 4407 case -2: 4408 return (*func)(recv, rb_ary_new4(argc, argv)); 4409 break; 4410 case -1: 4411 return (*func)(argc, argv, recv); 4412 break; 4413 case 0: 4414 return (*func)(recv); 4415 break; 4416 case 1: 4417 return (*func)(recv, argv[0]); 4418 break; 4419 case 2: 4420 return (*func)(recv, argv[0], argv[1]); 4421 break; : : 4475 default: 4476 rb_raise(rb_eArgError, "too many arguments(%d)", len); 4477 break; 4478 } 4479 return Qnil; /* not reached */ 4480 } (eval.c)
</pre> <p>Thus, it only diverges in proportion to the number of arguments. By the way, the maximum number of arguments is 15. </p> <p>To want you to note it by one is to pile up neither <code>SCOPE</code> nor <code>VARS</code> at <code>NODE_CFUNC</code>. It is natural because the local variable of Ruby is not used if the method is defined by <code>C</code> if it is said it is natural. However, when it accesses "Present" local variable from <code>C</code> at the same time, it means the local variable of previous one <code>FRAME</code> is seen. And, it is actually done. For instance, The <code>rb_svar(eval.c)</code><code></code> etc.</p> <h3><code>rb_call0()</code>-<code>NODE_SCOPE</code></h3> <p>It is a start of the method of the definition with <code>NODE_SCOPE</code>, that is, Ruby. It is a part where the base of Ruby is done. </p> <p class="caption">- <code>rb_call0()</code>-<code>NODE_SCOPE</code>([**katachi])</p> <pre class="longlist">
4568 case NODE_SCOPE: 4569 { 4570 int state; 4571 VALUE *local_vars; /* OK */ 4572 NODE *saved_cref = 0; 4573 4574 PUSH_SCOPE(); 4575 /* (A) CREF transmission */
4576 if (body-&gt;nd_rval) { 4577 saved_cref = ruby_cref; 4578 ruby_cref = (NODE*)body-&gt;nd_rval; 4579 ruby_frame-&gt;cbase = body-&gt;nd_rval; 4580 } /* (B) ruby_scope-&gt; local_vars initialization */
4581 if (body-&gt;nd_tbl) { 4582 local_vars = TMP_ALLOC(body-&gt;nd_
tbl[0]+1); 4583 *local_vars++ = (VALUE)body; 4584 rb_mem_clear(local_vars, body-&gt;nd_tbl[0]); 4585 ruby_scope-&gt;local_tbl = body-&gt;nd_tbl; 4586 ruby_scope-&gt;local_vars = local_vars; 4587 } 4588 else { 4589 local_vars = ruby_scope-&gt;local_vars = 0; 4590 ruby_scope-&gt;local_tbl = 0; 4591 } 4592 b2 = body = body-&gt;nd_next; 4593 4594 PUSH_VARS(); 4595 PUSH_TAG(PROT_FUNC); 4596 4597 if ((state = EXEC_TAG()) == 0) { 4598 NODE *node = 0; 4599 int i; /*…… (C) The argument is substituted for the local variable …
…*/. 4666 if (trace_func) { 4667 call_trace_func("call", b2, recv, id, klass); 4668 } 4669 ruby_last_node = b2; /* Main body of method of (D) */
4670 result = rb_eval(recv, body); 4671 } /* It returned with return */. 4673 result = prot_tag-&gt;retval; 4674 state = 0; 4675 } 4676 POP_TAG(); 4677 POP_VARS(); 4678 POP_SCOPE(); 4679 ruby_cref = saved_cref; 4680 if (trace_func) { 4681 call_trace_func("return", ruby_last_node, recv, id, klass); 4682 } 4683 switch (state) { 4684 case 0: 4685 break; 4686 4687 case TAG_RETRY: 4688 if (rb_block_given_p()) { 4689 JUMP_TAG(state); 4690 } 4691 /* fall through */ 4692 default: 4693 jump_tag_but_local_jump(state); 4694 break; 4695 } 4696 } 4697 break; (eval.c)
</pre> <p>(A) <code>CREF</code> spoken by the constant in the preceding chapter is transmitted. In a word, <code>cbase</code> is transplanted from the method entry to <code>FRAME</code>. </p> <p>(B) A content here is quite the same as <code>module_setup()</code>. The array is allocated in <code>local_vars</code> of <code>SCOPE</code>. The scope generation of the local variable was completed by this, <code>PUSH_SCOPE()</code>, and <code>PUSH_VARS()</code>. It can <code>rb_eval()</code> it in quite the same environment in the method after this. </p> <p>(C) The received argument is set in the parameter variable of the method. It is the same one in the parameter variable and [hayousuru] as the local variable. Because the number of arguments etc. are specified with <code>NODE_ARGS</code>, it only has to set it honestly. After this, let's immediately explain details. And,</p> <p>(D) The main body of the method is executed. Receiver <code>(recv)</code> is naturally made <code>self</code>. In a word, it makes it to the first argument of <code>rb_eval()</code>. The method started completely by this. </p> <h3>Set of argument</h3> <p>I want you to see first of all ..syntax tree of method.. again ahead of that though the [bashita] argument set ..feeling refreshed.. part then is seen in detail. </p> <pre class="screen">
% ruby -rnodedump -e 'def m(a) nil end' NODE_SCOPE nd_rval = (null) nd_tbl = 3 [ _ ~ a ] nd_next: NODE_BLOCK nd_head: NODE_ARGS nd_cnt = 1 nd_rest = -1 nd_opt = (null) nd_next: NODE_BLOCK nd_head: NODE_NEWLINE nd_file = "-e" nd_nth = 1 nd_next: NODE_NIL nd_next = (null)
</pre> <p>It is a node by which <code>NODE_ARGS</code> specifies the parameter of the method. The member seems to be handled as follows when some are dumped and it rolls it up. </p> <table> <tr><td><code>nd_cnt</code><td><td>Number of usual parameters. <td></tr> <tr><td><code>nd_rest</code><td><td>Variable <code>ID</code> of <code>rest</code> parameter. It is <code>-1</code> if there is no <code>rest</code> parameter. <td></tr> <tr><td><code>nd_opt</code><td><td>There is a syntax tree that expresses the default value of an optional parameter. List of <code>NODE_BLOCK</code>. <td></tr> </table> <p>Local variable ID corresponding to each parameter variable is uniquely decided if there is information only on this. 0 and 1 was always <code>$_</code> first of all and <code>$~</code>. A usual parameter queues up from the following two of that and only the number queues up. It is the row of an optional parameter as follows again. The number of optional parameters is understood from the length of <code>NODE_BLOCK</code>. The rest parameter comes after again ..that... </p> <p>For instance, when defining it as follows</p> <pre class="emlist">
def m(a, b, c = nil, *rest) lvar1 = nil end </pre> <p>Local variable ID is allocated as follows. </p> <pre class="emlist">
0 1 2 3 4 5 6 $_ $~ a b c rest lvar1 </pre> <p>Is it good?Then, let's see the code based on this. </p> <p class="caption">- Substitution of <code>rb_call0()</code>-<code>NODE_SCOPE</code>-argument</p> <pre class="longlist">
Main body of /* none */
4602 node = body; /* NODE_ARGS */ 4603 body = 0; /* main body */ of method 4604
There is a main body of /* */. 4606 node = body-&gt;nd_head; /* NODE_ARGS */ 4607 body = body-&gt;nd_next; /* main body */ of method 4608 Some..
parameter.
4612 } 4613 4614 i = node-&gt;nd_cnt; 4615 if (i &gt; argc) { 4616 rb_raise(rb_eArgError, "wrong number of arguments(%d for %d)", 4617 argc, i); 4618 } /* There is no rest parameter */. /* The number of parameters is counted */. 4620 int opt = i; /* number of parameters (I is nd_cnt) */. 4621 NODE *optnode = node-&gt;nd_opt; 4622 4623 while (optnode) { 4624 opt++; 4625 optnode = optnode-&gt;nd_next; 4626 } 4627 if (opt &lt; argc) { 4628 rb_raise(rb_eArgError, 4629 "wrong number of arguments(%d for %d)", argc, opt); 4630 } /* It substitutes in rb_call0 the second */. 4631 ruby_frame-&gt;argc = opt; 4632 ruby_frame-&gt;argv = local_vars+2; 4633 } 4634 Parameter..usually..parameter..area..avoid.
Optional..parameter.
4643 4644 while (opt &amp;&amp; argc) { 4645 assign(recv, opt-&gt;nd_head, *argv, 1); 4646 argv++; argc--; 4647 opt = opt-&gt;nd_next; 4648 } 4649 if (opt) { 4650 rb_eval(recv, opt); 4651 } 4652 } 4653 local_vars = ruby_scope-&gt;local_vars; Parameter.
4656 /* The remaining argument is made an array and it substitutes it for the variable */. 4657 if (argc &gt; 0) 4658 v = rb_ary_new4(argc,argv); 4659 else 4660 v = rb_ary_new2(0); 4661 ruby_scope-&gt;local_vars[node-&gt;nd_rest] = v; 4662 } 4663 } 4664 } (eval.c) </pre> <p>I will understand doing if it is possible to get it later honestly while seeing it because it put the comments more than the current. </p> <p>It is <code>argc</code> and <code>argv</code> of <code>ruby_frame</code> anxious by one. Is it good when there is no rest parameter alone though it updates when there is no rest parameter alone why?</p> <p>This respect is understood when thinking about the usage of <code>argc</code> and <code>argv</code>. This member exists for <code>super</code> that actually omits the argument. It is the in a word following forms. </p> <pre class="emlist">
super </pre> <p>There is working that passes the parameter of the method of the present execution in off as it is in <code>super</code> here. Because to pass it at that time, argument is preserved in <code>ruby_frame-&gt; argv</code></p> <p>I think that it seems to be convenient somehow to pass former argument list in <code>super</code> when there is rest parameter when returning to former story here. The one after an optional parameter is substituted seems to be better at the time of not being. </p> <pre class="emlist">
def m(a, b, *rest) .... end m(5, 6, 7, 8) def m(a, b = 6) .... end m(5) </pre> <p>This is a problem which is good as the specification rather than "Otherwise, do not become it". The possibility of becoming inconvenient when the value after it brings it together is passed because it is thought by the super-class that similarly, there is rest parameter if there is rest parameter in the method is very high. <p>Well, stories of the start of the method are this and all ends though said variously. Mounting <code>super</code> mentioned as finishing off this chapter now will be seen. </p> <h3><code>super</code></h3> <p>It is <code>NODE_SUPER</code> and <code>NODE_ZSUPER</code> to correspond to <code>super</code>. <code>NODE_SUPER</code> is usual <code>super</code>, and <code>NODE_ZSUPER</code> is <code>super</code> without the argument specification. </p> <p class="caption">- <code>rb_eval()</code>-<code>NODE_SUPER</code></p> <pre class="longlist">
2780 case NODE_SUPER: 2781 case NODE_ZSUPER: 2782 { 2783 int argc; VALUE *argv; /* used in SETUP_ARGS */ 2784 TMP_PROTECT; 2785 /* When (A) super is prohibited
2786 if (ruby_frame-&gt;last_class == 0) { 2787 if (ruby_frame-&gt;orig_func) { 2788 rb_name_error(ruby_frame-&gt;last_func, 2789 "superclass method `%s' disabled", 2790 rb_id2name(ruby_frame-&gt;orig_func)); 2791 } 2792 else { 2793 rb_raise(rb_eNoMethodError, "super called outside of method"); 2794 } 2795 } /* (B) Preparation or evaluation */ of argument
2796 if (nd_type(node) == NODE_ZSUPER) { 2797 argc = ruby_frame-&gt;argc; 2798 argv = ruby_frame-&gt;argv; 2799 } 2800 else { 2801 BEGIN_CALLARGS; 2802 SETUP_ARGS(node-&gt;nd_args); 2803 END_CALLARGS; 2804 } 2805 /* (C) still PUSH_ITER() of mystery */
2806 PUSH_ITER(ruby_iter-&gt;iter?ITER_PRE:ITER_NOT); 2807 SET_CURRENT_SOURCE(); 2808 result = rb_call(RCLASS(ruby_frame-&gt;last_class)-&gt;super, 2809 ruby_frame-
&gt;self, ruby_frame-&gt;orig_func, 2810 argc, argv, 3); 2811 POP_ITER(); 2812 } 2813 break; (eval.c)
</pre> <p>It has gone out straight to (B) though it was said that <code>ruby_frame-&gt; argv</code> would be made an argument as it was in <code>super</code> without the argument specification. </p> <p>(C) It <code>PUSH_ITER()s it </code>immediately before <code>rb_call()</code> is called. This can also in detail completely transfer the block passed to a present method to the following method (method of a super-class that will call in the future in a word) as it is by putting it thus though cannot explain. </p> <p>And, when (A) <code>ruby_frame-&gt; last_class</code> is 0, it seems to prohibit the call of <code>super</code> at the end. To the error message If <code>rb_enable_super()</code> is called, it seems to come to be able to be called <code>"must be enabled by rb_enable_super()"</code> safely because it is. [Darou] . why</p> <p>Substance : very much when examining it what time <code>last_class</code>'s first becoming 0 It seems to be so while method <code>(NODE_CFUNC)</code> defined by C is executed. In addition, when such a method is done or is replaced in <code>alias</code>, it is the same. </p> <p>Even if the source code is read, the continuation is not understood though it understood there. The log of the mailing list of <code>ruby</code> reluctantly because it did not understand It retrieved by <code>"rb_enable_super"</code> and it discovered it. It is the following according to the mail. </p> <p>For instance, there is a method named <code>String.new</code>. Of course, it is a method of generating the character string. <code>String.new</code> makes [tsukutai] of ..<code>T_STRING</code>.. [kama]. Therefore, the receiver may write the method of the instance of <code>String</code> always expecting that it is <code>T_STRING</code>. </p> <p>Well, <code>super</code> of <code>String.new</code> is <code>Object.new</code>. <code>Object.new</code> [Tsukutai] of .. <code>T_OBJECT</code>.. [kama] is made. Then, if <code>String.new</code> is replaced, defined, and <code>super</code> is done, it is likely to become it very. </p> <pre class="emlist">
def String.new super end </pre> <p>Consequently, the class can be done though the structure is <code>T_OBJECT</code> and the object named <code>String</code> be worn. However, it falls naturally because the method of <code>String</code> writes the structure of <code>T_STRING</code> expecting it. </p> <p>When whether goodness when doing very to avoid it is said, the method of expecting a different structure type cannot only have to be called. It is "Expected structure type. " in the method however Information doesn't adhere, and not exist even in the class either. For instance, from the <code>String</code> class This cannot be done now though it is possible to check before it calls if there is a method of taking <code>T_STRING</code>. Therefore, it is made it to "Method to define by C <code>Super</code> is prohibited" as a the next best thing. In that case, it is not possible to drop for the time being if the method hierarchy at C level is tightly made. And, <code>super</code> can come to be done if <code>rb_enable_super()</code> is called in case of "It wants you to do <code>super</code> because it is absolutely safe". </p> <p>The true nature of the problem is a structure type mismatch to [yousuru]. It is the same as the problem of happening by the allocation framework. </p> <p>And, it only has to solve the point "The class doesn't know the structure type of the instance" that is the root of the whole problem as a solution when saying how it is necessary to do. However, even if it is the lowest, new API is needed, and it becomes incompatible for that if it does more thoroughly. At present, the ultimate solution has not been decided because of this yet. <hr> <p>The point of an opinion, an impression, and a mis-plant etc. are <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fmailto%3Aaamine%40loveruby.net&wb_lp=JAEN&wb_dis=2">[mine**] Aoki Thank you very much even for &lt; aamine@loveruby.net &gt;</a>. </p> <p> <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fdirect.ips.co.jp%2Fdirectsys%2Fgo_x_TempChoice.cfm%3Fsh_id%3DEE0040%26amp%3Bspm_id%3D1%26amp%3BGM_ID%3D1721&wb_lp=JAEN&wb_dis=2">It is possible to reserve ..direct ..'Ruby source code complete explanation'.. IMPRESS it.. and to buy it (Fly to the book introduction page. )</a> </p> <p>Copyright (c) 2002-2004 Minero Aoki, All rights reserved.</p> </body> </html>
<script src="http://rep.excite-webtl.jp/urchin.js" type="text/javascript"></script>
<script type="text/javascript">
_udn="excite-webtl.jp";
urchinTracker();
</script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-400370-52");
pageTracker._initData();
pageTracker._trackPageview();
</script>
