<SCRIPT LANGUAGE="JavaScript">
<!--
var originalUrl="http://i.loveruby.net/ja/rhg/book/anyeval.html";
var originalLp ="JAEN";
var originalDis="";
if (self.parent.excite_header.display) {
self.parent.excite_header.display.wb_url.value = originalUrl;
self.parent.excite_header.display.wb_lp.value = originalLp;
}
//-->
</SCRIPT>
<SCRIPT LANGUAGE="JavaScript">
<!--
if (top.excite_header)
{
// ok
}
else
{
top.location.href = "http://www.excite-webtl.jp/world/english/web/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fanyeval.html&wb_lp=JAEN&wb_dis=";
}
//-->
</SCRIPT>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP"> <head><base href=http://i.loveruby.net/ja/rhg/book/anyeval.html> <meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"> <meta http-equiv="Content-Language" content="ja-JP"> <link rel="stylesheet" type="text/css" href="rhg.css"> <link rev="made" href="mailto:aamine@loveruby.net"> <title>Chapter 17 Dynamic evaluation</title></head> <body> <h1>Chapter 17 Dynamic evaluation</h1> <h2>Outline</h2> <p>It has already been concluded about deflecting of the mechanism of the evaluation machine in the preceding chapter. Let's verify the whole image as "Evaluation machine in the wide sense" that adds the parser to the all by this chapter. It is three. <code>eval･Module#module_eval･Object#instance_eval</code><code></code><code></code> becoming an object</p> <h3><code>eval</code></h3> <p>I will tell a more detailed story here though <code>eval</code> has already been spoken. </p> <p>The character string is compiled in the place when executing it when <code>eval</code> is used, and it is possible to evaluate it. The return value is a value of the last expression of the program. </p> <pre class="emlist">
p eval("1 + 1") # 2 </pre> <p>The variable in the scope can be referred to from among the character string that does <code>eval</code>. </p> <pre class="emlist">
lvar = 5 @ivar = 6 p eval("lvar + @ivar") # 11 </pre> <p>It becomes impossible to skip word "The scope" cheaply if the reader has read here. For instance, is not "Scope" of the constant how becomes, and how anxious?The author is anxious. You may think that it basically succeeds the environment outside <code>eval</code> as it is when saying from the conclusion. </p> <p>Moreover, the method definition and the class definition can be done. </p> <pre class="emlist">
def a eval('class C; def test() puts("ok") end end') end A() # class C and C#test are defined. C.new.test # It is displayed as ok. </pre> <p>In addition, when <code>Proc</code> is passed to the second argument, it is appreciable in the environment though it referred a little in the preceding chapter. </p> <pre class="emlist">
def new_env n = 5 This..method..environment..object..do..return.
p eval('n * 3', new_env()) # 15 </pre> <h3><code>Module_eval</code> and <code>instance_eval</code></h3> <p>When <code>Proc</code> was passed to the second argument of <code>eval</code>, it was appreciable in the environment. With <code>module_eval</code> <code>Instance_eval</code> is the limited edition (Or, short cut). It is appreciable in the environment in <code>module_eval</code> like it is in the module sentence and the class sentence. </p> <pre class="emlist">
Local variable for lvar ="Toplevel lvar" # scope confirmation
module M end M.module_eval (&lt;&lt; 'EOS') It is ..#.. [hiadokyumento] only at such time. P lvar # can be referred to. P self # It is displayed as M. Def ok # M#ok is defined. puts 'ok' end EOS </pre> <p> <code>Instance_eval</code> is appreciable in the environment that <code>self</code> becomes the object by the peculiar class sentence. </p> <pre class="emlist">
Local variable for lvar ="Toplevel lvar" # scope confirmation
obj = Object.new obj.instance_eval(&lt;&lt;'EOS') P lvar # can be referred to. It is displayed as p self ## &lt; Object:0x40274f5c &gt; def ok # Obj.ok is defined. puts 'ok' end EOS </pre> <p>Moreover, the block is evaluated in that case by being able to use this <code>module_eval</code> and <code>instance_eval</code> as [itere-ta] in each environment. For instance,</p> <pre class="emlist">
obj = Object.new p obj # #&lt;Object:0x40274fac&gt; obj.instance_eval { p self # #&lt;Object:0x40274fac&gt; }
</pre> <p>Way. </p> <p>However, behavior in the local variable circumference is different when the character string is used and when the block is used. For instance, refer to the local variable of <code>a</code> for the block when you do <code>instance_eval</code> by method <code>b</code> of making the block in method <code>a</code>. Refer to the local variable of <code>b</code> from among the character string when you do <code>instance_eval</code> by method <code>b</code> of making the character string in method <code>a</code>. Because because "Compile" is decided to the scope of the local variable to the end, the result is different in the block compiled when the character string and the file are loaded the usual compilation. </p> <h2><code>eval</code></h2> <h3><code>eval()</code></h3> <p>The call form : because there are a lot of case division of <code>eval</code> of Ruby none in there is an argument. </p> <pre class="emlist">
eval(prog_string, some_block)
</pre> <p>It limits it. Then, because actual interface function <code>rb_f_eval()</code> becomes hardly significant, it will see from the <code>eval()</code> of the function under another. The function prototype of <code>eval()</code></p> <pre class="emlist">
static VALUE eval(VALUE self, VALUE src, VALUE scope, char *file, int line);
</pre> <p>[De] and <code>scope</code> are <code>Proc</code> of the second argument. <code>File</code> and <code>line</code> are the file names assumed that there is a character string that does <code>eval</code> and line numbers. Then, let's see contents. </p> <p class="caption">- <code>eval()</code>(abridgment version)</p> <pre class="longlist">
4984 static VALUE 4985 eval(self, src, scope, file, line) 4986 VALUE self, src, scope; 4987 char *file; 4988 int line; 4989 { 4990 struct BLOCK *data = NULL; 4991 volatile VALUE result = Qnil; 4992 struct SCOPE * volatile old_scope; 4993 struct BLOCK * volatile old_block; 4994 struct RVarmap * volatile old_dyna_vars; 4995 VALUE volatile old_cref; 4996 int volatile old_vmode; 4997 volatile VALUE old_wrapper; 4998 struct FRAME frame; 4999 NODE *nodesave = ruby_current_node; 5000 volatile int iter = ruby_frame-&gt;iter; 5001 int state; 5002 It is always truth */ /* now 5009 Data_Get_Struct(scope, struct BLOCK, data); 5010 /* */ that piles up BLOCK from data 5011 frame = Data-&gt; frame;
5012 frame.tmp = ruby_frame; /* GC avoiding */
5013 ruby_frame = &amp;(frame); 5014 old_scope = ruby_scope; 5015 ruby_scope = data-&gt;scope; 5016 old_block = ruby_block; 5017 ruby_block = data-&gt;prev; 5018 old_dyna_vars = ruby_dyna_vars; 5019 ruby_dyna_vars = data-&gt;dyna_vars; 5020 old_vmode = scope_vmode; 5021 scope_vmode = data-&gt;vmode; 5022 old_cref = (VALUE)ruby_cref; 5023 ruby_cref = (NODE*)ruby_frame-&gt;cbase; 5024 old_wrapper = ruby_wrapper; 5025 ruby_wrapper = data-&gt;wrapper; 5032 self = data-&gt;self; 5033 ruby_frame-&gt;iter = data-&gt;iter; 5034 } 5045 PUSH_CLASS(); 5046 ruby_class = ruby_cbase; /* == ruby_frame-&gt;cbase */ 5047 5048 ruby_in_eval++; 5049 if (TYPE(ruby_class) == T_ICLASS) { 5050 ruby_class = RBASIC(ruby_class)-&gt;klass; 5051 } 5052 PUSH_TAG(PROT_NONE); 5053 if ((state = EXEC_TAG()) == 0) { 5054 NODE *node; 5055 5056 result = ruby_errinfo; 5057 ruby_errinfo = Qnil; 5058 node = compile(src, file, line); 5059 if (ruby_nerrs &gt; 0) { 5060 compile_error(0); 5061 } 5062 if (!NIL_P(result)) ruby_errinfo = result; 5063 result = eval_node(self, node); 5064 } 5065 POP_TAG(); 5066 POP_CLASS(); 5067 ruby_in_eval--; It is always truth */ /* now 5069 int dont_recycle = ruby_scope-&gt; flags & SCOPE_DONT_RECYCLE; 5070 5071 ruby_wrapper = Old_wrapper;
5072 ruby_cref = (NODE*)old_cref; 5073 ruby_frame = frame.tmp; 5074 ruby_scope = old_scope; 5075 ruby_block = old_block; 5076 ruby_dyna_vars = old_dyna_vars; 5077 data-&gt;vmode = scope_vmode; /* The change in the visibility scope is preserved */. 5078 scope_vmode = old_vmode; 5079 if (dont_recycle) { /*…… SCOPE･BLOCK･VARS is copied ……*/. 5097 } 5098 } 5104 if (state) { 5105 if (state == TAG_RAISE) { /*…… The exception object is prepared ……*/. 5121 rb_exc_raise(ruby_errinfo); 5122 } 5123 JUMP_TAG(state); 5124 } 5125 5126 return result; 5127 } (eval.c)
</pre> <p>It will become "[Gua;]" if this function is suddenly shown none as for introductory remarks, and is not an enemy any longer for us who has defeated the function of <code>eval.c</code> here. This function is single-mindedly saved and ..stack.. has returned. The place in which it should note it is only the following three points. </p> <ul> <li><code>FRAME</code> (It is not copy a push) is replaced unusually. </li> <li><code>Ruby_cref</code> is substituted with <code>ruby_frame-&gt; cbase</code> (?). </li> <li>Only <code>scope_vmode</code> influences not a simple return but <code>data</code>. </li> </ul> <p>And, the main part is <code>compile()</code> near the center and <code>eval_node()</code>. It is a function that begins argument <code>node</code> evaluation though <code>eval_node()</code> seems may already be forgotten. It ..<code>ruby_run()</code>.. was used. </p> <p> <code>Compile()</code> is a long ages. </p> <p class="caption">- <code>compile()</code></p> <pre class="longlist">
4968 static NODE* 4969 compile(src, file, line) 4970 VALUE src; 4971 char *file; 4972 int line; 4973 { 4974 NODE *node; 4975 4976 ruby_nerrs = 0; 4977 Check_Type(src, T_STRING); 4978 node = rb_compile_string(file, src, line); 4979 4980 if (ruby_nerrs == 0) return node; 4981 return 0; 4982 } (eval.c)
</pre> <p> <code>Ruby_nerrs</code> is a variable that the increment is done in <code>yyerror()</code>. In a word, if this variable is non-zero, it is shown that [pa-suera-] happened. Moreover, <code>Rb_compile_string()</code> has already been treated secondarily. It was a function that compiled the character string of Ruby to the syntax tree. </p> <p>Becoming a problem one here is a local variable. Chapter 12 The local variable was to have managed by using <code>lvtbl</code> like 'Construction of the syntax tree'. However, because <code>SCOPE</code> (<code>VARS</code> also possibly :) has already existed now, it is necessary to do Perth in shape to add the superscription to it. This is actually a core of <code>eval()</code>, and the worst difficult point. It returns to <code>parse.y</code> again and this search will be concluded. </p> <h3><code>top_local</code></h3> <p>Using it when management table <code>struct local_vars</code> of the local variable is piled up <code>local_push() There are actually another pair function that piles up the table for management in <code>parse.y</code> though it was a function named local_pop()</code>. It is <code>top_local_init()</code> and <code>top_local_setup()</code>. It is called by such feeling. </p> <p class="caption">- Those who are called about <code>top_local_init()</code></p> <pre class="longlist">
program : { top_local_init(); } compstmt { top_local_setup(); } </pre> <p>Everything was cut of course actually though it did ..others.. variously because it was trivial now. And, the content is a long ages. </p> <p class="caption">- <code>top_local_init()</code></p> <pre class="longlist">
5273 static void 5274 top_local_init() 5275 { 5276 local_push(1); 5277 lvtbl-&gt;cnt = ruby_scope-&gt;local_tbl?ruby_scope-&gt;local_tbl[0]:0; 5278 if (lvtbl-&gt;cnt &gt; 0) { 5279 lvtbl-&gt;tbl = ALLOC_N(ID, lvtbl-&gt;cnt+3); 5280 MEMCPY(lvtbl-&gt;tbl, ruby_scope-&gt;local_tbl, ID, lvtbl-&gt;cnt+1); 5281 } 5
282 else { 5283 lvtbl-&gt;tbl = 0; 5284 } 5285 if (ruby_dyna_vars) 5286 lvtbl-&gt;dlev = 1; 5287 else 5288 lvtbl-&gt;dlev = 0; 5289 } (parse.y)
</pre> <p>In a word, <code>local_tbl</code> is copied from <code>ruby_scope</code> onto <code>lvtbl</code>. Because you should see the block local variable later collectively, let's concentrate on a usual for the time being local variable. It is continuously <code>top_local_setup()</code>. </p> <p class="caption">- <code>top_local_setup()</code></p> <pre class="longlist">
5291 static void 5292 top_local_setup() 5293 { 5294 int len = lvtbl-&gt;cnt; /* number */ of the following Perth local variables 5295 Int i; /* number */ of local variables at the previous state of Perth 5296 5297 if (Len &gt; 0)
5298 i = ruby_scope-&gt;local_tbl ? ruby_scope-&gt;local_tbl[0] : 0; 5299 5300 if (i &lt; len) { 5301 if (i == 0 || (ruby_scope-&gt;flags &amp; SCOPE_MALLOC) == 0) { 5302 VALUE *vars = ALLOC_N(VALUE, len+1); 5303 if (ruby_scope-&gt;local_vars) { 5304 *vars++ = ruby_scope-&gt;local_vars[-1]; 5305 MEMCPY(vars, ruby_scope-&gt;local_vars, VALUE, i); 5306 rb_mem_clear
(vars+i, len-i); 5307 } 5308 else { 5309 *vars++ = 0; 5310 rb_mem_clear(vars, len); 5311 } 5312 ruby_scope-&gt;local_vars = vars; 5313 ruby_scope-&gt;flags | = SCOPE_MALLOC; 5314 } 5315 else { 5316 VALUE *vars = ruby_scope-&gt;local_vars-1; 5317 REALLOC_N(vars, VALUE, len+1); 5318 ruby_scope-&gt;local_vars = vars+1; 5319 rb_mem_clear(ruby_scope-&gt;local_vars+i, len-i); 5320 } 5321 if (ruby_scope-&gt;local_tbl &amp;&amp; ruby_scope-&gt;local_vars[-1] == 0) { 5322 free(ruby_scope-&gt;local_tbl); 5323 } 5324 ruby_scope-&gt;local_vars[-1] = 0; /* NODE is already unnecessary */ 5325 ruby_scope-&gt; local_tbl = Local_tbl(); 5326 } 5327 } 5328 local_pop(); 5329 } (parse.y) </pre> <p><code>Local_tbl</code> and <code>local_vars</code> of <code>ruby_scope</code> have been only renewed though it is when <code>local_vars</code> is in the stack, exists in the heap, and it becomes confusing somewhat (When <code>SCOPE_MALLOC</code> stands, <code>local_vars</code> is <code>malloc()</code> allocation). Moreover, it can do nothing but change compulsorily to the <code>malloc()</code> allocation because it is not significant even if <code>alloca()</code> is used here. </p> <h3>Block local variable</h3> <p>By the way, how is the block local variable going?First of all, it is necessary to return to entry point <code>yycompile()</code> of the parser to think about it. </p> <p class="caption">- Save of <code>ruby_dyna_vars</code></p> <pre class="longlist">
static NODE* yycompile(f, line) {
struct RVarmap *vars = ruby_dyna_vars; :
n = yyparse(); :
ruby_dyna_vars = vars;
}
</pre> <p>It is a point without clearing <code>ruby_dyna_vars</code> though sees like a mere save and return, etc.The parser will add the element directly to the link of <code>RVarmap</code> made with the evaluation machine in a word. </p> <p>However, <code>ruby_dyna_vars</code> should have been different the structure by the parser and the evaluation machine. Does the link always do and what do differences of those who adhere about the header (<code>RVarmap</code> of <code>id=0</code>) do single track [nanoha] though it seems to be unquestionable?</p> <p>Then, it is "1" of <code>local_push(1)</code> that it is given to help in <code>top_local_init()</code>. When the argument of <code>local_push()</code> truly becomes it, the first header of <code>ruby_dyna_vars</code> is not put up. In a word, it becomes as shown in Figure 1. It was able to be confirmed to be able to refer to the block local variable in scope on the outside by this from among the <code>eval</code> character string. <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_anyeval_dynavars.jpg" alt="(dynavars)"><br>Figure 1: <code>Ruby_dyna_vars</code> in <code>eval</code></p> <p>It is not or the person who has noticed wants you to be relieved reading the following place having liberated everything in the parser saying if the made link is liberated with the evaluation machine as …… very done though it is unpleasant, and is possible to refer certainly though not known. ruby_dyna_vars<code></code></p> <p class="caption">- <code>Yycompile()</code> - <code>ruby_dyna_vars</code> liberating</p> <pre class="longlist">
2386 vp = ruby_dyna_vars; 2387 ruby_dyna_vars = vars; 2388 lex_strterm = 0; 2389 while (vp &amp;&amp; vp != vars) { 2390 struct RVarmap *tmp = vp; 2391 vp = vp-&gt;next; 2392 rb_gc_force_recycle((VALUE)tmp); 2393 } (parse.y)
</pre> <p>The loop stops neatly when coming to link <code>(vars)</code> made with the evaluation machine. </p> <h2><code>instance_eval</code></h2> <h3>Whole image</h3> <p>In the substance of <code>Module#module_eval</code>, the substance of <code>rb_mod_module_eval()</code> and <code>Object#instance_eval</code> is <code>rb_obj_instance_eval()</code>. </p> <p class="caption">- <code>rb_mod_module_eval() rb_obj_instance_eval()</code></p> <pre class="longlist">
5316 VALUE 5317 rb_mod_module_eval(argc, argv, mod) 5318 int argc; 5319 VALUE *argv; 5320 VALUE mod; 5321 { 5322 return specific_eval(argc, argv, mod, mod); 5323 } 5298 VALUE 5299 rb_obj_instance_eval(argc, argv, self) 5300 int argc; 5301 VALUE *argv; 5302 VALUE self; 5303 { 5304 VALUE klass; 5305 5306 if (rb_special_const_p(self)) { 5307 klass = Qnil; 5308 } 5309 else { 5310 klass = rb_singleton_class(self); 5311 } 5312 5313 return specific_eval(argc, argv, klass, self); 5314 } (eval.c)
</pre> <p>Because these two methods can be shared as "Method of replacing <code>self</code> with <code>class</code>", the part has been brought together with <code>specific_eval()</code>. Let's show in the figure including this (Figure 2). It is a call with the function pointer with parentheses. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_anyeval_speceval.jpg" alt="(speceval)"><br>Figure 2: Call graph</p> <p>It separates into <code>eval</code> and <code>yield</code> about <code>instance_eval</code> to do peculiar processing respectively because both the block and the character string are received about <code>module_eval</code>. Because however, because most the parts are also common, the part is begun to bundle it as <code>exec_under()</code></p> <p>However, judging from the read side, Because it will take notice of 2\times 2=4 kind at the same time, no good policy it. Therefore, here</p> <ol> <li>With <code>instance_eval</code></li> <li>When you take the character string in the argument</li> </ol> <p>The function of <code>rb_obj_instance_eval()</code> or less will be read by thinking it is possible to hold and the one that the inline substitution and the constant folding in all were put be read. </p> <h3>After it annexes it</h3> <p>When everything was brought together, it became it so. It is fairly comprehensible compared with before it annexes it. </p> <p class="caption">- <code>Specific_eval()</code>-<code>instance_eval</code>, <code>eval</code>, and character string</p> <pre class="longlist">
static VALUE instance_eval_string(self, src, file, line) VALUE self, src; const char *file; int line; {
VALUE sclass; VALUE result; int state; int mode; sclass = rb_singleton_class(self); PUSH_CLASS(); ruby_class = sclass; PUSH_FRAME(); ruby_frame-&gt;self = ruby_frame-&gt;prev-&gt;self; ruby_frame-&gt;last_func = ruby_frame-&gt;prev-&gt;last_func; ruby_frame-&gt;last_class = ruby_frame-&gt;prev-&gt;last_class; ruby_frame-&gt;argc = ruby_frame-&gt;prev-&gt;argc; ruby_frame-&gt;argv = ruby_frame-&gt;prev-&gt;argv; if (ruby_frame-&gt;cbase != sclass) { ruby_frame-&gt;cbase = rb_node_newnode(NODE_CREF, sclass, 0, ruby_frame-&gt;cbase); }
PUSH_CREF(sclass); mode = scope_vmode; SCOPE_SET(SCOPE_PUBLIC); PUSH_TAG(PROT_NONE); if ((state = EXEC_TAG()) == 0) { result = eval(self, src, Qnil, file, line); }
POP_TAG(); SCOPE_SET(mode); POP_CREF(); POP_FRAME(); POP_CLASS(); if (state) JUMP_TAG(state); return result;
}
</pre> <p>It <code>ruby_frame-pushes to &gt; cbase</code> with <code>CLASS</code> and <code>CREF</code> a peculiar class of the object. [Ko], [torashii] .It is one. <code>eval()</code> the main processingIt is an unusual not to have initialized <code>FRAME</code> with the structure copy for a change, and it is not wonderful difference. </p> <h3>Before it annexes it</h3> <p>When he or she became legible, the author might have been easy before it possibly annexed it though it was when saying. Let's verify whereabouts made easy compared with the one before it annexes it. </p> <p>First of all, it is <code>specific_eval()</code>. Because this function is used to share the code in the interface part with Ruby, most is Perth of the argument. If it is all cut down, it becomes it so. </p> <p class="caption">- <code>specific_eval()</code>(abridgment version)</p> <pre class="longlist">
5258 static VALUE 5259 specific_eval(argc, argv, klass, self) 5260 int argc; 5261 VALUE *argv; 5262 VALUE klass, self; 5263 { 5264 if (rb_block_given_p()) { 5268 return yield_under(klass, self); 5269 } 5270 else { 5294 return eval_under(klass, self, argv[0], file, line); 5295 } 5296 } (eval.c)
</pre> <p>It perfectly divides whether this street block exists into two kinds, and the code of each route doesn't influence each other. Therefore, when reading, it is necessary to read by one. First of all, this respect is improved in the annexation version. </p> <p>Moreover, when the <code>yield</code> route is annexed to the subject, your may being not to think about Perth of this argument at all will become clear because <code>file</code> is unrelated to <code>line</code> when <code>yield_under()</code> is read. </p> <p>Next, let's see <code>eval_under()</code> and <code>eval_under_i()</code>. </p> <p class="caption">- <code>eval_under()</code></p> <pre class="longlist">
5222 static VALUE 5223 eval_under(under, self, src, file, line) 5224 VALUE under, self, src; 5225 const char *file; 5226 int line; 5227 { 5228 VALUE args[4]; 5229 5230 if (ruby_safe_level &gt;= 4) { 5231 StringValue(src); 5232 } 5233 else { 5234 SafeStringValue(src); 5235 } 5236 args[0] = self; 5237 args[1] = src; 5238 args[2] = (VALUE)file; 5239 args[3] = (VALUE)line; 5240 return exec_under(eval_under_i, under, under, args); 5241 } 5214 static VALUE 5215 eval_under_i(args) 5216 VALUE *args; 5217 { 5218 return eval(args[0], args[1], Qnil, (char*)args[2], (int)args[3]); 5219 } (eval.c)
</pre> <p>To adjust the argument to one, it passes it in this function via array <code>args</code>. So really is not understood though can expect that might not be a temporary container for <code>eval_under()</code> to pass it to <code>eval_under_i()</code> this <code>args</code>. Possibly <code>Args</code> might be processed in <code>exec_under()</code>. </p> <p>As the method of sharing the code, it is the one not understood that such an indirect passing enters judging from the read side easily though this is a very correct way. A true type is not imagined easily because there are useless Cast in <code>file</code> and <code>line</code> especially to make the compiler sesame. It ends hesitatingly because it has disappeared in the annexation version around here all. </p> <p>However, it is comprehensible is always so neither annexation nor development. For instance, when <code>exec_under()</code> is called, may I develop both of the parameter variables with <code>under</code> on the side of <code>exec_under()</code> though the second argument and the third argument have passed <code>under</code>?Saying shows <code>CLASS</code> that should be actually pushed <code>CREF</code> by the 2nd and the third argument of <code>exec_under()</code>. Because <code>CLASS</code> and <code>CREF</code> are "Another one", you might use another variable. Only here : the previous annexation version. </p> <pre class="emlist">
VALUE sclass = .....; VALUE cbase = sclass;
</pre> <p>It was thought that there was a sense of incompatibility even if only this suddenly left the variable, and developed with <code>sclass</code> though it was thought that solved and did. Only convenience in the sentence flow in a word and it exists. </p> <p>It has persistently explained the reason that develops in every case though the argument is progressed and the function has been progressed many times up to now. That is,</p> <ul> <li>When the pattern that can be taken is limited to the number of patterns</li> <li>When operation changes slightly</li> </ul> <p>[Dearu]. "Anyway, if various the one is developed by the hand, become easy. " Because it says, it doesn't decide it. </p> <p>It is easiness that gives priority at any time to understand for I, and doesn't defend the procedure. If having developed is comprehensible, it develops. Let's do so if it is felt that bringing it together in the procedure not developing or nor oppositely is comprehensible. If it is a source that the poor hand wrote, bundling to the function and rolling up often become comprehensible though it just developed for <code>ruby</code> because the origin can be neatly written. <hr> <p>The point of an opinion, an impression, and a mis-plant etc. are <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fmailto%3Aaamine%40loveruby.net&wb_lp=JAEN&wb_dis=2">[mine**] Aoki Thank you very much even for &lt; aamine@loveruby.net &gt;</a>. </p> <p> <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fdirect.ips.co.jp%2Fdirectsys%2Fgo_x_TempChoice.cfm%3Fsh_id%3DEE0040%26amp%3Bspm_id%3D1%26amp%3BGM_ID%3D1721&wb_lp=JAEN&wb_dis=2">It is possible to reserve ..direct ..'Ruby source code complete explanation'.. IMPRESS it.. and to buy it (Fly to the book introduction page. )</a> </p> <p>Copyright (c) 2002-2004 Minero Aoki, All rights reserved.</p> </body> </html>
<script src="http://rep.excite-webtl.jp/urchin.js" type="text/javascript"></script>
<script type="text/javascript">
_udn="excite-webtl.jp";
urchinTracker();
</script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-400370-52");
pageTracker._initData();
pageTracker._trackPageview();
</script>
