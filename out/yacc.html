<SCRIPT LANGUAGE="JavaScript">
<!--
var originalUrl="http://i.loveruby.net/ja/rhg/book/yacc.html";
var originalLp ="JAEN";
var originalDis="";
if (self.parent.excite_header.display) {
self.parent.excite_header.display.wb_url.value = originalUrl;
self.parent.excite_header.display.wb_lp.value = originalLp;
}
//-->
</SCRIPT>
<SCRIPT LANGUAGE="JavaScript">
<!--
if (top.excite_header)
{
// ok
}
else
{
top.location.href = "http://www.excite-webtl.jp/world/english/web/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fyacc.html&wb_lp=JAEN&wb_dis=";
}
//-->
</SCRIPT>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP"> <head><base href=http://i.loveruby.net/ja/rhg/book/yacc.html> <meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"> <meta http-equiv="Content-Language" content="ja-JP"> <link rel="stylesheet" type="text/css" href="rhg.css"> <link rev="made" href="mailto:aamine@loveruby.net"> <title>Chapter 9 velocity ..learning.. <code>yacc</code></title></head> <body> <h1>Chapter 9 velocity ..learning.. <code>yacc</code></h1> <h2>Outline</h2> <h3>Parser and scanner</h3> <p>Those who write about the parser of the program language are researched for a long time persistently, and there is a formula considerably steady. Or, it is the very strange ..(.. one in the formula that can be solved if on a roll as long as it is not a vague) grammar. </p> <p>First of all, there is a part where the character string is cut out to the row of the word (It is said the token) in the lowest vicinity. This is called scanner (scanner) or [rekusa] (lexer). Let's call the scanner because it hesitates to say though it is a lexical analysis machine when saying in Japanese. </p> <p>To begin with, there is common sense named" ..it is in the delimitation of the word at the blank.. in the basis from which the scanner comes out .."... And, an actually most programming language is such a specification. It is because that is easy. </p> <p>For instance, the blank did not have the meaning in old Fortran. It did not necessarily switch off, and even if the blank was put in a word, the word district was on the way of the variable the harbinger and either was able to insert the blank. The analysis was frightened however, the compiler vender in the troublesome one began to disregard the standard one after another, and its ..Fortran 90 after all.. blanking post-[o] [ishite] became a standard that neatly influenced. </p> <p>By the way, because it makes a mistake easily in a blank number when the program is stricken to the punched card when why Fortran 77 did not give the meaning at the blank is said, [rashii] .. </p> <h3>Symbol string</h3> <p>It is not a word to be precise though the scanner was said that it will vomit the row of the word (token). It is a row of "Sign" that the scanner generates. </p> <p>What is the sign?For instance, let's think about the numerical value. If it is a program language, 1, 2, 3, and 99 are same "Number". Quite the same treatment is grammatically done all. If it is a place that can be written one, 2 and 3 can be written. Therefore, it is not necessary to necessarily treat all distinguishing these if it sees as a parser. If it is a numerical value, it is enough by "Numerical value". </p> <p>It is called, "Sign (symbol)" bringing the one such as the "Numerical value" or "Identifier" together. The sign in this case is "Meaning. " ..when becoming Japanese though the meaning is not understood easily.. It is used like "Symbol" in the meaning. It is confusing though good those who call have thought whether for a moment with the instance of the <code>Symbol</code> class when saying the symbol. It is confusing with the variable identifier when writing symbol. Because there is no other way, it gives up and it will be called, "Sign". </p> <p>The scanner first delimits the character string to the word and calculates the sign. For instance, to the way named <code>IF</code> <code>if</code> it is <code>IDENTIFIER</code>, and if of the reserved word in case of the name (identifier) such as <code>NUMBER</code>, <code>DIGIT</code>, and <code>"name"</code> if it is a numerical value. And, the sign is passed to the next stage. </p> <h3>[Pa-sajenere-ta]</h3> <p>Well, the row of the word and the sign that the scanner vomited is assembled this time like the tree. This tree is called syntax tree (syntax tree). </p> <p>Because even all scanners might be included because the syntax tree is grown when the word parser is only used, let's call the device that grows this syntax tree a parser in the narrow sense limitedly. How does the parser in the narrow sense make a free symbol string a tree?If to what is paid attention when paraphrasing it, can the tree be discovered?</p> <p>One has the hand to pay attention to the meaning of the word. For instance, let's assume that word <code>var</code> was discovered. If local variable <code>var</code> definition has been discovered by at this time, this is sure to be understood no reference to the local variable. </p> <p>Another is a method of wanting see single-mindedly and attention. For instance, when <code>=</code> comes next to the identifier, this is understood no substitution. Here when <code>if</code> of the reserved word appears It is understood that no <code>if</code> sentence. </p> <p>The method to pay attention only to wanting see of the latter is a present trend. Only the symbol string is seen in a word and to analyze it, the language is designed. Because that can automate it with the tool easy and advanced generalization only by simple. The automation tool is called [pa-sajenere-ta] (parser generator). </p> <p>And, [pa-sajenere-ta] used most in UNIX is <code>yacc</code>. It is written by the parser of <code>ruby</code> not leaking to a multi amount and either using this <code>yacc</code>. <code>Parse.y</code> is the input. It is necessary to know <code>yacc</code> to read the parser of <code>ruby</code> in a word to some degree. </p> <p>Then, this chapter is restricted to a minimum explanation necessary to read to the end though does an easy explanation of <code>yacc</code> in preparation for the <code>parse.y</code> analysis. 'This unreasonable chapter to use Ruby by 256 times' It is [tsutanacho] in the reader who wants to learn the parser and [pa-sajenere-ta] in fuller detail \footnote 'This unreasonable chapter to use Ruby by 256 times' written by [mine**] Aoki, ASCII Publications Service, and 2001 are recommended. It is because it is the most comprehensible book even if it sees objectively for this field it doesn't recommend because this was separately written for myself. It doesn't become gambling because it is cheap for it. </p> <p>O'Reily's 'Lex&yacc programming' \footnote 'Lex&yacc programming' John R. Levine, Tony Mason, written by Doug Brown, [retsuyaku] Murakami, ASCII Publications Service, and 1994 ..after all good another person's still, and.. It recommends itThere is no way for me other than Still, Aho if it is not possible to satisfy it yet 'Compiler' read \footnote 'Compiler' Alfred V.Aho, Ravi Sethi, and Jeffrey D.Ullman collaboration, [yoshikazuyaku] Harada, science company, and 1990. </p> <h2>Grammar</h2> <h3>Grammatical file</h3> <p>The input to <code>yacc</code> is called a grammatical file. Because it is a file that writes the grammar, it is a grammatical file. A grammatical file is <code>*. Making to the file name of y</code> is a custom. It only has to compile it usually because the source code of C can be done by putting this on <code>yacc</code> (The overall view is Figure 1). </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_yacc_build.jpg" alt="(build)"><br>Figure 1: Chart related to file</p> <p>The output file name is not always revokable in <code>y.tab.c</code>. Doing is safe in <code>y.tab.c</code> though it is revokable ..a command optional mostly line it.. when it is new <code>yacc</code> when thinking about interchangeability. By the way, <code>tab</code> of <code>y.tab.c</code> seems to be <code>tab</code> of <code>table</code>. It is because of the definition for which a lot of huge tables. It is good when peeping at the file once. </p> <p>Well, contents of a grammatical file are the following shape. </p> <p class="caption">- Grammatical file [**katachi]</p> <pre class="longlist">
%{
Header
%}
%union .... %token .... %type .... %%
Rule part
%%
User definition part
</pre> <p>It is divided roughly into three by the input [hamazu] <code>%</code> of <code>yacc</code>. It is said the definition part, and the first one does various definitions and writes the preparation. Especially, the place from <code>%</code> <code>%</code> from which a favorite thing can be written by C language. A for instance necessary macro is written here. A peculiar instruction to <code>yacc</code> that uses <code>%</code> continues. Let's explain the instruction used here in every case. </p> <p>The center is called a rule part. The parser can be done by writing, "It is Perth as for such a grammar" here in the most essential point of <code>yacc</code>. It speaks in detail in the following paragraph. </p> <p>The user may freely use the last one and user definition part. <code>Yacc</code> is not concerned to a content here at all, and copied onto the output file one phrase a character as it is. For instance, the auxiliary routine needed at Perth is written and it uses it. </p> <h3><code>Yacc</code> must do. </h3> <p>It is written what in the rule part that <code>yacc</code> looks after. the center chieflyWhen the grammar is written here, <code>yacc</code> converts it into the function named <code>yyparse()</code>. This is ,in a word, a parser in the narrow sense. </p> <p>[Nanode] in the narrow sense and additionally, the scanner is necessary. However, because even the scanner doesn't look after, the user should prepare <code>yacc</code>. The scanner is a function named <code>yylex()</code>. </p> <p><code>Yacc</code>'s generating it even in case of <code>yyparse()</code> after that becomes it almost "Action" described later only in a part that is more essential in that beyond the limits of <code>yacc</code>. Then, [saniarazu] though might not thought that the part where <code>yacc</code> is taken an active part is a too little. <code>Yacc</code> is still survived though it is complained with [kanda] whose the "Essential part" is essential [sugirukarakoso] too ,. Then, because of becoming story what on earth the essential part is</p> <h3>BNF</h3> <p>If the parser is written by C, the code becomes "Here of the character string is cut so, this is made <code>if</code> sentence, and ……". When [pa-sajenere-ta] is used, it only has to be said, "It is Perth as for such a grammar" oppositely ..that... Then, the parser that treats the grammar is generated. When specification is told in a word, it is possible to mountIt It is a convenient point of <code>yacc</code>. </p> <p>Then, how is the specification told?The description method named BNF(Backus-Naur Form) is used for <code>yacc</code>. Let's see very a very easy example. </p> <pre class="emlist">
if_stmt: IF expr THEN stmt END </pre> <p><code>":"</code> is seen right and left separately. Calling the left one ,in a word, <code>if_stmt</code> …… equal to the row of the right side says here. In a word</p> <p class="center">If_stmt is equal to the row named IF expr THEN stmt END. </p> <p>It says. <code>If_stmt</code>, <code>IF</code>, <code>expr</code>, and …… are "Sign. " here all. In <code>expr</code>, <code>expression</code> (expression) and <code>stmt</code> will be the abbreviation of <code>statement</code> (sentence). This might surely be a definition of the <code>if</code> sentence. </p> <p>This one definition is called a rule. And, the left side of <code>":"</code> is called and "Left side" and the right side are called "Right side". It is naming that remembers easily indeed straight. </p> <p>Well, it is insufficient to do the oak and it is possible to hold this a little. If <code>else</code> is not put up if it is <code>if</code> sentence, it is unpleasant. It wants is omissible when <code>else</code> is unnecessary because it is troublesome of writing <code>else</code> always. It only has to do as follows at such time. </p> <pre class="emlist">
if_stmt: IF expr THEN stmt END | IF expr THEN stmt ELSE stmt END </pre> <p><code>"|"</code> is a meaning of "Or (Or,)". </p> <p class="center">It is a row of row or "IF expr THEN stmt ELSE stmt END" of "IF expr THEN stmt END" if_stmt. </p> <p>..saying.. </p> <p>Wanting you to note it here<code>|</code>The rule has been that one [de] district increased only by it if it switches off. Actually<code>|</code>Only the description of the left side is omitted, and an example a little while ago is quite the same logically meaning of [de] district as the following grammar in switching off. </p> <pre class="emlist">
if_stmt: IF expr THEN stmt END if_stmt: IF expr THEN stmt ELSE stmt END </pre> <p>The rule defined by an example in a word a little while ago is two. </p> <p>The definition of the <code>if</code> sentence was not concluded only by this. It is necessary to define what arrangement because <code>expr</code> and the <code>stmt</code> sign won't be sent from the scanner it is neatly. To bring it close to Ruby, let's boldly add the rule. </p> <pre class="emlist">
stmt : if_stmt | IDENTIFIER '=' expr /* substitution */ Expr
if_stmt: IF expr THEN stmt END | IF expr THEN stmt ELSE stmt END Expr: Refer to the IDENTIFIER /* variable */. | NUMBER /* integer constant */ Funcall /* function call | (FUNction CALL) */
funcall: IDENTIFIER '(' args ')' Args: The argument : ..expr /*.. for the time being only by one */. </pre> <p>Two new elements were used. First of all, it is an expression of the character such as comments on the same form as C language and <code>'='</code>. This <code>'='</code> is also a sign. The sign is <code>'='</code> because there are nothing but only kinds unlike the number the sign like "=" etc. as it is. It cannot be done because of the restriction of C language though it comes to want to use it as it is ..the reserved word etc... ..the character string.. if coming. </p> <p>If the entire rule to have to expand the rule for this, and to follow can be written, it is a completion of the grammar. If it is this example, <code>stmt</code> will show the entire program because the left side of the rule written most up is supposed to show "The entire grammar to be expressed" in <code>yacc</code>. </p> <p>It passed for a moment abstractly. Let's explain a little more concretely. "<code>Stmt</code> shows the entire program" is to be taken the queue up all of "It is equal" sign in <code>stmt</code> and the rule as a grammar. For instance, <code>stmt</code> is first of all equal to <code>stmt</code>. It is natural. Next, <code>expr</code> is equal to <code>stmt</code>. This is a rule as it is. And, it is the next, and <code>NUMBER</code> is equal to <code>stmt</code>. Because it is <code>expr</code> and <code>expr</code> is <code>stmt</code> in <code>NUMBER</code>. </p> <p>It can be said that the more complex one is equal. </p> <pre class="emlist">
stmt ↓ if_stmt ↓ IF expr THEN stmt END ↓ ↓ IF IDENTIFIER THEN expr END ↓ IF IDENTIFIER THEN NUMBER END </pre> <p>It seems to have become all signs sent from the scanner in the place in which it had developed with here. In a word, the row of such a sign is correct as the program. As for the parser, when the arrangement of such a sign is sent from the scanner if it says oppositely, the input can be understood in the reverse order of development. </p> <pre class="emlist">
IF IDENTIFIER THEN NUMBER END ↓ IF IDENTIFIER THEN expr END ↓ ↓ IF expr THEN stmt END ↓ if_stmt ↓ stmt </pre> <p>And, <code>stmt</code> is a sign that shows the entire program. Therefore, this symbol string is correct as the program. The parser is to think. Then, [pa-suru-chin] <code>Yyparse()</code> is returned 0 to the sign of having succeeded and ends. </p> <p>By the way, when it is a technical term, the Perth success is called acceptance (accept). Because if document that fixes [kacchiri] into frame that I specified massaging it like public office is not submitted, parser is immediately rejectedThe symbol string that accept is done is waited for neatly the frame. The point where specification is detailed or around in the use of a difficult term purposely and the parser and public office look alike considerably strangely. </p> <h3>Terminal and nonterminal</h3> <p>Well, let's explain again because it put it without the explanation of the word in "Sign that comes from the scanner" in the confusion of the moment. There are two kinds even if it is actually said to the unit the sign. </p> <p>One is sign sent from the scanner , for instance, <code>IF</code>, <code>THEN</code>, and <code>END</code> and <code>'='</code>, etc.This is called terminal (terminal symbol). It is because of the row of endmost [kkoni] to development fast a little while ago. This chapter describes all always terminals by the capital letter. It is correct and the one bundled by the quart like <code>'='</code> is special. This kind of sign is a terminal without the exception. </p> <p>Another is a sign that never comes from the scanner , for instance, <code>if_stmt</code>, <code>expr</code>, and <code>stmt</code>. Such a sign is called nonterminal (nonterminal symbol). Nonterminal is up to existence only in the parser because it doesn't come from the scanner. And, nonterminal appears without fail at the left of the rule some time. This chapter describes all nonterminal by the small letter. </p> <h3>Test method</h3> <p>I will teach the method of actually processing a grammatical file with <code>yacc</code> here. </p> <pre class="emlist">
%token A B C D E %%
list: A B C | de de : D E </pre> <p>All terminals first used are arranged after <code>%token</code>. However, you may not write the sign (<code>'='</code> etc.) that uses the quart. And, it delimits with <code>%</code> and the grammar is written. It is only this. </p> <p>Then, let's process it. </p> <pre class="screen">
% yacc first.y % ls first.y y.tab.c %
</pre> <p>It makes it a rule and "A silence is a mind of the success. " of UNIX tool. </p> <p>After that, <code>yacc</code> for which the semicolon is necessary exists at the end of the rule (crowd), too. At that time, let's do as follows. </p> <pre class="emlist">
%token A B C D E %%
list: A B C | de ;
de : D E ;
</pre> <p>Because the author hates this semicolon, it always omits it in this book. </p> <h3>Empty rule</h3> <p>Then, some formulae of a grammatical description of <code>yacc</code> will be seen a little more. First of all, let's introduce it from an empty rule. </p> <pre class="emlist">
void:
</pre> <p>There is nothing in the right side, too. Then, sign <code>void</code> is equal to "Nothing". For instance, the following two <code>target</code> becomes quite the same meaning. </p> <pre class="emlist">
target: A B C target: A void B void C void :
</pre> <p>Are these kind of things useful ..what..?It is very useful. For instance, the following. </p> <pre class="emlist">
if_stmt : IF expr THEN stmts opt_else END opt_else: | ELSE stmts </pre> <p>"Paragraph <code>else</code> might be omitted (zilch)" was expressible well by the use of an empty rule. You may be more concise here, and not distribute the responsibilities more than two rules as similar a little while ago are arranged and written. </p> <h3>Reflexive definition</h3> <p>The following example is cramped a little more. </p> <pre class="emlist">
List: ITEM /* rule 1 */
| List ITEM /* rule 2 */
</pre> <p>This expresses the list that displays one <code>ITEM</code> or more. In a word, either of the following symbol strings is shown. </p> <pre class="emlist">
ITEM ITEM ITEM ITEM ITEM ITEM ITEM ITEM ITEM ITEM :
</pre> <p>Why do you understand?First of all, by rule 1 <code>List</code> is read as <code>ITEM</code> and can be changed. Then, the rule comes to be able to be called <code>list</code> is <code>ITEM ITEM</code> from two this time. </p> <pre class="emlist">
list: list ITEM = ITEM ITEM </pre> <p>The symbol string named <code>ITEM ITEM</code> is understood from this equal to <code>list</code>. If this is continued fast, <code>ITEM</code> can be increased very much solving …… ..saying.. ..equal to <code>list</code>.. if it applies it to <code>list</code> of this further rule 2 again even by <code>ITEM3</code>. It is the one like the principle of induction. </p> <p>The following example is shown. The list that displays 0 <code>ITEM</code> or more is shown as follows. </p> <pre class="emlist">
list: | list ITEM </pre> <p>The line ..first of all.. is a meaning "<code>List</code> (zilch) is equal". No, it is a list of 0 <code>ITEM</code>. Next, <code>"list ITEM"</code> can be said by seeing the second rule equal to <code>ITEM1</code> piece. Because <code>list</code> is a body equal to nothing. </p> <pre class="emlist">
list: list ITEM =(zilch)ITEM = ITEM </pre> <p>It is understood that <code>list</code> is an expression of the list of 0 <code>ITEM</code> or more if this replacement work is continued many times a little while ago. </p> <p>In "Two lists of <code>ITEM</code> more" or "Three lists of <code>ITEM</code> more", if this knowledge is applied, it is easy, and "<code>ITEM</code> is a list of the even number piece" can make the one. </p> <pre class="emlist">
list: | list ITEM ITEM </pre> <h2>Construction of value</h2> <p>An abstract story continued and I want to pursue the subject physically to one's heart's content recently. </p> <h3>Shift and reduction</h3> <p>For us to want to do is to grow the syntax tree to the end though it has variously explained those who write about the grammar here. However, it is not indeed because of making it for the syntax tree only from telling the rule to our regret. Then, let's teach the method of this plus sometting to the rule and growing the syntax tree. </p> <p>First of all, it explains putting when the parser actually executes it. Let's take it as an example of simple following grammars. </p> <pre class="emlist">
%token A B C %%
program: A B C </pre> <p>There is one stack that is called semantics tuck (semantic stack) in the parser. And, the sign that comes from the scanner to this is pushed fast. This operation is indicated and it is said, "The sign is shifted (shift)". </p> <pre class="emlist">
[ A B ] ← C shift
</pre> <p>And, when the arrangement becomes complete in the point of the stack, "Understanding" does this. "Understanding" Then, the arrangement of the right side changes into a left sign. </p> <pre class="emlist">
[ A B C ]
↓ Reduction
[ program ] </pre> <p>This operation is said, "<code>A B C</code> is reduced to <code>program</code> (reduce)". The word is like becoming a large ternary when becoming complete in [yousuru] ..seem great.. during [shiro**]. …… Is it different?</p> <p>And, because <code>program</code> showed the entire program, the entire program might have been found by there was only <code>program</code> in the stack. Therefore, if the input just ends here, it is accepted. </p> <p>Let's try only a little more by a complex grammar. </p> <pre class="emlist">
%token IF E S THEN END %%
program : if if : IF expr THEN stmts END expr : E stmts : S | stmts S </pre> <p>The input from the scanner is a long ages. </p> <pre class="emlist">
IF E THEN S S S END </pre> <p>The transition of the semantics tuck at this time is shown below. </p> <table> <tr><td>Stack<td><td>Operation<td></tr> <tr><td><td><td>It is the sky first. <td></tr> <tr><td><code>IF</code><td><td><code>IF</code> is shifted. <td></tr> <tr><td><code>IF E</code><td><td><code>E</code> is shifted. <td></tr> <tr><td><code>IF expr</code><td><td>It reduces it with <code>E→expr</code><code></code>. <td></tr> <tr><td><code>IF expr THEN</code><td><td><code>THEN</code> is shifted. <td></tr> <tr><td><code>IF expr THEN S</code><td><td><code>S</code> is shifted. <td></tr> <tr><td><code>IF expr THEN stmts</code><td><td>It reduces it with <code>S→stmts</code><code></code>. <td></tr> <tr><td><code>IF expr THEN stmts S</code><td><td><code>S</code> is shifted. <td></tr> <tr><td><code>IF expr THEN stmts</code><td><td>It reduces it with <code>stmts S→stmts</code><code></code>. <td></tr> <tr><td><code>IF expr THEN stmts S</code><td><td><code>S</code> is shifted. <td></tr> <tr><td><code>IF expr THEN stmts</code><td><td>It reduces it with <code>stmts S→stmts</code><code></code>. <td></tr> <tr><td><code>IF expr THEN stmts END</code><td><td><code>END</code> is shifted. <td></tr> <tr><td><code>if</code><td><td>It reduces it with <code>IF expr THEN stmts END→if</code><code></code>. <td></tr> <tr><td><code>program</code><td><td>It reduces it with <code>if→program</code><code></code>. <td></tr> <tr><td><td><td>accept.<td></tr> </table> <p>It notes it only by one at the end. The sign doesn't necessarily decrease in reduction. The sign might be generated from "Nothing" when there is an empty rule. </p> <h3>Action</h3> <p>Well, it is a point important ..here... There is only [udauda] in the semantics tuck and is not a meaning though it might be reduction though it might be a shift either. It embarrasses it if it doesn't connect with it our end goal is to generate the syntax tree. How will <code>yacc</code> put can the drop dance?"Let's have the hook of the moment that the parser reduces can done" is an answer that <code>yacc</code> got. The hook is called action (action) of the parser. The action is written as follows at the end of the rule. </p> <pre class="emlist">
program: A B C Here /* is action */. </pre> <p>The part that enclosed it is an action. <code></code><code></code>This action is executed momentarily at the time of reduce <code>A B C</code> to <code>program</code> when writing so. When what is done in the action, it is free. If it is a code of C, anything roughly can be written. </p> <h3>Value of sign</h3> <p>Here is and, there is the one "The value" in all signs though it is more important. The terminal is nonterminal [moda] .. Because the terminal comes from the scanner, the value is gotten from the scanner. <code>For instance..sign.</code>It might be <code>"Sym"</code> such as <code>"Attr"</code> or <code>"Name"</code> for sign <code>IDENTIFIER</code>Anything is good. The value is piled up in the semantics tuck with the sign. The following figure just shifted <code>S</code> with the value now. </p> <pre class="emlist">
IF expr THEN stmts S value value value value value
</pre> <p><code>Stmts S</code> can be reduced to <code>stmts</code> according to a rule a little while ago. If the action was written in the rule, the value of the sign to correspond right at that time is passed to the action because it is executed. </p> <pre class="emlist">
IF expr THEN stmts S /* stack */ value 1 value 2 value 3 value 4 Value 5
↓ ↓ Stmts: stmts S /* rule */
↓ ↓ /* action */
</pre> <p>The value of the corresponding sign can be taken at the right of the rule with <code>$1</code>, <code>$2</code>, and <code>$3……</code> in the action like this. Because <code>yacc</code> rewrites <code>$1</code> or <code>$2</code> in expression that indicates stackNow, I will in reality assume the type to be <code>int</code> though it is variously because I am troublesome in case of C language. </p> <p>And, the value must be still also in the left sign because the sign has all values though the following pile up a left sign instead. As for it, the value of the \\ when it is expressed in the action as the \\, and comes off the action reaches the value of a left sign. <code></code><code></code></p> <pre class="emlist">
Stack */ value 1 immediately before reduction of IF expr THEN stmts S /* value 2 value 3 value 4 Value 5
↓ ↓ Rule that the right side of stmts: stmts S /* matches to end */
↑ ↓ ↓ /* The action */
Stack */ value 1 after IF expr THEN stmts /* is reduced value 2 Value 3(..value.. four+ value 5)
</pre> <p>It is a superfluity in the end. The value of the sign might be called the meaning value and semantic value. Therefore, because of stack that puts it is semantic value stack, and calling for short semantic stack</p> <h3><code>Yacc</code> and type</h3> <p>Well, if the story of the type is not told, the talk is not installed though it is indeed troublesome. What on earth is the type of the value of the sign?It becomes a type named <code>YYSTYPE</code> if it says from the conclusion. This surely : It either is <code>YY Stack TYPE</code> or <code>Semantic value TYPE</code> or abbreviation. mustAnd, <code>YYSTYPE</code> is <code>typedef</code> of another some types naturally. The type is a common body specified by the instruction named <code>%union</code> in the definition part. </p> <p>However, <code>%union</code> had not been written up to now. Not having become an error will be able to boil ..what.. yet. It is because of <code>yacc</code>'s effective of the nature and having without permission in default and processing it. Naturally, it is <code>int</code> if it is said that it will default by C. Thus, the default of <code>YYSTYPE</code> is <code>int</code>. </p> <p>The structure, the pointer, and, additionally, I want to use variety to grow the syntax tree though it doesn't care by the example and calculator programs it put out to the book on <code>yacc</code> like <code>int</code>. Then, <code>%union</code> is used for instance as follows. </p> <pre class="emlist">
%union { struct node { int type; struct node *left; struct node *right; } *node; int num; char *str;
}
</pre> <p>The type and the name of the member are suitable because it doesn't actually use it now. Attention of semicolon unnecessary for the end of block of <code>%union</code> unlike usual C. </p> <p>And, because of becoming in <code>y.tab.c</code> the following if it writes so</p> <pre class="emlist">
typedef union { struct node { int type; struct node *left; struct node *right; } *node; int num; char *str; } YYSTYPE;
</pre> <p>Then, the semantics tuck :. </p> <pre class="emlist">
YYSTYPE yyvs[256]; /* substance (yyvs = YY Value Stack) of stack *
/ YYSTYPE *yyvsp = Yyvs; /* Pointer that indicates point of stack */
</pre> <p>The expectation that might not feeling it adheres. If so, the value of the sign that comes out in the action …… also :. </p> <pre class="emlist">
/* action */ before yacc is processed Target: A B C{ func($1, $2, $3); } Func(yyvsp[-2], yyvsp[-1], yyvsp[0]) ;;
</pre> <p>It becomes it naturally so. </p> <p>In this case, it only has to refer to the stack because <code>int</code> of default was used, and the member is sure not to specify at the same time and either it to be inaccessible for a common body <code>YYSTYPE</code>. They (the method of the tie each sign and the method of specification in every case) two kinds of are. </p> <p>From the method of specification first of all each general sign. <code>%token</code> is written as follows by the use of <code>%type</code> for nonterminal for the terminal. </p> <pre class="emlist">
%token &lt; num &gt; The value of A B C all A B C /* is int type %
type &lt; str &gt; */ The value of target all target /* is char * type */. </pre> <p>On the other hand, the name of the member is made to interrupt next to <code>$</code>as follows when specifying it every time. </p> <pre class="emlist">
%union { char *str; } %%
target: Do..Cast..one.
</pre> <p>You should not use a method here as much as possible. It is basic to decide the member in each sign. </p> <h3>Connection of parser and scanner</h3> <p>All [arekore] of the value in the parser was spoken by this. The matters that become nuclei are all ends if connected protocol with the scanner is spoken. </p> <p>The scanner was function <code>yylex()</code> when first confirming it. (terminal)The sign is returned as a return value of the function (With <code>int</code>). If it is sign <code>NUMBER</code>, it is good because <code>yacc</code> is the same name as the sign, the constant is done in <code># define</code>, and it exists ..only writing as <code>NUMBER</code>... And, the value is put in the global variable named <code>yylval</code> and passed. The same thing can be completely said also to this <code>yylval</code> that the parser of it in the <code>YYSTYPE</code> type. It becomes a common body when defining it with <code>%union</code> in a word. However, the member is not chosen without permission and it is useless this time if the name of the member is not written for myself. When it is a simplified example, it becomes the following in a word very much. </p> <pre class="emlist">
static int yylex() {
yylval.str = next_token(); return STRING;
}
</pre> <p>I want you to confirm it one by one because it summarized the relation to here in Figure 2. The variable that becomes an interface such as <code>yylval</code>, the \\, <code>$1</code>, and <code>$2……</code> all : It is <code>YYSTYPE</code> type. <code></code></p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_yacc_yaccvars.jpg" alt="(yaccvars)"><br>Figure 2: Relation between variable and function related to <code>yacc</code></p> <h3>Burial action</h3> <p>It is possible to write actually on the way of the rule though the action explained the one written at the end of the rule. </p> <pre class="emlist">
target: A B { puts("embedded action"); } C D </pre> <p>This is called a burial action. The burial action is a mere syntax sugar of the following descriptions. </p> <pre class="emlist">
target: A B dummy C D Dummy :/* empty rule */
{
puts("embedded action"); }
</pre> <p>All the executed timing etc. might be understood from this. The value of the sign can be usually taken. In a word, the value of the burial action comes out as <code>$3</code> if it is this example. </p> <h2>Realistic topic</h2> <h3>Collision</h3> <p><code>Yacc</code> is not scared any longer in this. </p> <p>It is considerably sweet when thinking. Why is <code>yacc</code> feared like this, and the reason exists after this. </p> <p>How do it become it though it has been casually written, "The right side of the rule matches to the stack point" up to now when there are the following rules?</p> <pre class="emlist">
target : A B C | A B C </pre> <p>Which rule is matched when the symbol string named <code>A B C</code> has actually come out is sure not to be understood. Even man doesn't understand these kind of things. Therefore, <code>yacc</code> is not understood. When such a strange grammar is discovered, <code>yacc</code> : It is complained that reduce/reduce conflict (reduction and reduction collisions) occurred. It means two or more rules can be reduced at the same time. </p> <pre class="screen">
% yacc rrconf.y conflicts: 1 reduce/reduce </pre> <p>However, how about the following example though these kind of things are not thought to do besides the accident if it is usual?The described symbol string is quite the same. </p> <pre class="emlist">
target : abc | A bc abc : A B C bc : B C </pre> <p>It can be comparatively if it is this. Especially, [guchagucha] moves while thinking about the rule and such a rule can be done by an imperceptible process. </p> <p>It is a pattern that looks like and there are the following one, too. </p> <pre class="emlist">
target : abc | ab C abc : A B C ab : A B </pre> <p>When the symbol string named <code>A B C</code> appears, <code>abc</code> one is not understood the combination of <code>ab</code> and <code>C</code> the loan ..should the choice.. ..whether it is necessary to do... <code>Yacc</code> at such time Shift/reduce conflict (the shift and reduction collisions) occurs, and it ..complaint.. drips. Here is to mean there are a rule that can be shifted at the same time and a rule that can be reduced. </p> <pre class="screen">
% yacc srconf.y conflicts: 1 shift/reduce </pre> <p>A famous example of shift/reduce conflict is "Hanging <code>else</code> problem. "For instance, this problem happens by the <code>if</code> sentence of C language. Let's simplify and write the talk. </p> <pre class="emlist">
stmt : expr ';' | if expr : IDENTIFIER if : IF '(' expr ')' stmt | IF '(' expr ')' stmt ELSE stmt </pre> <p>The main body of <code>if</code> made the rule only in <code>IDENTIFIER</code> (variable) in the expression as only one sentence. Well, if the following program is done in Perth by this grammar, it is likely to become what. </p> <pre class="emlist">
if (cond) if (cond) true_stmt; else false_stmt;
</pre> <p>It is possible to look obvious somehow when writing so, and to interpret it actually as follows. </p> <pre class="emlist">
if (cond) { if (cond) true_stmt; }
else { false_stmt;
}
</pre> <p>It is a problem to <code>if</code> of which the outside and the inside to put up <code>else</code> in a word. </p> <p>However, shift/reduce conflict is a comparatively harmless compared with reduce/reduce conflict collision. It is because because it goes well if the shift is chosen mostly. The rough synonym, and it matched to man's intuition to choose shifting easily , saying that "Near elements are connected mutually as much as possible". Actually, it hangs <code>Else</code> shifts, too and it goes well. <code>Yacc</code> also : along the flow because of this When shift/reduce conflict occurs, the shift is chosen by default. </p> <h3>Lookahead</h3> <p>I want you to put the following grammar on <code>yacc</code> by way of experiment. </p> <pre class="emlist">
%token A B C %%
Target: A B C /* rule 1 */
| A B /* rule 2 */
</pre> <p>Do not you not seem to collide no matter how it thinks?It wants to shift rule 1 when even <code>A B</code> is read, and I want to reduce rule 2. In a word, this is sure to become shift/reduce conflict. However ……,</p> <pre class="screen">
% yacc conf.y %
</pre> <p>It doesn't collide ..amusing... [Darou] . why</p> <p>To tell the truth, the parser made from <code>yacc</code> : the sign only by one It cuts it by "Lookahead (look ahead)". How it costs it can be judged by stealing a glance at the following sign before it shifts really and it reduces it. </p> <p>Therefore, if it is possible to distinguish by one lookahead in consideration of it when the parser is generated, they are not allowed to collide. For instance, because only rule 1 has the possibility if <code>C</code> comes next to <code>A B</code> if it is a rule a little while ago, rule 1 is chosen (Shift). When the input ends, rule 2 is chosen (Reduce it). </p> <p>It is that two kinds of meanings are in word "Lookahead" that it wants you to note it. One is <code>yacc</code> and <code>*. The lookahead when y</code> is processed. When the generated parser is actually moved, another is lookahead. The lookahead of <code>yacc</code> is very confusing though the lookahead when executing it is not very difficult. Because it is necessary to decide behavior forecasting all the input configurations when executing it only from the grammatical rule. </p> <p>However," will actually deal with "Considerably" pattern because it is impossible. Because and, within how much range of all patterns it is possible to deal becomes strength of lookahead algorithmThe lookahead algorithm used when <code>yacc</code> processes a grammatical file calls LALR(1), and is comparatively strong in the in existence collision solution algorithm. </p> <p>I need not worry so much though it said variously to do in this book is not to write the rule only by reading by it. It is lookahead of not lookahead it that uses the grammar but execution that wanted to explain here. </p> <h3>Operator priority level</h3> <p>Because an abstract story continued for a while, a concrete a little more story is told here. Rules of clause 2 operators such as <code>+</code> and <code>*</code>(infix type operator) will be defined. You only have to follow it obediently because there is a formula also in this. The one like the calculator that was able to use the arithmetic operation was defined as follows. </p> <pre class="emlist">
expr : expr '+' expr | expr '-' expr | expr '*' expr | expr '/' expr | primary primary : NUMBER | '(' expr ')' </pre> <p>As for <code>primary</code>, "Clause" is translated. Each smallest grammar. Becoming <code>primary</code> if <code>expr</code> is bundled by parentheses is a point. </p> <p>Well, it becomes it so when this grammar is suitably written in the file and it compiles. </p> <pre class="screen">
% yacc infix.y 16 shift/reduce conflicts </pre> <p>It has collided intensely. It embarrasses it in the following cases in this rule though it is thought that it understands if it thinks only about five minutes. </p> <pre class="emlist">
1 - 1 - 1 </pre> <p>This can be interpreted also as the following any two kinds of. </p> <pre class="emlist">
(1 - 1) - 1 1 - (1 - 1)
</pre> <p>It is the former to say nothing of natural as the expression. However, it is processing of wanting to see to the end that <code>yacc</code> does, and the meaning doesn't enter there at all. <code>-</code>It doesn't consider it in the such a little of meaning of the sign. It is necessary to direct that it wants to do honestly to reflect man's intention correctly. </p> <p>Then, when whether goodness when doing very is said, it only has to write in the definition part so. </p> <pre class="emlist">
%left '+' '-' %left '*' '/' </pre> <p>This instruction specifies two (the priority of operator and the connectivity) at the same time. Let's explain sequentially. </p> <p>I think that the word priority level often comes out when the story of the grammar of the program language is told. In the following cases, it is a story to which operator parentheses adhere because it is confusing when theoretically speaking when intuitively saying. </p> <pre class="emlist">
1 + 2 * 3 </pre> <p> <code>*</code>It becomes it so if the order is high [masa] [nohou] ahead. </p> <pre class="emlist">
1 + (2 * 3)
</pre> <p>If the priority level is high, <code>+</code> becomes it so. </p> <pre class="emlist">
(1 + 2) * 3 </pre> <p>Thus, the strong one and the weak one are set to the operator It is an operator priority level to solve shift/reduce conflict. </p> <p>However, how should I do when the priority level is the same even if doing and falling into an oak and the same situation?For instance, like this. </p> <pre class="emlist">
1 - 2 - 3 </pre> <p>Because it is <code>-</code>, both priority levels are this time the same quite. It solves it by using the connectivity at such time. There are three kinds of connectivities of left right nonassoc, and it is interpreted respectively as follows. </p> <table> <tr><td>Connectivity<td><td>Interpretation<td></tr> <tr><td>left(left uniting)<td><td><code>(1 - 2) - 3</code><td></tr> <tr><td>right(right association)<td><td><code>1 - (2 - 3)</code><td></tr> <tr><td>nonassoc(non-uniting)<td><td>[Pa-suera-]<td></tr> </table> <p>When it is an operator for the expression, most is a left uniting. The right association chiefly uses it with <code>=</code> of substitution and <code>not</code> of the denial. </p> <pre class="emlist">
a = b = 1 # (a = (b = 1)) not not a # (not (not a))
</pre> <p>The representative of nonassoc might be a relative operator. </p> <pre class="emlist">
A == b == c # [pa-suera-] a &lt; = b &lt; = C # [pa-suera-]
</pre> <p>It is not this because it can compare clauses 3 in Python etc.</p> <p>And, the instruction named <code>%left･%right･%nonassoc</code><code></code><code></code> a little while ago is used to show the connectivity the same as the name. And, the priority level is shown in order arranging it. The priority level is high like the operator that is below. It is the same order in case of being in the same row. </p> <pre class="emlist">
'It is /* right association and priority level 1 It is %left '+' and '
-' /* left uniting and priority level 3 It is */ %left '*' and' /* '/
left uniting and priority level 2 */ %right '*/. </pre> <hr> <p>The point of an opinion, an impression, and a mis-plant etc. are <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fmailto%3Aaamine%40loveruby.net&wb_lp=JAEN&wb_dis=2">[mine**] Aoki Thank you very much even for &lt; aamine@loveruby.net &gt;</a>. </p> <p> <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fdirect.ips.co.jp%2Fdirectsys%2Fgo_x_TempChoice.cfm%3Fsh_id%3DEE0040%26amp%3Bspm_id%3D1%26amp%3BGM_ID%3D1721&wb_lp=JAEN&wb_dis=2">It is possible to reserve ..direct ..'Ruby source code complete explanation'.. IMPRESS it.. and to buy it (Fly to the book introduction page. )</a> </p> <p>Copyright (c) 2002-2004 Minero Aoki, All rights reserved.</p> </body> </html>
<script src="http://rep.excite-webtl.jp/urchin.js" type="text/javascript"></script>
<script type="text/javascript">
_udn="excite-webtl.jp";
urchinTracker();
</script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-400370-52");
pageTracker._initData();
pageTracker._trackPageview();
</script>
