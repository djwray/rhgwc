<SCRIPT LANGUAGE="JavaScript">
<!--
var originalUrl="http://i.loveruby.net/ja/rhg/book/evaluator.html";
var originalLp ="JAEN";
var originalDis="";
if (self.parent.excite_header.display) {
self.parent.excite_header.display.wb_url.value = originalUrl;
self.parent.excite_header.display.wb_lp.value = originalLp;
}
//-->
</SCRIPT>
<SCRIPT LANGUAGE="JavaScript">
<!--
if (top.excite_header)
{
// ok
}
else
{
top.location.href = "http://www.excite-webtl.jp/world/english/web/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fevaluator.html&wb_lp=JAEN&wb_dis=";
}
//-->
</SCRIPT>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP"> <head><base href=http://i.loveruby.net/ja/rhg/book/evaluator.html> <meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"> <meta http-equiv="Content-Language" content="ja-JP"> <link rel="stylesheet" type="text/css" href="rhg.css"> <link rev="made" href="mailto:aamine@loveruby.net"> <title>Chapter 13 Structure of evaluation machine</title></head> <body> <h1>Chapter 13 Structure of evaluation machine</h1> <h2>The fourth outline</h2> <h3>What is the evaluation machine?</h3> <p>"Evaluation machine" It is a word that is not accustomed to be heard. To the idea from the character side of evaluation machine "Evaluation. " Then, what is evaluating it though it differs in done "Machine" and it doesn't exist?</p> <p>It is a mistranslation in assumption of speaking the program language though "Evaluation" is a definitive translation of evaluate. The shade of meaning of "It is good and bad" is included by all means when saying the evaluation in Japanese. </p> <p>"It recommends and measure it. " ..quite regardless of the quality.. ..of evaluate in the program language.. It has a meaning near "Execute it". The etymology of evaluate is Latin It becomes it , saying that "It is worth" if it translates literally with ex+value+ate. It might be easy to understand this most. The value is requested from the expression expressed by the text. </p> <p>The evaluation executes the written expression, obtains the result, and is a meaning if it ..[maayousuru].. ..[bucchakete].. says. It is then because execution alone is not an evaluation when it says why not to say execution. </p> <p>For instance, it is treated as three of the integers if it is written "3" if it is a usual program language. It is said at such time, "The result of evaluating <code>"3"</code> is 3". The expression of the constant is difficult to say to execute, and it is also an evaluation. Because it doesn't care separately even if there is a language treated as integer 6 when the character side of "3" is evaluated (It is evaluated). </p> <p>Let's give another example. It is likely to calculate while compiling when there is an expression that combines constants (constant folding in). It is not said that this also usually does "Execution" and it calculates. It is because work while the made binary moves is indicated if it is said that it will execute. However, a final evaluation value to program doesn't change to calculate when. </p> <p>Execution and the evaluation are fundamentally different from "Evaluate it" though it is equal to the execution of the program mostly in a word. Only this respect is remembered for the time being and it wants it. </p> <h3>Feature of evaluation machine of <code>ruby</code></h3> <p>The maximum feature in the evaluation machine of <code>ruby</code> is C level though can say to the entire interpreter The difference of the expression of the code at (enhancing library) and the Ruby level is small. It frightens and the limitation is a little in <code>ruby</code> though the function of the interpreter who can use it from the enhancing library in a usual processing system is the one considerably limited. It is possible to use it for the thread by assuming to be natural around finally ..the exception handling and [itere-ta].. the method call without the class definition, the method definition, and the limitation. </p> <p>However, it is necessary to pay the compensation for the convenience somewhere. Mounting is, and it is serious, large to be overhead strangely, and there is considerably a location where a similar thing is mounted twice for Ruby and for C, too. </p> <p>Moreover, the program can be assembled with the character string when executing it because <code>ruby</code> is a dynamic language and it be evaluated. The method named <code>eval</code> of the function style is it. It comes from evaluate to say nothing of the name. These kind of things can be done by using it. </p> <pre class="emlist">
lvar = 1 Answer = eval("lvar + lvar") # answer is two. </pre> <p>Movement that there is the one named <code>Module#module_eval</code> and <code>Object#instance_eval</code>, too and is a habit respectively is done additionally. Let's describe details around here in 'Dynamic evaluation' Chapter 17. </p> <h3><code>eval.c</code></h3> <p>The evaluation machine is mounted with <code>eval.c</code>. However, this <code>eval.c</code> is very huge, and indeed It is [gatakana] of several 309 of the 9000 line 200 Kbyte and functions. The structure cannot be gripped at all when becoming this level by the extent looked at from the head. </p> <p>Then, how do you do?First of all, it is not possible that there is no division in that according to becoming if becoming a huge file at all. It is sure to be modulated by a in a word smaller internally unit. Therefore, it is necessary to think the search for it the first. Then, it is necessary to look for the module very. Some the methods are enumerated. </p> <p>The list of the function first defined is output and the prefix is seen. The function with the prefix such as <code>rb_dvar _</code>, <code>rb_mod _</code>, and <code>rb_obj _</code> and <code>rb_thread _</code> is sure to queue up with [zurazura]. This is a settlement of obviously the same kind of function. </p> <p>Moreover, in the code of <code>ruby</code> though it understands when the code of the class library is seen <code>Init_xxxx()</code> is always put at the end of the block. Therefore, the zosh there when there is <code>Init_xxxx()</code>. </p> <p>The name is also naturally important in it. Thinking that there is mutually a deep relation when <code>eval()</code>, <code>rb_eval()</code>, and <code>eval_node()</code> are suited in the vicinity is natural. </p> <p>Finally, when the definition and the prototype declaration of the type and the variable have been got in in the source code of <code>ruby</code>, it is often an zosh. </p> <p><code>Eval.c</code> can be divided into the chiefly following modules by consciously seeing around here. </p> <table> <tr><td>Safe level<td><td>Chapter 7 It has explained by 'Security'. <td></tr> <tr><td>Operation of method entry<td><td>It searches for the syntax tree of the method substance and it deletes it. <td></tr> <tr><td>Evaluation machine core<td><td>Core part of evaluation machine that centers on <code>rb_eval()</code><td></tr> <tr><td>Exception<td><td>Generation and backtrace generation of exception<td></tr> <tr><td>Method<td><td>Mounting of method call<td></tr> <tr><td>[Itere-ta]<td><td>Mounting of function that relates to block<td></tr> <tr><td>Loading<td><td>Loading and evaluation of foreign file<td></tr> <tr><td><code>Proc</code><td><td>Mounting of <code>Proc</code><td></tr> <tr><td>Thread<td><td>Mounting of Ruby thread<td></tr> </table> <p>The part of loading and the thread is the parts among these that should not be originally <code>eval.c</code>. The restriction of C language is only a reason for being in <code>eval.c</code>. It is because it is necessary to use the macro defined in <code>eval.c</code> such as <code>PUSH_TAG()</code> when saying a little more. Then, this two decided to be removed from the third, and to be treated fourthly. Moreover, because it has explained a safe level, in the first it might already be good. </p> <p>Six items of the remainder that cuts down the above-mentioned three are the third explanation objects. Correspondence with the chapter is shown in the following tables. </p> <p class="caption">- The third explanation allotment</p> <table> <tr><td>Operation of method entry<td><td>The next chapter'Context'<td></tr> <tr><td>Evaluation machine core<td><td>All chapters 3<td></tr> <tr><td>Exception<td><td>This chapter<td></tr> <tr><td>Method<td><td>Chapter 15'Method'<td></tr> <tr><td>[Itere-ta]<td><td>Chapter 16'Block'<td></tr> <tr><td><code>Proc</code><td><td>Chapter 16'Block'<td></tr> </table> <h2>Going by way of <code>main</code> <code>ruby_run</code> <code>rb_eval</code></h2> <h3>Call graph</h3> <p>The route from <code>main()</code> to the <code>rb_eval()</code> is chased recently though a true core of the evaluation machine is a function named <code>rb_eval()</code>. First of all, the following are rough call graphs around <code>rb_eval()</code>. </p> <pre class="emlist">
main ....main.c ruby_init ....eval.c ruby_prog_init ....ruby.c ruby_options ....eval.c ruby_process_options ....ruby.c ruby_run ....eval.c eval_node rb_eval *
ruby_stop </pre> <p>The file name was put right in the place where the file moved. To notice first of all because this is quietly seen is to call back the function of <code>main.c</code> from the function of <code>eval.c</code>. </p> <p>As for either <code>main.c</code> or <code>ruby.c</code>, having written calling back : It is because it is a file that becomes mounting the <code>ruby</code> command. In <code>eval.c</code>, the <code>ruby</code> command is mounting of the evaluation machine where a little keep away from. <code>Eval.c</code> is a standpoint used for <code>ruby.c</code>, and, in a word, when you call the function of <code>ruby.c</code> from <code>eval.c</code> The independence of <code>eval.c</code> falls. </p> <p>Then, it is likely to become it so why. The reason chiefly depends on the restriction of C language. There is a possibility that the exception occurs because it begins to use API in the Ruby world in <code>ruby_prog_init()</code> and <code>ruby_process_options()</code>. However, if the macro named <code>PUSH_TAG()</code> that can be used only in <code>eval.c</code> is not used to stop the exception of Ruby, it doesn't become it. <code>Ruby_init()</code> and <code>ruby_run()</code> should be <code>ruby.c</code> in a word originally. </p> <p>Then, <code>PUSH_TAG()</code> might be made why the <code>extern</code> function or what and it not open it to the public. <code>PUSH_TAG()</code> cannot be actually used as a pair with <code>POP_TAG()</code> as follows. </p> <pre class="emlist">
PUSH_TAG(); /* It does variously */. POP_TAG(); </pre> <p>It is necessary to put these two macros in the same function for reasons of mounting. Curettage doesn't come to be divided into a separate function because the speed slows if it is thought that it does though it is possible to mount. <p>It is that noticing seems to be very significant next that the function named <code>ruby_xxxx()</code> is continuously called from <code>main()</code>. If it is a symmetric figure, unrelated to anything is plainly amusing in the so much. </p> <p>A deep relation actually exists to these three functions. This three all are "Built-in Ruby interface. " when saying in a single phrase. It is a function that is used only when the command that builds in the <code>ruby</code> interpreter is made in a word and not used in the enhancing library. It is natural to use this interface because theoretical is thought to be a kind of built-in Ruby the program as for the <code>ruby</code> command. </p> <p>What is the prefix of <code>ruby _</code>?Up to now, the function of <code>ruby</code> all : It was <code>rb _</code>. Why are there two kinds about <code>rb _</code> and <code>ruby _</code>?I hear, it is "The one to assist the <code>ruby</code> command is <code>ruby _</code> and an official interface is <code>rb _</code>" because it doesn't understand the difference anyhow even if it examines it when the reason is heard directly. </p> <p>Then, why are <code>ruby_scope</code> etc. used only in <code>eval.c</code> <code>ruby _</code>?[Tsukko] [ndemiruto] and this seem to be ..mere.. coincidence. The change that put the prefix on all interfaces during 1.3 entered though <code>ruby_scope</code> etc. were originally the names of <code>the _</code>. It is. " in that time "Like inside somehow ..<code>ruby _</code>.. do not put out the putting phlegm to the variable. </p> <p>When only the conclusion is said in a word, the one that <code>ruby _</code> has adhered is a variable only for <code>ruby</code> command auxiliary use or internal. The one that <code>rb _</code> has adhered is <code>ruby</code> interpreter's official interface. ..saying.. </p> <h3><code>main()</code></h3> <p>It will see obediently from the <code>main()</code> first. Here is very short and survives. </p> <p class="caption">- <code>main()</code></p> <pre class="longlist">
36 int 37 main(argc, argv, envp) 38 int argc; 39 char **argv, **envp; 40 { 41 #if defined(NT) 42 NtInitialize(&amp;argc, &amp;argv); 43 #endif 44 #if defined(__MACOS__) &amp;&amp; defined(__MWERKS__) 45 argc = ccommand(&amp;argv); 46 #endif 47 48 ruby_init(); 49 ruby_options(argc, argv); 50 ruby_run(); 51 return 0; 52 } (main.c)
</pre> <p> <code>#Ifdef NT</code> is NT of Windows NT in nature. However, even Win9x : why NT is defined. It is the Win32 environment, ,in a word,, meaning. <code>NtInitialize()</code> is <code>argc argv</code> and a socket system for Win32 (WinSock) is initialized. This function is omitted because it is interesting only it is to initialize it or is unrelated to the main plot. </p> <p>Moreover, <code>__ MACOS__</code> is Mac OS of no "[Makosu]" it. In this case, it is before Mac OS 9, and Mac OS X doesn't enter. A present version doesn't move before Mac OS 9 as written first though such <code># ifdef</code> remains. It is a remaining influences when moving. Therefore, this code is abbreviated. </p> <p>By the way, the identifier that starts in under a bar has been reserved for system library and OS though it is thought that it knows if it is a well informed reader about C language. It is likely to become an error in cc [hen] for a moment if it uses it even if it is said that it will be reserved most though there is to the error. <code></code>For instance, <code>cc</code> of HP-UX. HP-UX is UNIX that <code>HP</code> makes. The opinion that HP-UX is not [hen] is emphasized and rejected. </p> <p>Oh dear, not defining it is a promise in the user application to such an identifier as for what. </p> <p>Then, let's explain [sara] built-in Ruby the interface. </p> <h3><code>ruby_init()</code></h3> <p> <code>Ruby_init()</code> initializes the Ruby interpreter. Because a present Ruby interpreter exists only by one per process, the argument and the return value are unnecessary. In general, this respect is thought to be "Lack of features". </p> <p>It might be in the development environment circumference of Ruby that embarrasses if the interpreter is only one even if it says very much. It is an application called RubyWin and RDE as it is concretely <code>irb</code>. Even if the program is rewritten and loaded, the class that is sure to erase it remains. It is considerably painful though can deal if reflection API is made good use of. </p> <p>However, original who waits seems to be limiting the number of interpreters to one apparently intentionally. "Complete initialization cannot be done" seems to be a reason. For instance, the example includes cannot remove the enhancing library that has been loaded. </p> <p>The code of <code>ruby_init()</code> is abbreviated because it is not significant even if it sees. </p> <h3><code>ruby_options()</code></h3> <p>Doing a command optional line in Perth for the Ruby interpreter It is <code>ruby_options()</code>. Of course, it is not necessary to use it according to the command. </p> <p><code>- in this function <code>e(The program is passed from the command line) is processed r</code>(load of the library) and -</code>. It is here to assume the file passed to the argument to be Ruby program to it and to do Perth. </p> <p>If the <code>ruby</code> command is not given there if the file is given The main program is read from <code>stdin</code>. Then, it introduced it secondarily The text is compiled to the syntax tree by using <code>rb_compile_string()</code> and <code>rb_compile_file()</code>. The result is set in global variable <code>ruby_eval_tree</code>. </p> <p>Because the code of <code>ruby_options()</code> is too honest and not interesting, either it abbreviates it. </p> <h3><code>ruby_run()</code></h3> <p>And, the evaluation of the syntax tree set in <code>ruby_eval_tree</code> with <code>ruby_run()</code> at the end begins. This function need not necessarily be called. There is a method of evaluating the character string by using the function named <code>rb_eval_string()</code> for instance besides <code>ruby_run()</code>. </p> <p class="caption">- <code>ruby_run()</code></p> <pre class="longlist">
1257 void 1258 ruby_run() 1259 { 1260 int state; 1261 static int ex; 1262 volatile NODE *tmp; 1263 1264 if (ruby_nerrs &gt; 0) exit(ruby_nerrs); 1265 1266 Init_stack((void*)&amp;tmp); 1267 PUSH_TAG(PROT_NONE); 1268 PUSH_ITER(ITER_NOT); 1269 if ((state = EXEC_TAG()) == 0) { 1270 eval_node(ruby_top_self, ruby_eval_tree); 1271 } 1272 POP_ITER(); 1273 POP_TAG(); 1274 1275 if (state &amp;&amp; !ex) ex = state; 1276 ruby_stop(ex); 1277 } (eval.c)
</pre> <p>You may disregard it for the time being though the macro named <code>PUSH_xxxx()</code> is seen. It explains either of details around here when living and coming. The important one : here It is only <code>eval_node()</code>. The contents [hato] [i] ..neglecting.. ,</p> <p class="caption">- <code>eval_node()</code></p> <pre class="longlist">
1112 static VALUE 1113 eval_node(self, node) 1114 VALUE self; 1115 NODE *node; 1116 { 1117 NODE *beg_tree = ruby_eval_tree_begin; 1118 1119 ruby_eval_tree_begin = 0; 1120 if (beg_tree) { 1121 rb_eval(self, beg_tree); 1122 } 1123 1124 if (!node) return Qnil; 1125 return rb_eval(self, node); 1126 } (eval.c)
</pre> <p><code>Rb_eval()</code> is called for <code>ruby_eval_tree</code>. <code>Ruby_eval_tree_begin</code> The sentence registered with <code>BEGIN</code> is stored. However, no do matter of this either. </p> <p>Moreover, end all threads, and [fainaraizu] all objects, check the exception, and finally in <code>ruby_stop()</code> in <code>ruby_run()</code> <code>Exit()</code> is called. Because here is also trivial, it doesn't see. </p> <h2><code>rb_eval()</code></h2> <h3>Outline</h3> <p>Well, it is <code>rb_eval()</code>. Only this function is a true nucleus of <code>ruby</code>. One time of the call of <code>rb_eval()</code> processes one <code>NODE</code>, and the entire syntax tree is processed while calling the reflexive (Figure 1). </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_evaluator_rbeval.jpg" alt="(rbeval)"><br>Figure 1: Image of <code>rb_eval</code></p> <p> <code>Rb_eval()</code> can be done as well as <code>yylex()</code> by a huge <code>switch</code> sentence, and it diverges in each node. First of all, let's see from [**katachi]. </p> <p class="caption">- <code>Rb_eval()</code> [**katachi]</p> <pre class="longlist">
2221 static VALUE 2222 rb_eval(self, n) 2223 VALUE self; 2224 NODE *n; 2225 { 2226 NODE *nodesave = ruby_current_node; 2227 NODE * volatile node = n; 2228 int state; 2229 volatile VALUE result = Qnil; 2230 2231 #define RETURN(v) do { \ 2232 result = (v); \ 2233 goto finish; \ 2234 } while (0) 2235 2236 again: 2237 if (!node) RETURN(Qnil); 2238 2239 ruby_last_node = ruby_current_node = node; 2240 switch (nd_type(node)) { case NODE_BLOCK: .....
case NODE_POSTEXE: .....
case NODE_BEGIN: : (a large amount of case sentence) : 3415 default: 3416 rb_bug("unknown node type %d", nd_type(node)); 3417 } 3418 finish: 3419 CHECK_INTS; 3420 ruby_current_node = nodesave; 3421 return result; 3422 } (eval.c)
</pre> <p>It lines up in the place in which it omitted it with ..processing code of all nodes.. [zura]. Because it does so, it diverges, and each node is processedIf the code is a little It is divided into the function when increasing though it is processed only in <code>rb_eval()</code>. Most of the function of <code>eval.c</code> is the one that was able to be done by doing so. </p> <p>When the value is returned from <code>rb_eval()</code>, not <code>return</code> but macro <code>RETURN()</code> is used. The purpose is to make it pass <code>CHECK_INTS</code> without fail. Because this macro is a thread relation, you may disregard it until the moment. </p> <p>After that, <code>result</code> and <code>node</code> of the local variable at the end It is GC measures that do <code>volatile</code>. </p> <h3><code>NODE_IF</code></h3> <p>Then, let's take as an example of the <code>if</code> sentence and see the process of the evaluation by <code>rb_eval()</code> concretely. Hereafter, in the explanation of <code>rb_eval()</code></p> <ul> <li>Source program(Ruby program)</li> <li>Syntax tree corresponding to it</li> <li>Node processing code in <code>rb_eval()</code></li> </ul> <p>It drinks and it will read enumerating in opening. </p> <p class="caption">- Source program</p> <pre class="longlist">
if true 'true expr' else 'false expr' end </pre> <p class="caption">- and done syntax tree for(<code>nodedump</code>)</p> <pre class="longlist">
NODE_NEWLINE nd_file = "if" nd_nth = 1 nd_next: NODE_IF nd_cond: NODE_TRUE nd_body: NODE_NEWLINE nd_file = "if" nd_nth = 2 nd_next: NODE_STR nd_lit = "true expr":String nd_else: NODE_NEWLINE nd_file = "if" nd_nth = 4 nd_next: NODE_STR nd_lit = "false expr":String </pre> <p><code>Elsif</code> and <code>unless</code> : in devising those who unite it as seen secondarily It is not necessary to treat specially because it is brought together in <code>NODE_IF</code> kinds. </p> <p class="caption">- <code>rb_eval()</code>-<code>NODE_IF</code></p> <pre class="longlist">
2324 case NODE_IF: 2325 if (trace_func) { 2326 call_trace_func("line", node, self, 2327 ruby_frame-&gt;last_
func, 2328 ruby_frame-&gt;last_class); 2329 } 2330 if (RTEST(rb_
eval(self, node-&gt;nd_cond))) { 2331 node = node-&gt;nd_body; 2332 } 2333 else { 2334 node = node-&gt;nd_else; 2335 } 2336 goto again; (eval.c)
</pre> <p>The important one is only the last <code>if</code> sentence. If this sentence is rewritten without changing the meaning, it becomes it so. </p> <pre class="emlist">
if (RTEST(rb_eval(self, node-&gt;nd_cond))) { (A) RETURN(rb_eval(self, node-&gt;nd_body)); (B) }
else { RETURN(rb_eval(self, node-&gt;nd_else)); (C)
}
</pre> <p>The conditional expression of Ruby (..drinking.. node) is evaluated by unpalatable (A), and the value is tested with <code>RTEST()</code>. It was a macro that tested <code>RTEST()</code> is whether <code>VALUE</code> was the truth of Ruby. The paragraph on the <code>then</code> side is evaluated by (B) if it is the truth, and if it is an imitation, the paragraph on the <code>else</code> side is evaluated by (C). </p> <p>And, the <code>if</code> type of Ruby is to have the value, too it is necessary to return the value. Because the value of <code>if</code> is a value of the paragraph of the <code>then</code> side or the <code>else</code> side and execution, it is returned by the <code>RETURN()</code> macro. </p> <p>It is appearing "Conversion ..end reflexive <code>→goto</code>.. ..the preceding chapter 'Construction of the syntax tree'.." to finish with <code>goto</code> without calling <code>rb_eval()</code> in the reflexive by an original list. </p> <h3><code>NODE_NEWLINE</code></h3> <p>I will see the processing code because there was <code>NODE_NEWLINE</code> in the <code>if</code> type. This node was the one like one-<code>stmt</code>-one attaching header. It is used to one by one match the position in the file of the program executing it in <code>rb_eval()</code>. </p> <p class="caption">- <code>rb_eval()</code>-<code>NODE_NEWLINE</code></p> <pre class="longlist">
3404 case NODE_NEWLINE: 3405 ruby_sourcefile = node-&gt;nd_file; 3406 ruby_sourceline = node-&gt;nd_nth; 3407 if (trace_func) { 3408 call_trace_func("line", node, self, 3409 ruby_frame-&gt;last_
func, 3410 ruby_frame-&gt;last_class); 3411 } 3412 node = node-&gt;
nd_next; 3413 goto again; (eval.c)
</pre> <p>Especially, it need not be difficult. </p> <p><code>NODE_IF</code> appeared in <code>call_trace_func()</code>. This easily explains. This is a function to trace the Ruby program from the Ruby level. Debugger <code>(debug.rb)</code>, tracer <code>(tracer.rb)</code>, profiler <code>(profile.rb)</code>, and <code>irb</code> (interactive <code>ruby</code> command), etc. use this function. </p> <p>The <code>Proc</code> object for the trace can be registered when the method named <code>set_trace_func</code> of the function style is called, and the <code>Proc</code> object : It is in <code>trace_func</code>. (With <code>call_trace_func()</code>) In a word, when <code>trace_func</code> is not 0 When it is not <code>Qfalse</code>, it is considered to be <code>Proc</code> object It executes it. </p> <p>It disregards it in this book thereafter all because this <code>call_trace_func()</code> is unrelated, and is not so interesting with the main plot. An interesting person wants you to challenge after 'Block' Chapter 16 is read. </p> <h3>Pseudolocal variable</h3> <p> <code>NODE_IF</code> etc. were the parts that corresponded to the paragraph if it said by the syntax tree. I will see the green part. </p> <p class="caption">- <code>Rb_eval()</code>-pseudolocal variable node</p> <pre class="longlist">
2312 case NODE_SELF: 2313 RETURN(self); 2314 2315 case NODE_NIL: 2316 RETURN(Qnil); 2317 2318 case NODE_TRUE: 2319 RETURN(Qtrue); 2320 2321 case NODE_FALSE: 2322 RETURN(Qfalse); (eval.c)
</pre> <p> <code>Self</code> was an argument of <code>rb_eval()</code>. It returns ahead for a moment, it confirms, and it wants it. Another might be good. </p> <h3>Jump tag</h3> <p>It is difficult only in the recursive call of the function to mount <code>break</code> and <code>next</code> though the following want to explain node <code>NODE_WHILE</code> corresponding to <code>while</code>. First of all, because <code>ruby</code> has achieved these syntaxes by using the jump tag, let's tell the story. </p> <p>In a word, the jump tag with library function <code>setjmp()</code> of C language It is a rapper of <code>longjmp()</code>. Do you know <code>setjmp()</code>?Those who use it there are considerably evil ways though <code>gc.c</code> has come out from this function. It is the one used ..<code>setjmp()</code>.. ..function.. to usually jump. Let's explain as an example of the following codes. The entry point is <code>parent()</code>. </p> <p class="caption">- <code>Setjmp()</code> and <code>longjmp()</code></p> <pre class="longlist">
jmp_buf buf; void child2(void) { longjmp(buf, 34); /* It returns to parent at a dash. The return value of setjmp becomes 34 */. Puts ("This message is never output");
}
void child1(void) { child2(); Puts ("This message is never output");
}
void parent(void) { int result; if ((result = setjmp(buf)) == 0) { /* */ that returns usually from setjmp Child1();
} else { /* */ that returns from child2 with longjmp Printf("%d\n", result); /* It is displayed as 34 */. }
}
</pre> <p>When <code>setjmp()</code> is first called with <code>parent()</code>, the running state at that time is recorded in <code>buf</code> of the argument. With an up-to-date address of the machine stack when having said for a moment immediately The register of CPU is recorded. It was to have returned from the <code>setjmp()</code> usually when the return value of <code>setjmp()</code> is 0, it only has to write the code of continuation usually. It is <code>if</code> side. <code>Child1()</code> is called here. </p> <p>And, <code>buf</code> of the argument when the control moves to <code>child2()</code> as follows and <code>longjmp</code> is called It is possible to return to the place where <code>setjmp</code> was done suddenly. In a word in this case, it returns to <code>setjmp</code> of <code>parent()</code>. When returning with <code>longjmp</code>, the <code>else</code> side is executed because the return value of <code>setjmp()</code> reaches the value of the second argument of <code>longjmp</code>. By the way, it is useless because it is made to a compulsorily different value even if 0 is passed to <code>longjmp</code>. </p> <p>When the state of the machine stack is made figure according to the example, it becomes as shown in Figure 2. A usual function returns only once about the call of one time. However, <code>Setjmp()</code> might return twice. Can the image be gripped a little when saying that it is the one like <code>fork()</code>?<p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_evaluator_setjmp.jpg" alt="(setjmp)"><br>Figure 2: <code>setjmp()</code> Image of <code>longjmp()</code></p> <p>Well, the preparation of <code>setjmp()</code> is up to here. <code>EXEC_TAG()</code> corresponds in <code>eval.c</code> and <code>setjmp()</code> and <code>JUMP_TAG()</code> correspond to <code>longjmp()</code> respectively (Figure 3). </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_evaluator_jumptag.jpg" alt="(jumptag)"><br>Figure 3: Image of tag jump</p> <p>There seems to be no argument in <code>EXEC_TAG()</code> when this figure is seen. <code>Jmp_buf</code> might gone to where. As for <code>jmp_buf</code>, the structure named <code>struct tag</code> is actually wrapped in <code>ruby</code>. Let's see. </p> <p class="caption">- <code>struct tag</code></p> <pre class="longlist">
783 struct tag { 784 jmp_buf buf; 785 struct FRAME *frame; /* FRAME */ 786 struct iter *iter when PUSH_TAG is done; /* ITER */ 787 ID tag when PUSH_TAG is done; /* kind */ of tag 788 VALUE retval; /* return value */ according to jump 789 Struct SCOPE *scope; /* SCOPE */ 79
0 int dst when PUSH_TAG is done; /* ID */ 791 struct tag *prev at jump destination;
792 }; (eval.c) </pre> <p><code>Struct tag</code> is predictable because there is <code>prev</code> member when might the stack structure that uses the link list. In addition, with <code>PUSH_TAG()</code> when you look about the circumference It seems to be correct in the stack because there is a macro named <code>POP_TAG()</code>. </p> <p class="caption">- <code>PUSH_TAG() POP_TAG()</code></p> <pre class="longlist">
793 static struct tag *prot_tag; /* Pointer that indicates point of stack */
795 #define PUSH_TAG(ptag) do { \ 796 struct tag _tag; \ 797 _tag.
retval = Qnil; \ 798 _tag.frame = ruby_frame; \ 799 _tag.iter = ruby_
iter; \ 800 _tag.prev = prot_tag; \ 801 _tag.scope = ruby_scope; \ 80
2 _tag.tag = ptag; \ 803 _tag.dst = 0; \ 804 prot_tag = &amp;_tag 818 #define POP_TAG() \ 819 if (_tag.prev) \ 820 _tag.prev-&gt;
retval = _tag.retval;\ 821 prot_tag = _tag.prev; \ 822 } while (0) (eval.c) </pre> <p>It seems very to put [beta] on the machine stack as a local variable and to be secured the substance of tag though I want you to be dumbfounded here (Figure 4). Moreover, <code>Do-while</code><code></code> is separate to two macros. Let's do not enter a considerably brutal class this even by those who use it about the pre-processor of C. Plainly It becomes it so when the macro of <code>PUSH/POP</code><code></code> teams and it develops. </p> <pre class="emlist">
do { struct tag _tag; _tag.prev = prot_tag; /* The previous tag is preserved */. prot_tag = &amp;_tag; *//* /* It is variously done that new tag is piled up in the stack */. prot_tag = _tag.prev; /* ..previous tag.. return */
} while (0); </pre> <p>It is equal to there is no overhead of the function call when it is this method and is no cost of the memory allocation. The evaluation machine of <code>ruby</code> is a reflexive of <code>rb_eval()</code> and ..made.. [rukarakosodekiru] technique. this technique</p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_evaluator_tagstack.jpg" alt="(tagstack)"><br>Figure 4: The tag stack is buried under the machine stack. </p> <p><code>PUSH_TAG()</code> and <code>POP_TAG()</code> are unpalatable as a pair in one function because such mounting if it doesn't put it. Moreover, because it is not the one that may be carelessly used outside the evaluation machine, either it is not possible to open it to the public. </p> <p>I will incidentally see <code>EXEC_TAG()</code> and <code>JUMP_TAG()</code>. </p> <p class="caption">- <code>EXEC_TAG() JUMP_TAG()</code></p> <pre class="longlist">
810 #define EXEC_TAG() setjmp(prot_tag-&gt;buf) 812 #define JUMP_TAG(st) do { \ 813 ruby_frame = prot_tag-&gt;frame; \ 814 ruby_iter = prot_tag-&gt;iter; \ 815 longjmp(prot_tag-&gt;buf,
(st)); \ 816 } while (0) (eval.c)
</pre> <p>When <code>setjmp</code> and <code>longjmp</code> ..thus.. are <code>EXEC_TAG()</code> respectively, <code>JUMP_TAG()</code> is wrapped. It sees like the moment rapper of <code>longjmp()</code> when seeing only on the character side named <code>EXEC_TAG()</code>, and here is execution of <code>setjmp()</code>. <p>Let's explain the mechanism of <code>while</code> based on above. First of all, when you begin <code>while</code> It <code>EXEC_TAG()s </code><code>(setjmp)</code>. <code>Rb_eval()</code> is executed and the main body of reflexive [shite] is executed afterwards. And, it <code>JUMP_TAG()s when there are </code><code>break</code> and <code>next</code> <code>(longjmp)</code>. Then, the <code>while</code> loop is begun and can return to the point (Figure 5). </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_evaluator_whilejmp.jpg" alt="(whilejmp)"><br>Figure 5: Mounting of <code>while</code> by tag jump</p> <p>Being not able to mount if not jumping is not only <code>break</code> though <code>break</code> was made an example here. There are <code>next</code> and <code>redo</code> even if it limits it to <code>while</code>. Moreover, the method <code>Return</code> and the exception are sure to have to exceed the wall of <code>rb_eval()</code>. And, it is the one that uses another tag stack for each that to be troublesome, and to be brought together somehow or other with one stack. </p> <p>To achieve it, it only has to apply information "Why is this jump a jump?". Because the return value of <code>setjmp()</code> was able to be specified for convenience when the argument is passed to <code>longjmp()</code>, it seems to only have to use it. The kind is shown with the following flag. </p> <p class="caption">- Tag type</p> <pre class="longlist">
Exception */ 834 # define TAG_THROW 0x7 /* throw (Do not treat in this book) */ 835 Exception fatal */ 836 #define TAG_MASK 0xf that cannot supplement # define TAG_FATAL 0x8 /*. (eval.c)
</pre> <p>The meaning : as shown in the comment. The last <code>TAG_MASK</code> is a bit mask to take out these flags of the return value of <code>setjmp()</code>. It is because information other than "Kind of the jump" might be put on the return value of <code>setjmp()</code>. </p> <h3><code>NODE_WHILE</code></h3> <p>Then, confirm those who use it about actual tag by the code of <code>NODE_WHILE</code>. </p> <p class="caption">- Source program</p> <pre class="longlist">
while true 'true_expr' end </pre> <p class="caption">- and done syntax tree for(<code>nodedump-short</code>)</p> <pre class="longlist">
NODE_WHILE nd_state = 1 (while) nd_cond: NODE_TRUE nd_body: NODE_STR nd_lit = "true_expr":String </pre> <p class="caption">- <code>rb_eval</code>-<code>NODE_WHILE</code></p> <pre class="longlist">
2418 case NODE_WHILE: 2419 PUSH_TAG(PROT_NONE); 2420 result = Qnil; 2421 switch (state = EXEC_TAG()) { 2422 case 0: 2423 if (node-&gt;nd_state &amp;&amp; !RTEST(rb_eval(self, node-&gt;nd_cond))) 2424 goto while_out; 2425 do { 2426 while_redo: 2427 rb_eval(self, node-&gt;nd_body); 2428 while_next: 2429 ; 2430 } while (RTEST(rb_eval(self, node-&gt;nd_cond))); 2431 break; 2432 2433 case TAG_REDO: 2434 state = 0; 2435 goto while_redo; 2436 case TAG_NEXT: 2437 state = 0; 2438 goto while_next; 2439 case TAG_BREAK: 2440 state = 0; 2441 result = prot_tag-&gt;retval; 2442 default: 2443 break; 2444 } 2445 while_out: 2446 POP_TAG(); 2447 if (state) JUMP_TAG(state); 2448 RETURN(result); (eval.c)
</pre> <p>The phrase that will appear many times many times in the future appears here. </p> <pre class="emlist">
PUSH_TAG(PROT_NONE); switch (state = EXEC_TAG()) { case 0: /* It processes usually */. break; case TAG_a: state = 0; /* Because it is a jump for which I was waiting, state is clear *//* processing */ when having flown with TAG_a Break;
case TAG_b: state = 0; /* Because it is a jump for which I was waiting, state is clear *//* processing */ when having flown with TAG_b Break;
default break; /* It is not a jump for which I was waiting. Then ……*/,
}
POP_TAG(); if (state) JUMP_TAG(state); /*…… It jumps again here. */ </pre> <p><code>First of all..above-mentioned..mechanism..without fail..as a pair.</code><code></code>Moreover, it should be outside of <code>EXEC_TAG()</code>. And, <code>jmp_buf</code> of just piling up now is <code>EXEC_TAG()ed. </code>In a word, it <code>setjmp()s it. </code>If the return value is 0 It was to have returned from <code>setjmp()</code> at once, it usually processes it (Usually <code>Rb_eval()</code> is included). I strain with <code>case</code>, take only a necessary jump because I returned with <code>longjmp()</code>, and the remainder is passed if the return value of <code>EXEC_TAG()</code> is numbers except 0 <code>(default)</code>. </p> <p>When the code of the jump is matched and seen, it might be comprehensible. The handler of the node of <code>redo</code> is shown as follows. </p> <p class="caption">- <code>rb_eval()</code>-<code>NODE_REDO</code></p> <pre class="longlist">
2560 case NODE_REDO: 2561 CHECK_INTS; 2562 JUMP_TAG(TAG_REDO); 2563 break; (eval.c)
</pre> <p>It returns to the <code>EXEC_TAG()</code> where it goes ahead by one when flying with <code>JUMP_TAG()</code>. The return value at that time is <code>TAG_REDO</code> of the argument. I want you to confirm between what route to pass looking at the code of <code>NODE_WHILE</code> thinking about it. <p>Then, the phrase assumes it is good, and explains the code of <code>NODE_WHILE</code> for a moment in detail already. It took out only there because this processing as said in <code>case 0</code>, and to become legible incidentally, some labels were moved. </p> <pre class="emlist">
if (node-&gt;nd_state &amp;&amp; !RTEST(rb_eval(self, node-&gt;nd_cond))) goto while_out; do { rb_eval(self, node-&gt;nd_body); } while (RTEST(rb_eval(self, node-&gt;nd_cond))); while_out:
</pre> <p><code>Node-&gt; nd_cond</code> that corresponds to the conditional expression is <code>rb_eval()ed in </code>two places. Only the first condition judgment seems to be separated. The purpose of this is to treat <code>do-while</code><code></code> and <code>while</code> collectively. <code>Node-&gt; nd_state</code> is usual <code>while</code> at the time of <code>do-while</code><code></code> and 1 at the time of 0. If it is possible to get it later honestly, it might understand. It doesn't explain separately. <p>By the way, I think that it will easily become an infinite loop if there are <code>next</code> and <code>redo</code> in the conditional expression. It is anxious for a moment though writing because of the code of such a meaning of course it is bad. Then, it actually tried. </p> <pre class="screen">
% ruby -e 'while next do nil end' -e:1: void value expression </pre> <p>..[hane].. [rare] of easy PerthIt is not an interesting result though is safe. By the way, it is <code>value_expr()</code> of <code>parse.y</code> to have put out this error. </p> <h3>Evaluation value of <code>while</code></h3> <p>It came to be able to return the value from <code>ruby 1.7</code> with <code>break</code> though <code>while</code> did not have the value for a long time. Let's this time pay attention to the flow of the evaluation value. I want you to have reaching of the value of local variable <code>result</code> to the return value of <code>rb_eval()</code> in mind and to see. </p> <pre class="emlist">
result = Qnil; switch (state = EXEC_TAG()) { case 0: /* This processing */
case TAG_REDO: case TAG_NEXT: /* Each jump */
case TAG_BREAK: state = 0; result = prot_tag-&gt;retval; (A) default: break; }
RETURN(result); </pre> <p>What should be paid attention is only (A). The return value of the jump It seems to be passed via <code>prot_tag-&gt; retval</code> ,in a word, <code>struct tag</code>. Passing is a long ages. </p> <p class="caption">- <code>rb_eval()</code>-<code>NODE_BREAK</code></p> <pre class="longlist">
2219 #define return_value(v) prot_tag-&gt;retval = (v) 2539 case NODE_BREAK: 2540 if (node-&gt;nd_stts) { 2541 return_value(avalue_to_svalue(rb_eval(self, node-&gt;nd_stts))); 2542 } 2543 else { 2544 return_value(Qnil); 2545 } 2546 JUMP_TAG(TAG_BREAK); 2547 break; (eval.c)
</pre> <p>The value is put in the structure in the tag stack point like this by the macro named <code>return_value()</code>. </p> <p>Actually though a basic flow is good in this Another <code>EXEC_TAG</code> can enter from <code>EXEC_TAG()</code> of <code>NODE_WHILE</code> to <code>JUMP_TAG()</code> of <code>NODE_BREAK</code>. For instance, there might be <code>rescue</code> of the exception handling on the way. </p> <pre class="emlist">
While cond # It is NODE_WHILE and EXEC_TAG. () It is re-EXEC_TAG here begin # for rescue. () break 1 rescue end end </pre> <p>Therefore, it is not understood whether it is tag that <code>struct tag</code> at the <code>JUMP_TAG()</code> with <code>NODE_BREAK</code> piled up with <code>NODE_WHILE</code>. In <code>POP_TAG()</code> in that case as follows <code>Retval</code> is passed and the following tag and the return value can be passed even if nothing is especially thought because it spreads. </p> <p class="caption">- <code>POP_TAG()</code></p> <pre class="longlist">
818 #define POP_TAG() \ 819 if (_tag.prev) \ 820 _tag.prev-&gt;
retval = _tag.retval;\ 821 prot_tag = _tag.prev; \ 822 } while (0) (eval.c)
</pre> <p>It is likely to become as shown in Figure 6 if it makes it to figure. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_evaluator_usetag.jpg" alt="(usetag)"><br>Figure 6: Spread of return value</p> <h2>Exception</h2> <p>The handling of the exception is seen as the second example of those who use it about the tag jump. </p> <h3><code>raise</code></h3> <p>The idea is changed this time because it saw on the tip of the <code>setjmp()</code> side <code>while</code> It will see from the <code>longjmp()</code> side. It is substance <code>rb_exc_raise()</code> of <code>raise</code>. </p> <p class="caption">- <code>rb_exc_raise()</code></p> <pre class="longlist">
3645 void 3646 rb_exc_raise(mesg) 3647 VALUE mesg; 3648 { 3649 rb_longjmp(TAG_RAISE, mesg); 3650 } (eval.c)
</pre> <p> <code>Mesg</code> is an exception object (instance of the class of <code>Exception</code> or less). It pays attention with <code>TAG_RAISE</code> this time ..seeming the jump... And, the one that <code>rb_longjmp()</code> was made easy to one's heart's content is shown below. </p> <p class="caption">- <code>rb_longjmp()</code>(abridgment version)</p> <pre class="longlist">
static void rb_longjmp(tag, mesg) int tag; VALUE mesg; {
if (NIL_P(mesg)) mesg = ruby_errinfo; set_backtrace(mesg, get_backtrace(mesg)); ruby_errinfo = mesg; JUMP_TAG(tag);
}
</pre> <p>It only jumps usually with <code>JUMP_TAG()</code> though it is natural if it is probably said it is natural. </p> <p>What is <code>ruby_errinfo</code>?When <code>grep</code> is done a little, this variable has been understood that substance ..Ruby.. ..global variable <code>$</code>.. drinking. Because this variable shows the exception being being generated now, it is sure to have the meaning as which <code>ruby_errinfo</code> of the substance is naturally the same. </p> <h3>Whole image</h3> <p class="caption">- Source program</p> <pre class="longlist">
begin raise('exception raised') rescue 'rescue clause' ensure 'ensure clause' end </pre> <p class="caption">- and done syntax tree for(<code>nodedump-short</code>)</p> <pre class="longlist">
NODE_BEGIN nd_body: NODE_ENSURE nd_head: NODE_RESCUE nd_head: NODE_FCALL nd_mid = 3857 (raise) nd_args: NODE_ARRAY [ 0:
NODE_STR nd_lit = "exception raised":String ]
nd_resq: NODE_RESBODY nd_args = (null) nd_body: NODE_STR nd_lit = "rescue clause":String nd_head = (null) nd_else = (null) nd_ensr: NODE_STR nd_lit = "ensure clause":String </pre> <p>Order is strictly decided to the syntax tree again like the order of <code>rescue</code> and <code>ensure</code> having been decided by [pa-sareberu]. <code>NODE_ENSURE</code> without fail comes and the main body (place with <code>raise</code>) comes ..".. most as follows ..that.. at <code>NODE_RESCUE</code> and the end. Because any <code>NODE_BEGIN</code> is a node doesn't have, you may actually think that there is <code>NODE_ENSURE</code> most up. </p> <p><code>Raise</code> is stopped by the <code>EXEC_TAG()</code> merely because of coming of <code>NODE_ENSURE</code> and <code>NODE_RESCUE</code> from the main body to be protected in a word up. Is it does do to finish being so up on the syntax tree, and more correct than it says solving?</p> <h3><code>ensure</code></h3> <p>The handler of node <code>NODE_ENSURE</code> of <code>ensure</code> is seen. </p> <p class="caption">- <code>rb_eval()</code>-<code>NODE_ENSURE</code></p> <pre class="longlist">
2634 case NODE_ENSURE: 2635 PUSH_TAG(PROT_NONE); 2636 if ((state = EXEC_TAG()) == 0) { 2637 result = rb_eval(self, node-&gt;nd_head); (A-1) 2638 } 2639 POP_TAG(); 2640 if (node-&gt;nd_ensr) { 2641 VALUE retval = prot_tag-&gt;retval; (B-1) 2642 VALUE errinfo = ruby_errinfo; 2643 2644 rb_eval(self, node-&gt;nd_ensr); (A-2) 2645 return_
value(retval); (B-2) 2646 ruby_errinfo = errinfo; 2647 } 2648 if (state) JUMP_TAG(state); (B-3) 2649 break; (eval.c)
</pre> <p>The divergence that uses this <code>if</code> is the second phrase that treats tag. It <code>EXEC_TAG()s, the </code>jump is stopped, and if paragraph <code>ensure</code> (<code>node-&gt; nd_ensr</code>) is evaluated, it becomes it. As for the flow of processing, it might be unquestionable. </p> <p>Moreover, it thinks about the evaluation value. When confirming it from the specification</p> <pre class="emlist">
begin expr0 ensure expr1 end </pre> <p>The value named the entire <code>begin</code> in case of the sentence reaches the value of <code>expr0</code> regardless of none with <code>ensure</code>. It is thrown away that it is reflected and is thrown away the evaluation value of paragraph <code>ensure</code> to no [**] in (A-1,2). </p> <p>Moreover, the evaluation value when the jump is generated by the main body in (B-1,3) has been treated. It saves in the local variable so that it is not carelessly rewritten while executing paragraph <code>ensure</code> in <code>prot_tag-&gt; retval</code> the value in that case (B-1). And, when the evaluation of paragraph <code>ensure</code> ends, it returns with <code>return_value()</code> (B-2). In a word, even if the jump has not been generated by the main body, no do matter of <code>state==0</code> because <code>prot_tag-&gt; retval</code> is not used to begin with at that time. </p> <h3><code>rescue</code></h3> <p>Because a little in has become empty, I will see the syntax tree of <code>rescue</code> again. </p> <p class="caption">- Source program</p> <pre class="longlist">
begin raise() rescue ArgumentError, TypeError 'error raised' end </pre> <p class="caption">- and done syntax tree for(<code>nodedump-short</code>)</p> <pre class="longlist">
NODE_BEGIN nd_body: NODE_RESCUE nd_head: NODE_FCALL nd_mid = 3857 (raise) nd_args = (null) nd_resq: NODE_RESBODY nd_args: NODE_ARRAY [ 0:
NODE_CONST nd_vid = 4733 (ArgumentError) 1:
NODE_CONST nd_vid = 4725 (TypeError) ]
nd_body: NODE_STR nd_lit = "error raised":String nd_head = (null) nd_else = (null)
</pre> <p> <code>Object..do..sentence..drink..confirm..desirous.</code><code></code></p> <p class="caption">- <code>rb_eval()</code>-<code>NODE_RESCUE</code></p> <pre class="longlist">
2590 case NODE_RESCUE: 2591 retry_entry: 2592 { 2593 volatile VALUE e_info = ruby_errinfo; 2594 2595 PUSH_TAG(PROT_NONE); 2596 if ((state = EXEC_TAG()) == 0) { 2597 result = rb_eval(self, node-&gt;nd_head); /* The main body is evaluated */ 2598. 2599 POP_TAG(); The exception was generated by the main body of /* */. 2601 NODE * volatile resq = node-&gt;nd_resq; 2602 /* */ that treats paragraph rescue sequentially 2604 ruby_current_
node = Resq;
*/ if it treats /* recently 2606 state = 0;
2607 PUSH_TAG(PROT_NONE); 2608 if ((state = EXEC_TAG()) == 0) { 2609 result = rb_eval(self, resq-&gt;nd_body); 2610 } /* Paragraph rescue is evaluated */ 2611 POP_TAG(); /* Because retry was generated */
2613 state = 0; 2614 ruby_errinfo = Qnil; /* The exception is stopping */ 2615 Goto retry_entry; Conversion. /* Return etc. are */ 2618 ruby_errinfo = E_info; /* stopping */ exception 2619 2620 break; 2621 } 2622 resq = resq-&gt;nd_head; /* advanced */ to the following paragraph rescue 2623 2624 } Only when the /* exception doesn't occur, it evaluates */. 2627 result = rb_eval(self, node-&gt;nd_else); 2628 } 2629 } 2630 if (state) JUMP_TAG(state); /* jump */ for which it doesn't wait 2631 2632 break; (eval.c)
</pre> <p>Only because the node is treated honestly and honestly, it is not difficult though there is somewhat code size. Neither [daga] nor this first ..putting out.. function <code>handle_rescue()</code> share for a moment and go because it sees now. It explains only the effect. The prototype</p> <pre class="emlist">
static int handle_rescue(VALUE self, NODE *resq)
</pre> <p>[De] and exception <code>(ruby_errinfo)</code> being being generated now It is judged whether it is a descendent class of the class (for instance, <code>TypeError</code>) shown with <code>resq</code>. <code>Self</code> has been passed because it is necessary to call <code>rb_eval()</code> to evaluate <code>resq</code> in the function. <hr> <p>The point of an opinion, an impression, and a mis-plant etc. are <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fmailto%3Aaamine%40loveruby.net&wb_lp=JAEN&wb_dis=2">[mine**] Aoki Thank you very much even for &lt; aamine@loveruby.net &gt;</a>. </p> <p> <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fdirect.ips.co.jp%2Fdirectsys%2Fgo_x_TempChoice.cfm%3Fsh_id%3DEE0040%26amp%3Bspm_id%3D1%26amp%3BGM_ID%3D1721&wb_lp=JAEN&wb_dis=2">It is possible to reserve ..direct ..'Ruby source code complete explanation'.. IMPRESS it.. and to buy it (Fly to the book introduction page. )</a> </p> <p>Copyright (c) 2002-2004 Minero Aoki, All rights reserved.</p> </body> </html>
<script src="http://rep.excite-webtl.jp/urchin.js" type="text/javascript"></script>
<script type="text/javascript">
_udn="excite-webtl.jp";
urchinTracker();
</script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-400370-52");
pageTracker._initData();
pageTracker._trackPageview();
</script>
