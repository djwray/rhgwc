<SCRIPT LANGUAGE="JavaScript">
<!--
var originalUrl="http://i.loveruby.net/ja/rhg/book/iterator.html";
var originalLp ="JAEN";
var originalDis="";
if (self.parent.excite_header.display) {
self.parent.excite_header.display.wb_url.value = originalUrl;
self.parent.excite_header.display.wb_lp.value = originalLp;
}
//-->
</SCRIPT>
<SCRIPT LANGUAGE="JavaScript">
<!--
if (top.excite_header)
{
// ok
}
else
{
top.location.href = "http://www.excite-webtl.jp/world/english/web/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fiterator.html&wb_lp=JAEN&wb_dis=";
}
//-->
</SCRIPT>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP"> <head><base href=http://i.loveruby.net/ja/rhg/book/iterator.html> <meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"> <meta http-equiv="Content-Language" content="ja-JP"> <link rel="stylesheet" type="text/css" href="rhg.css"> <link rev="made" href="mailto:aamine@loveruby.net"> <title>Chapter 16 Block</title></head> <body> <h1>Chapter 16 Block</h1> <h2>[Itere-ta]</h2> <p>The last important person and <code>BLOCK</code> of seven Ruby stacks appear in this chapter. As for an internal state of the evaluation machine, if this ends, it is just like understanding. </p> <h3>Whole image</h3> <p>How on earth is the mechanism of [itere-ta] going?First of all, let's think by a program that is the following and is small. </p> <p class="caption">- Source program</p> <pre class="longlist">
iter_method() do 9 Sign that searches for # block
end </pre> <p>The term is confirmed. <code>Iter_method</code> is [itere-tamesoddo] when saying by this program, and <code>do-end</code><code></code> is [itere-taburokku]. When the syntax tree of this program was dumped, it became it so. </p> <p class="caption">- and done syntax tree for</p> <pre class="longlist">
NODE_ITER nd_iter: NODE_FCALL nd_mid = 9617 (iter_method) nd_args = (null) nd_var = (null) nd_body: NODE_LIT nd_lit = 9:Fixnum </pre> <p> It understands. ..seeming show [itere-taburokku] by <code>NODE_ITER</code>..With it <code>NODE_FCALL</code> that calls <code>iter_method</code> is in "Under" of the <code>NODE_ITER</code>. In a word, it is on the tip of the node of [itere-taburokku] the call of [itere-tamesoddo]. Then, the block seems to be piled up by another node before [itere-tamesoddo] is called. </p> <p>Moreover, when the flow of the code is chased and confirmed by the debugger, it has been understood that the start of [itere-ta] has divided into three stages where <code>NODE_YIELD</code> was added to this <code>NODE_ITER NODE_CALL</code>. It</p> <ol> <li>The block is piled up. (<code>NODE_ITER</code>)</li> <li>The method that is [itere-ta] is called. (<code>NODE_CALL</code>)</li> <li><code>yield</code>(<code>NODE_YIELD</code>)</li> </ol> <p>[Dearu]. </p> <h3>The block has been pushed. </h3> <p>Then, it will see from the node that first piles up the block of the first stage and <code>NODE_ITER</code>. </p> <p class="caption">- <code>rb_eval()</code>-<code>NODE_ITER</code>(abridgment version)</p> <pre class="longlist">
case NODE_ITER: {
iter_retry: PUSH_TAG(PROT_FUNC); PUSH_BLOCK(node-&gt;nd_var, node-&gt;nd_body); state = EXEC_TAG(); if (state == 0) { PUSH_ITER(ITER_PRE); result = rb_eval(self, node-&gt;nd_iter); POP_ITER(); }
else if (_block.tag-&gt;dst == state) { state &amp;= TAG_MASK; if (state == TAG_RETURN || state == TAG_BREAK) { result = prot_tag-&gt;retval; }
}
POP_BLOCK(); POP_TAG(); switch (state) { case 0: break; case TAG_RETRY: goto iter_retry; case TAG_BREAK: break; case TAG_RETURN: return_value(result); /* fall through */ default: JUMP_TAG(state); }
}
break;
</pre> <p>Because the <code>for</code> sentence was supported in former code, it is deleted. They are only Push Pops of <code>ITER</code> and <code>BLOCK</code> except the tag relation. The necessary condition for this <code>ITER</code> and <code>BLOCK</code> to make the method [itere-ta] only because it usually <code>rb_eval()s it </code><code>NODE_FCALL</code>. </p> <p>Is it assumed to be a probably good to need the push of <code>BLOCK</code>, and why is there <code>ITER</code>?It is necessary to think by actually becoming the body of the use of <code>BLOCK</code> to consider the meaning of <code>ITER</code>. </p> <p>For instance, let's assume that the method was exactly called now. And, <code>ruby_block</code> existed. However, <code>BLOCK</code> understands by the block and doesn't understand whether existence [surukara] and [i] are blocks where it was piled up for me with the delimitation of the method call by me because it is piled up regardless. Are not you ..might the block piled up for the method in front of me.. (Figure 1)?</p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_iterator_stacks.jpg" alt="(stacks)"><br>Figure 1: Neither <code>FRAME</code> nor <code>BLOCK</code> are for the one to one. </p> <p>Then, to distinguish for which method the block was piled up Because <code>ITER</code> is used. <code>BLOCK</code> is piled up because heavily for a moment when why <code>BLOCK</code> of each <code>FRAME</code> is not piled up is said. Let's actually see and confirm how heavy it to be. </p> <h4><code>PUSH_BLOCK()</code></h4> <p>The argument of <code>PUSH_BLOCK()</code> is a block parameter ([bunki] of ..drinking.. [kama]) and a main body of the block. </p> <p class="caption">- <code>PUSH_BLOCK() POP_BLOCK()</code></p> <pre class="longlist">
592 #define PUSH_BLOCK(v,b) do { \ 593 struct BLOCK _block; \ 594 _
block.tag = new_blktag(); \ 595 _block.var = v; \ 596 _block.body = b; \ 597 _block.self = self; \ 598 _block.frame = *ruby_frame; \ 599 _block.klass = ruby_class; \ 600 _block.frame.node = ruby_current_
node;\ 601 _block.scope = ruby_scope; \ 602 _block.prev = ruby_block; \ 603 _block.iter = ruby_iter-&gt;iter; \ 604 _block.vmode = scope_
vmode; \ 605 _block.flags = BLOCK_D_SCOPE; \ 606 _block.dyna_vars = ruby_dyna_vars; \ 607 _block.wrapper = ruby_wrapper; \ 608 ruby_
block = &amp;_block 610 #define POP_BLOCK() \ 611 if (_block.tag-&gt;flags &amp; (BLOCK_DYNAMIC)) \ 612 _block.tag-&
gt;flags | = BLOCK_ORPHAN; \ 613 else if (!(_block.
scope-&gt;flags &amp; SCOPE_DONT_RECYCLE)) \ 614 rb_gc_force_recycle(
(VALUE)_block.tag); \ 615 ruby_block = _block.prev; \ 616 } while (0) (eval.c)
</pre> <p><code>BLOCK</code> is "Snap shot of the environment in the made point. " when confirming it. Six stack frames other than <code>CREF</code> and <code>BLOCK</code> are preserved by that token. Because it is possible to substitute it with <code>ruby_frame-&gt; cbase</code>, <code>CREF</code> need not be piled up. </p> <p>I want to confirm three points about the mechanism of the push again. <code>BLOCK</code> also must put [beta] in the stack and secure. <code>FRAME</code> at the time of this must be copied onto <code>BLOCK</code> wholly. <code>BLOCK</code> is the previous unlike a lot of other stack frame structures Have pointer <code>(prev)</code> to <code>BLOCK</code>. </p> <p>It doesn't explain now because the flag variously used with <code>POP_BLOCK()</code> is not understood if it doesn't see collectively after mounting <code>Proc</code> will be seen later. </p> <p>Well, it seems certainly to be a little heavy though it is a story that <code>BLOCK</code> is heavy. When the inside is seen, <code>new_blktag()</code> <code>malloc()s, and </code>stores a large amount of members. However, after comparing <code>PUSH_ITER()</code>, it is a mother-of-pearl way that does a final judgment. </p> <h4><code>PUSH_ITER()</code></h4> <p class="caption">- <code>PUSH_ITER() POP_ITER()</code></p> <pre class="longlist">
773 #define PUSH_ITER(i) do { \ 774 struct iter _iter; \ 775 _iter.
prev = ruby_iter; \ 776 _iter.iter = (i); \ 777 ruby_iter = &amp;_
iter 779 #define POP_ITER() \ 780 ruby_iter = _iter.prev; \ 78
1 } while (0) (eval.c)
</pre> <p>Here seems to be obviously light. Using it also is only a stack area, and has only two members. Even if each <code>FRAME</code> is piled up, it seems not to be wonderful if it is this. </p> <h3>[Itere-tamesoddo] call</h3> <p>When the block is piled up, the following will call [itere-ta] ([dearu]) method. Then, a little beginning is necessary. Do you remember there was a code in which the value of <code>ruby_iter</code> is changed at the beginning of <code>rb_call0()</code>?It is here. </p> <p class="caption">- It changes to <code>rb_call0()</code> - <code>ITER_CUR</code>. </p> <pre class="longlist">
4498 switch (ruby_iter-&gt;iter) { 4499 case ITER_PRE: 4500 itr = ITER_CUR; 4501 break; 4502 case ITER_CUR: 4503 default: 4504 itr = ITER_NOT; 4505 break; 4506 } (eval.c)
</pre> <p><code>Ruby_iter</code> : in this code because it piled up <code>ITER_PRE</code> a little while ago with <code>NODE_ITER</code> It becomes <code>ITER_CUR</code>. It is this and the method is "Become it" division into [itere-ta] for the first time. Moreover, when the state of the stack is shown in the figure, it becomes as shown in Figure 2. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_iterator_itertrans.jpg" alt="(itertrans)"><br>Figure 2: Appearance of Ruby stack when [itere-ta] is called</p> <p>The reason for the value of <code>ruby_iter</code> is that dividing into three stages will have a little space by the time [itere-tamesoddo] starts after piling up the block but two of the truths. For instance, the evaluation of the argument of [itere-tamesoddo] is got in. There is a possibility to be used with ours the block piled up now being misunderstood while the.. evaluating it because the call of the method must be likely to be in that it. Therefore, it should be in <code>rb_call0()</code> immediately before the start is completed to make to …… <code>ITER_CUR</code> that becomes [itere-ta]. </p> <p class="caption">- The processing order</p> <pre class="longlist">
<span class="ami">Block..pile..argument..evaluation..method..call.</span><span class="ami"></
span><span class="ami"></span><span class="ami"></span>
</pre> <p>For instance, it was the preceding chapter 'Method' and there was a macro named <code>BEGIN_CALLARGS</code> in the handler of <code>NODE_CALL</code>. This has exactly used three stages <code>ITER</code>. Let's return for a moment and see. </p> <h4><code>BEGIN_CALLARGS END_CALLARGS</code></h4> <p class="caption">- <code>BEGIN_CALLARGS END_CALLARGS</code></p> <pre class="longlist">
1812 #define BEGIN_CALLARGS do {\ 1813 struct BLOCK *tmp_block = ruby_
block;\ 1814 if (ruby_iter-&gt;iter == ITER_PRE) {\ 1815 ruby_block = ruby_block-&gt;prev;\ 1816 }\ 1817 PUSH_ITER(ITER_NOT) 1819 #define END_CALLARGS \ 1820 ruby_block = tmp_block;\ 1821 POP_
ITER();\ 1822 } while (0) (eval.c)
</pre> <p>When <code>ruby_iter</code> is <code>ITER_PRE</code>, one <code>ruby_block</code> is removed. For instance, it is the following to take an active part this code. </p> <pre class="emlist">
obj.m1 { nil }.m2 { nil } </pre> <p>The order of the evaluation of this expression</p> <ol> <li>The block of <code>m2</code> is pushed. </li> <li>The block of <code>m1</code> is pushed. </li> <li>Method <code>m1</code> call</li> <li>Method <code>m2</code> call</li> </ol> <p>It becomes it. Therefore, <code>m1</code> calls the block of <code>m2</code> if there is no <code>BEGIN_CALLARGS</code>. </p> <p>Moreover, in that case even if another [itere-ta] is connected Because the number of <code>BEGIN_CALLARGS</code> increases together, too it is unquestionable. </p> <h3>Block start</h3> <p>The third stage of the [itere-ta] start ,in a word, the last stage is an activation of blocks. </p> <p class="caption">- <code>rb_eval()</code>-<code>NODE_YIELD</code></p> <pre class="longlist">
2579 case NODE_YIELD: 2580 if (node-&gt;nd_stts) { 2581 result = avalue_to_yvalue(rb_eval(self, node-
&gt;nd_stts)); 2582 } 2583 else { 2584 result = Qundef; /* no arg */ 2585 } 258
6 SET_CURRENT_SOURCE(); 2587 result = rb_yield_0(result, 0, 0, 0); 2588 break; (eval.c)
</pre> <p> <code>Nd_stts</code> is an argument of <code>yield</code>. It disregards and is unquestionable for <code>avalue_to_yvalue()</code> only though touches for a moment in the multiple assignment. The core of operation is not these kind of things but <code>rb_yield_0()</code>. This function is simplified to one's heart's content and put because it is long, too. The method is only the one the current having used it. </p> <ul> <li>The <code>trace_func</code> relation is cut down. </li> <li>The error is cut down. </li> <li>The code that is only for the GC avoiding is cut down. </li> <li>There is argument <code>pcall</code> as well as <code>massign()</code>. </li>Only it is to change the severity of the argument check, no do matter of this argument. Therefore, it is assumed <code>pcall=0</code> and puts constant [**] seeing. </ul> <p>Moreover, the following "Legible optimization option" was turned on further this time. </p> <ul> <li>After leaving only the one of the main, each branch cuts down an equal code divergence. </li> <li>The condition that is truth/imitation if almost is always considered to be truth/imitation. </li> <li>The tag jump assumes no complete occurrence and erases all the tag relations. </li> </ul> <p>It does here and it shortens. </p> <p class="caption">- <code>rb_yield_0()</code>(abridgment version)</p> <pre class="longlist">
static VALUE rb_yield_0(val, self, klass, /* pcall=0 */) VALUE val, self, klass; {
volatile VALUE result = Qnil; volatile VALUE old_cref; volatile VALUE old_wrapper; struct BLOCK * volatile block; struct SCOPE * volatile old_scope; struct FRAME frame; int state; PUSH_VARS(); PUSH_CLASS(); block = ruby_block; frame = block-&gt;frame; frame.prev = ruby_frame; ruby_frame = &amp;(frame); old_cref = (VALUE)ruby_cref; ruby_cref = (NODE*)ruby_frame-&gt;cbase; old_wrapper = ruby_wrapper; ruby_wrapper = block-&gt;wrapper; old_scope = ruby_scope; ruby_scope = block-&gt;scope; ruby_block = block-&gt;prev; ruby_dyna_vars = new_dvar(0, 0, block-&gt;dyna_vars); ruby_class = block-&gt;klass; self = block-&gt;self; /* The block argument is set */. massign(self, block-&gt;var, val, pcall); PUSH_ITER(block-&gt;iter); /* The main body of the block is executed */. result = rb_eval(self, block-&gt;body); POP_ITER(); POP_CLASS(); /*…… ……*/ that collects ruby_dyna_vars POP_VARS(); ruby_block = block; ruby_frame = ruby_frame-&gt;prev; ruby_cref = (NODE*)old_cref; ruby_wrapper = old_wrapper; ruby_scope = old_scope; return result;
}
</pre> <p>As you see, it substitutes it secretly to the one that most stack frames were memorized in <code>ruby_block</code>. The one that saves simple and has returned assumes it is good, and will see the treatment of other frames that should be noted. </p> <h4><code>FRAME</code></h4> <pre class="emlist">
struct FRAME frame; frame = block-&gt;frame; /* Structure [marugo] and copy */
frame.prev = ruby_frame; /* By these two lines ……*/
ruby_frame = &amp;(frame); /*…… Frame is pushed */. </pre> <p><code>FRAME</code> is not the one memorizing it as it is and is new unlike other frames It seems to reproduce <code>FRAME</code> and to make it. It becomes as shown in Figure 3 in a word. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_iterator_framepush.jpg" alt="(framepush)"><br>Figure 3: The copied frame is piled up. </p> <p>When the code to here is seen, <code>FRAME</code> seems not to have what "Recycle" is done. Whenever <code>FRAME</code> is piled up, new <code>FRAME</code> is made. </p> <h4><code>BLOCK</code></h4> <pre class="emlist">
block = ruby_block; : ruby_block = block-&gt;prev; : ruby_block = block;
</pre> <p>It is these operation of <code>BLOCK</code> most not to understand division. Whether it saves or it costs it in pop is not understood well. It returns to the origin finally, the second sentence might because be on earth connected with what result though it is possible to understand pairing of the first sentence with the third sentence. </p> <p>It is "Return to <code>ruby_block</code> when the block is piled up. " as for the conclusion about which it variously thinks in a word. Because it only has to return state of stack frame to [itere-ta] and [hayousuru] at point that makes block because it is syntax that returns to frame beforeAnd, the value of <code>ruby_block</code> when the block was made must have been <code>block-&gt; prev</code>. Therefore, it is in <code>prev</code>. </p> <p>Moreover, it can do nothing but be said to the doubt "May I assume that I always start one of the <code>ruby_block</code> heads?", "You may assume it so as <code>rb_yield_0()</code> side". It is because of work on the side where the block is prepared piling up the block that should start on top of <code>ruby_block</code>, and no work of <code>rb_yield_0()</code>. </p> <p>It is <code>BEGIN_CALLARGS</code> that the one example did in the preceding chapter. The block that should not be used comes to the head of the stack being piled up the block by two steps when the [itere-ta] call does the cascade. Therefore, the check was purposely put and it removed it sideways. </p> <h4><code>VARS</code></h4> <p>Incidently, contents of <code>PUSH_VARS()</code> and <code>POP_VARS()</code> still think that it doesn't see. I will see it here. </p> <p class="caption">- <code>PUSH_VARS() POP_VARS()</code></p> <pre class="longlist">
619 #define PUSH_VARS() do { \ 620 struct RVarmap * volatile _old; \ 621 _old = ruby_dyna_vars; \ 622 ruby_dyna_vars = 0 624 #define POP_VARS() \ \ 626 if (flags of RBASIC(_old)-&gt;) If /* is not recycled, */ \ 627 FL_SET(_old, DVAR_DONT_RECYCLE); \. 628 } \ 629 ruby_dyna_vars = _old; \ 630 } while (0) (eval.c)
</pre> <p>Because this doesn't pile up the novel structure, either saying, "Save and return" is near. <code>PUSH_VARS()</code> is actually only used in <code>rb_yield_0()</code> to save the value. It is in this line that actually prepares <code>ruby_dyna_vars</code>. </p> <pre class="emlist">
ruby_dyna_vars = new_dvar(0, 0, block-&gt;dyna_vars);
</pre> <p><code>Dyna_vars</code> memorized in <code>BLOCK</code> is taken out and set. One entry is incidentally put. Be to want you to recall the structure of <code>ruby_dyna_vars</code> done secondarily, and <code>RVarmap</code> of 0 to have used <code>id</code> generated here as a delimitation of the block scope. </p> <p>However, the shape of the link stored in <code>ruby_dyna_vars</code> is slightly different in the parser and the evaluation machine actually. The function for which the block local variable is substituted in a present block Let's see <code>dvar_asgn_curr()</code>. </p> <p class="caption">- <code>dvar_asgn_curr()</code></p> <pre class="longlist">
737 static inline void 738 dvar_asgn_curr(id, value) 739 ID id; 740 VALUE value; 741 { 742 dvar_asgn_internal(id, value, 1); 743 } 699 static void 700 dvar_asgn_internal(id, value, curr) 701 ID id; 702 VALUE value; 703 int curr; 704 { 705 int n = 0; 706 struct RVarmap *vars = ruby_dyna_vars; 707 708 while (vars) { 709 if (curr &amp;&amp; vars-&gt;id == 0) { 710 /* first null is a dvar header */ 711 n++; 712 if (n == 2) break; 713 } 714 if (vars-&gt;id == id) { 715 vars-&gt;val = value; 716 return; 717 } 718 vars = vars-&gt;next; 719 } 720 if (!ruby_dyna_vars) { 721 ruby_dyna_vars = new_dvar(id, value, 0); 722 } 723 else { 724 vars = new_dvar(id, value, ruby_dyna_vars-&gt;
next); 725 ruby_dyna_vars-&gt;next = vars; 726 } 727 } (eval.c)
</pre> <p>The last <code>if</code> sentence is an addition of the variable. When it pays attention there, <code>ruby_dyna_vars</code> always It is understood to make the link interrupt "Following". It becomes as shown in Figure 4 in a word. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_iterator_dynavarseval.jpg" alt="(dynavarseval)"><br>Figure 4: Structure of <code>ruby_dyna_vars</code></p> <p>The difference of parser is two points. First of all, header (id=0) that shows the zosh in scope adheres to the hand side of the link. Moreover, there is no link that hangs from this chain. That is, <code>ruby_dyna_vars</code> always forms one straight list. </p> <p>There is relativity to say nothing of these two points. The entry hung on the way should be able to be inserted in the parser to adjust the list to one on the way of the list. However, if the header has adhered to the interior, it is good at the first one scope and is not possible to insert it (Figure 5). It returns to the head to operate it like this (To begin with, it is difficult), all links are traced or if the <code>prev</code> link is not put, it doesn't become it. The former is troublesome, diminishes in speed, and because the latter doesn't have the space in <code>RVarmap</code>, it is impossible. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_iterator_insert.jpg" alt="(insert)"><br>Figure 5: The entry cannot be inserted well. </p> <h3>Target specification jump</h3> <p>There is a device in the jump of <code>rb_yield_0()</code> without so far though the jump tag relation is erased a little while ago and it showed it. I will say the cause first. why to need devisingI want you to see the following programs. </p> <pre class="emlist">
[0].each do break end # Place that comes off with break
</pre> <p>Thus, it is sure to have to come off to the method of piling up the block when <code>break</code> is done from the block. What is it actually?Let's think about the call graph when [itere-ta] is started (dynamic) by seeing. </p> <pre class="emlist">
rb_eval(NODE_ITER) .... catch(TAG_BREAK) rb_eval(NODE_CALL) .... catch(TAG_BREAK) rb_eval(NODE_YIELD) rb_yield_0 rb_eval(NODE_BREAK) .... throw(TAG_BREAK)
</pre> <p>You might have to return to <code>NODE_ITER</code> in <code>break</code> because it is <code>NODE_ITER</code> to pile up the block. However, <code>NODE_CALL</code> waits for <code>TAG_BREAK</code> before <code>NODE_ITER</code>. It is because it makes an error of <code>break</code> of the method. This was embarrassed. It is necessary to come off to <code>NODE_ITER</code> at a dash somehow or other. </p> <p>Moreover, "Return to <code>NODE_ITER</code>" is still unpalatable actually. If it is a nest, [itere-ta] limits and without two or more <code>NODE_ITER</code>'s being likely being likely to exist either not corresponding to a present block limit most as the first <code>NODE_ITER</code>. It is necessary to limit only "The block starting now was piled up <code>NODE_ITER</code>" in a word and to return. </p> <p>Then, let's be why or see. </p> <p class="caption">- <code>Rb_yield_0()</code>-tag relation</p> <pre class="longlist">
3826 PUSH_TAG(PROT_NONE); 3827 if ((state = EXEC_TAG()) == 0) { /*…… The main body is evaluated ……*/. 3838 } 3839 else { 3840 switch (state) { 3841 case TAG_REDO: 3842 state = 0; 3843 CHECK_INTS; 3844 goto redo; 3845 case TAG_NEXT: 3846 state = 0; 3847 result = prot_tag-&gt;retval; 3848 break; 3849 case TAG_BREAK: 3850 case TAG_RETURN: 3851 state | = (serial++ &lt;&lt; 8); 3852 state | = 0x10; 3853 block-&gt;tag-&gt;dst = state; 3854 break; 3855 default: 3856 break; 3857 } 3858 } 3859 POP_TAG(); (eval.c) </pre> <p> <code>TAG_BREAK</code> and <code>TAG_RETURN</code> are essential. </p> <p>First of all, because <code>serial</code> is a static variable of <code>rb_yield_0()</code>, a different value at each call of <code>rb_yield_0()</code> will be obtained. "Serial number. " ..of <code>"serial"</code>.. It is <code>serial</code>. </p> <p>For the left shift by eight bits to avoid value of <code>TAG_xxxx</code><code>TAG_xxxx</code> It ends if there are four bits because it is <code>0x1-0x8</code><code></code>. And, it seems that bit or of <code>0x10</code> is the overflow measures of <code>serial</code>. When it is 32 bit machine, <code>serial</code> : by 24 bits It overflows it without taking ten seconds if it is a recent machine because there is only (16 million times). Then, because 0 will stand in a row in 24 subordinate position bits, <code>state</code> reaches the same value as <code>TAG_xxxx</code> without <code>0x10</code> as for the times (Refer to Figure 6). <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_iterator_dst.jpg" alt="(dst)"><br>Figure 6: <code>Block-&gt; tag-&gt; dst</code></p> <p>Well, <code>tag-&gt; dst</code> reached a unique value at each call by this unlike <code>TAG_xxxx</code>. Then, because it becomes impossible to receive in usual <code>switch</code> like the situation to date, a device moderate as for the stop of the jump is sure to be needed. It is here of <code>rb_eval:NODE_ITER</code> when saying somewhere. </p> <p class="caption">- <code>rb_eval()</code>-<code>NODE_ITER</code>(The jump is stopped. )</p> <pre class="longlist">
case NODE_ITER: {
state = EXEC_TAG(); if (state == 0) { /*…… [Itere-ta] is started ……*/. }
else if (_block.tag-&gt;dst == state) { state &amp;= TAG_MASK; if (state == TAG_RETURN || state == TAG_BREAK) { result = prot_tag-&gt;retval; }
}
}
</pre> <p><code>Tag-&gt; dst</code> set with <code>rb_yield_0()</code> will come out in here in corresponding <code>NODE_ITER</code> and <code>rb_yield_0()</code> it is to be sure to indicate the same one by <code>block</code>. Because then, jump is stopped well only with corresponding <code>NODE_ITER</code></p> <h3>Check on block</h3> <p>It can be confirmed whether there is a blocked block whether the method of the present evaluation is [itere-ta] by peel <code>rb_block_given_p()</code>. If here is read, mounting might be understood. </p> <p class="caption">- <code>rb_block_given_p()</code></p> <pre class="longlist">
3726 int 3727 rb_block_given_p() 3728 { 3729 if (ruby_frame-&gt;iter &amp;&amp; ruby_block) 3730 return Qtrue; 3731 return Qfalse; 3732 } (eval.c)
</pre> <p>I think it is unquestionable. It is actually function <code>rb_f_block_given_p()</code> for another check to have wanted to mention this time. </p> <p class="caption">- <code>rb_f_block_given_p()</code></p> <pre class="longlist">
3740 static VALUE 3741 rb_f_block_given_p() 3742 { 3743 if (ruby_frame-&gt;prev &amp;&amp; ruby_frame-&gt;prev-&gt;iter &amp;&amp; ruby_block) 3744 return Qtrue; 3745 return Qfalse; 3746 } (eval.c)
</pre> <p>Here is <code>block_given? of Ruby. </code>It is ..drinking.. substance. Compared with <code>rb_block_given_p()</code> It seems to be different examining <code>prev</code> of <code>ruby_frame</code>. [Darou] . why</p> <p>Now in <code>rb_block_given_p()</code> when the mechanism that the block is piled up is considered It is correct to examine <code>ruby_frame</code>. However, <code>block_given? from the Ruby level. </code><code>Block_given? when [wo] is called</code>Because it is a method, <code>FRAME</code> is piled up by one extra step. Therefore, it is necessary to examine ahead another step. </p> <h2><code>Proc</code></h2> <p>When the <code>Proc</code> object is said from the viewpoint of mounting, it is "It is possible to take it out at the Ruby level <code>BLOCK</code>. "When and where it is used while degree of freedom goes up is not understood then at all it is possible to take it out at the Ruby level either. Mounting is seen as that pays attention ..how it influences... </p> <h3>Generation of <code>Proc</code> object</h3> <p>The <code>Proc</code> object was to have made it from <code>Proc.new</code>. The substance is <code>proc_new()</code>. </p> <p class="caption">- <code>proc_new()</code></p> <pre class="longlist">
6418 static VALUE 6419 proc_new(klass) 6420 VALUE klass; 6421 { 6422 volatile VALUE proc; 6423 struct BLOCK *data, *p; 6424 struct RVarmap *vars; 6425 6426 if (!rb_block_given_p() &amp;&amp; !rb_f_block_given_p()) { 6427 rb_raise(rb_eArgError, "tried to create Proc object without a block"); 6428 } 6429 /* (A) struct RData and struct BLOCK are collectively secured */. 6430 proc = Data_Make_Struct(klass, struct BLOCK, blk_mark, blk_free, data); 6431 *data = *ruby_block; 6432 6433 data-&gt;orig_thread = rb_thread_current(); 6434 data-&gt;wrapper = ruby_wrapper; 6435 data-&gt;iter = data-&gt;prev?Qtrue:Qfalse; /* Initialization (B) essential is completed here */. 6436 frame_dup(&amp;data-&gt;frame); 6437 if (data-&gt;iter) { 6438 blk_copy_prev(data); 6439 } 6440 else { 6441 data-&gt;prev = 0; 6442 } 6443 data-&gt;flags | = BLOCK_DYNAMIC; 6444 data-&gt;tag-&gt;flags | = BLOCK_DYNAMIC; 6445 6446 for (p = data; p; p = p-&gt;prev) { 6447 for (vars = p-&gt;dyna_vars; vars; vars = vars-&gt;next) { 6448 if (FL_TEST(vars, DVAR_DONT_RECYCLE)) break; 6449 FL_SET(vars, DVAR_DONT_
RECYCLE); 6450 } 6451 } 6452 scope_dup(data-&gt;scope); 6453 proc_save_safe_level(proc); 6454 6455 return proc; 6456 } (eval.c)
</pre> <p>Making the <code>Proc</code> object is unexpectedly easy. (A)The area of the <code>Proc</code> object is secured between painful (B), and initialization ends, too. <code>Data_Make_Struct()</code> is a simple macro that does <code>malloc()</code> and <code>Data_Wrap_Struct()</code> at the same time. </p> <p>The problem is subsequent. </p> <ul> <li><code>frame_dup()</code></li> <li><code>blk_copy_prev()</code></li> <li><code>FL_SET(vars, DVAR_DONT_RECYCLE)</code></li> <li><code>scope_dup()</code></li> </ul> <p>These four purposes are all the same. It</p> <ul> <li>All things put on the machine stack are moved to the heap. </li> <li>Even if <code>POP</code> is done, it is not collected. </li> </ul> <p>[Dearu]. Here, "All" includes even <code>prev</code> and is all. Everything is <code>malloc()ed, the </code>stack frame piled up there is copied, and the reproduction is made. When <code>VARS</code> is usual, the compulsion collection is done with <code>rb_gc_force_recycle()</code>, and it also : simultaneously with <code>POP</code> It is stopped putting up the <code>DVAR_DONT_RECYCLE</code> flag. [Nadona], [doda]. It indeed gave it up. </p> <p>Why should I do such a terrific thing?<code>Proc</code> because of being able to live long more than the method of the making origin it is different from [itere-taburokku]. And, it is <code>FRAME</code> that the method ended secured for the machine stack It can be expected that it was easy what result to become if <code>local_vars</code> of <code>ITER</code> and <code>SCOPE</code> became invalid, and the memory that had become invalid was used back (example solution: Embarrassed it. )</p> <p>Still, it doesn't seem to go well though it thought cannot this of the use of same <code>FRAME</code> at least with two or more <code>Proc</code> because the pointer has been saved in the local variable like <code>old_frame</code> etc.The labor should be used to devise the allocation of everything from the beginning for instance with <code>malloc()</code> etc. if it has a hard time anyway. </p> <p>However, the author heartily thinks that he or she often moves at such a speed though it is done that it is terrible in the so much. It is what became an indeed good age. </p> <h3>Floatage frame</h3> <p>I will think, "All frames are reproduced" then in massage Rina's a little more in detail in a single phrase though it has put in order a little while ago. The points are the following two points. </p> <ul> <li>How is everything reproduced?</li> <li>Is everything why reproduced?</li> </ul> <p>Then, let's start first from the summary of the storage form of each stack frame. </p> <table> <tr><td>Frame<td><td>Storage form<td><td><code>Prev</code> pointer<td></tr> <tr><td><code>FRAME</code><td><td>Stack<td><td>It is. <td></tr> <tr><td><code>SCOPE</code><td><td>Stack<td><td>None<td></tr> <tr><td><code>local_tbl</code><td><td>Heap<td><td><td></tr> <tr><td><code>local_vars</code><td><td>Stack<td><td><td></tr> <tr><td><code>VARS</code><td><td>Heap<td><td>None<td></tr> <tr><td><code>BLOCK</code><td><td>Stack<td><td>It is. <td></tr> </table> <p> <code>CLASS CREF ITER</code> is unnecessary at this. Do not <code>rb_gc_force_recycle()</code> (It is not possible to do), and with <code>CREF</code> even if you make a mistake because <code>CLASS</code> is a general Ruby object The reason for <code>ITER</code> is that ending for already if an each occasion value is stored in <code>FRAME</code>. Four frames that exist in this table are important because of having many times to change and to refer. Three of the remainder are not so. </p> <p>And, it is a story how to reproduce everything. No "<code>Malloc()</code>. " even if it is said how of course. It is a problem how to reproduce "All". Because there is a frame without the <code>prev</code> pointer though I want you to see the table. In a word, the link cannot be traced. If so, how is everything reproduced?</p> <p>The sleight of hand is quite used for this. Let's take it as an example of <code>SCOPE</code>. First of all, because the function named <code>scope_dup()</code> was used to reproduce <code>SCOPE</code> a little while ago, let's see it. </p> <p class="caption">- Only the <code>scope_dup()</code> head :. </p> <pre class="longlist">
6187 static void 6188 scope_dup(scope) 6189 struct SCOPE *scope; 6190 { 6191 ID *tbl; 6192 VALUE *vars; 6193 6194 scope-&gt;flags | = SCOPE_DONT_RECYCLE; (eval.c)
</pre> <p>As you see, <code>SCOPE_DONT_RECYCLE</code> is put up. Then, when you see the definition of <code>POP_SCOPE()</code> as follows</p> <p class="caption">- Only the <code>POP_SCOPE()</code> head :. </p> <pre class="longlist">
869 #define POP_SCOPE() \ 870 if (ruby_scope-&gt;flags &amp; SCOPE_DONT_
RECYCLE) { \ 871 if (_old) scope_dup(_old); \ 872 } \ (eval.c)
</pre> <p>It is when the <code>SCOPE_DONT_RECYCLE</code> flag stands in present <code>SCOPE(ruby_scope)</code><code></code> when doing in pop when the previous one <code>SCOPE(_old)</code><code></code> is <code>scope_dup()ed. </code>In a word, <code>SCOPE_DONT_RECYCLE</code> adheres to this. Because flag is spread in place in which it does so and it does in pop one by one (Figure 7)</p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_iterator_flaginfect.jpg" alt="(flaginfect)"><br>Figure 7: Spread of flag</p> <p>Because <code>VARS</code> doesn't have the <code>prev</code> pointer, either the flag named <code>DVAR_DONT_RECYCLE</code> is spread by using the same technique. <p>Next, let's think about the second point and "Is everything why reproduced?". If <code>Proc</code> is made, that Everything might not have to be copied including even <code>SCOPE</code> ahead of that of any however though it is understood to be able to refer back to the local variable of <code>SCOPE</code>. </p> <p>The answer has been understood a minute ago though the author is worried about good when this answer is not understood and recent is written very on around the third when he or she says honestly. I want you to see the following program. </p> <pre class="emlist">
def get_proc Proc.new { nil } end env = get_proc { p 'ok' } eval("yield", env)
</pre> <p>When the <code>Proc</code> object is passed to the second argument of <code>eval</code>, the character string is appreciable in the environment though this is a function not to have explained yet. </p> <p>Because various environments are taken out, pushed, and evaluated from <code>Proc</code> (in a word <code>BLOCK</code>) though think understanding in a word if the reader had read here. Then, because <code>BLOCK</code> is piled up of course, the <code>BLOCK</code> is made <code>Proc</code> again. Can it like and [dai] almost of ruby_block ..shooting.. be accessed to information according to the Ruby level if eval is </code>done and it does to ……. <code></code> <code><code></code>It is a reason that it is necessary to reproduce all stacks wholly. </p> <h3>Start of <code>Proc</code></h3> <p>The following see the start of the generated <code>Proc</code> object. From Ruby Because it is possible to start with <code>Proc#call</code>, it only has to chase the substance. The substance of <code>Proc#call</code> is <code>proc_call()</code>. </p> <p class="caption">- <code>proc_call()</code></p> <pre class="longlist">
6570 static VALUE 6571 proc_call(proc, args) 6572 VALUE proc, args; /* OK */ 6573 { 6574 return proc_
invoke(proc, args, Qtrue, Qundef); 6575 } (eval.c)
</pre> <p>It transfers it to <code>proc_invoke()</code>. <code>Invoke</code> is often used in roughly the same meaning as "Start" in case of the context of the programming though writes rope [kuto] "(To the god etc.) Call for saving" etc. by the dictionary. For instance, say, "Invoking gcc". Aren't about "Start" and "Movement" good if it makes it to Japanese?</p> <p>Prototype [hato] [i] of the <code>proc_invoke()</code> ..neglecting.. ,</p> <pre class="emlist">
proc_invoke(VALUE proc, VALUE args, int pcall, VALUE self)
</pre> <p>Because it is <code>self=Qundef</code>, this two are crushed in the constant folding in <code>pcall=Qtrue</code> according to seeing a little while ago it though it becomes. </p> <p class="caption">- <code>proc_invoke</code>(abridgment version)</p> <pre class="longlist">
static VALUE proc_invoke(proc, args, /* pcall=Qtrue */, /* self=Qundef */) VALUE proc, args; VALUE self; {
struct BLOCK * volatile old_block; struct BLOCK _block; struct BLOCK *data; volatile VALUE result = Qnil; int state; volatile int orphan; volatile int safe = ruby_safe_level; volatile VALUE old_wrapper = ruby_wrapper; struct RVarmap * volatile old_dvars = ruby_dyna_vars; /* */ from (A) proc to substitute BLOCK for taking out data Data_
Get_Struct(proc, struct BLOCK, data); /*(B)blk_orphan */ orphan = blk_orphan(data); ruby_wrapper = data-&gt;wrapper; ruby_dyna_vars = data-&gt;dyna_vars; /* */ that piles up BLOCK from (C) data old_block = Ruby_block; _block = *data; ruby_block = &amp;_block; /* */ that changes to (D) ITER_CUR PUSH_ITER(ITER_CUR); ruby_frame-&gt;iter = ITER_CUR; PUSH_TAG(PROT_NONE); state = EXEC_TAG(); if (state == 0) { proc_set_safe_level(proc); /* (E) Block start */
result = rb_yield_0(args, self, 0, pcall); }
POP_TAG(); POP_ITER(); if (ruby_block-&gt;tag-&gt;dst == state) { state &amp;= TAG_MASK; /* Target specification jump */
}
ruby_block = old_block; ruby_wrapper = old_wrapper; ruby_dyna_vars = old_dvars; ruby_safe_level = safe; switch (state) { case 0: break; case TAG_BREAK: result = prot_tag-&gt;retval; break; case TAG_RETURN: if (orphan) { /* orphan procedure */ localjump_error("return from proc-closure", prot_tag-&gt;retval); }
/* fall through */ default: JUMP_TAG(state); }
return result;
}
</pre> <p>An essential point is three (C, D, and E). </p> <p>(C) From <code>Proc</code> this time though <code>BLOCK</code> was piled up from the syntax tree in <code>NODE_ITER</code> making it <code>BLOCK</code> is taken out and piled up. </p> <p>(D) Suddenly this time though it made to <code>ITER_CUR</code> in <code>rb_call0()</code> via <code>ITER_PRE</code> It rushes into <code>ITER_CUR</code>. </p> <p>(E) After getting in the method call if it is usual [itere-ta] Questions and answers are useless because <code>yield</code> happens and it goes to <code>rb_yield_0()</code> this time <code>Rb_yield_0()</code> is started, and it calls, and the block of just piling up is started. </p> <p><code>In a word..separately for..provide..work..bring together..do.</code><code></code><code></code></p> <p>I will speak the meaning of <code>blk_orphan()</code> of (B) at the end. Orphan is a function to judge "The method of making <code>Proc</code> has ended" state in the meaning "Orphan". For instance, it only has to be judged that it ends if <code>SCOPE</code> that <code>BLOCK</code> uses has been done in pop. </p> <h3>Block and <code>Proc</code></h3> <p>There was no story of the block argument though the argument and the parameter of the method were variously spoken in the preceding chapter. Let's be, and, then, do the chapter of the conclusion easily here. </p> <pre class="emlist">
def m(&amp;block) end </pre> <p>This is "Block parameter. "The method of achieving this is very easy. It is made <code>Proc</code> it is to be already sure to have piled up <code>BLOCK</code> if <code>m</code> is [itere-ta] (If in this case) and it ends if it substitutes it for the local variable named <code>block</code>. It only has to call <code>proc_new()</code> of just doing a little while ago to make the block <code>Proc</code>. It it is good or there must not be change in the situation "The method is called, and <code>BLOCK</code> is piled up" why when it might be <code>m</code> if might <code>Proc.new</code> though it might be cramped for a moment. Therefore, the block at any time if you call <code>proc_new()</code> from C level It is possible to make it to <code>Proc</code>. </p> <p>Moreover, if <code>m</code> is not [itere-ta], it only has to substitute <code>nil</code> only. <p>Next, passing the block. </p> <pre class="emlist">
m(&amp;block)
</pre> <p>Here is "Block argument. "It only has to take out <code>BLOCK</code> of <code>block</code> (<code>Proc</code> object of [ni] that has entered) as this is also easy and to pile up. It is only at previously the point that <code>BLOCK</code> is made or is not so that differs from <code>PUSH_BLOCK()</code>. </p> <p>By the way, the function to which this work is done is <code>block_pass()</code>. I want you to see around of that and to confirm it if anxious. However, …… though it might [gakkari] because it doesn't do it is this year as really saying here it. <hr> <p>The point of an opinion, an impression, and a mis-plant etc. are <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fmailto%3Aaamine%40loveruby.net&wb_lp=JAEN&wb_dis=2">[mine**] Aoki Thank you very much even for &lt; aamine@loveruby.net &gt;</a>. </p> <p> <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fdirect.ips.co.jp%2Fdirectsys%2Fgo_x_TempChoice.cfm%3Fsh_id%3DEE0040%26amp%3Bspm_id%3D1%26amp%3BGM_ID%3D1721&wb_lp=JAEN&wb_dis=2">It is possible to reserve ..direct ..'Ruby source code complete explanation'.. IMPRESS it.. and to buy it (Fly to the book introduction page. )</a> </p> <p>Copyright (c) 2002-2004 Minero Aoki, All rights reserved.</p> </body> </html>
<script src="http://rep.excite-webtl.jp/urchin.js" type="text/javascript"></script>
<script type="text/javascript">
_udn="excite-webtl.jp";
urchinTracker();
</script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-400370-52");
pageTracker._initData();
pageTracker._trackPageview();
</script>
