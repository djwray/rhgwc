<SCRIPT LANGUAGE="JavaScript">
<!--
var originalUrl="http://i.loveruby.net/ja/rhg/book/variable.html";
var originalLp ="JAEN";
var originalDis="";
if (self.parent.excite_header.display) {
self.parent.excite_header.display.wb_url.value = originalUrl;
self.parent.excite_header.display.wb_lp.value = originalLp;
}
//-->
</SCRIPT>
<SCRIPT LANGUAGE="JavaScript">
<!--
if (top.excite_header)
{
// ok
}
else
{
top.location.href = "http://www.excite-webtl.jp/world/english/web/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fvariable.html&wb_lp=JAEN&wb_dis=";
}
//-->
</SCRIPT>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP"> <head><base href=http://i.loveruby.net/ja/rhg/book/variable.html> <meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"> <meta http-equiv="Content-Language" content="ja-JP"> <link rel="stylesheet" type="text/css" href="rhg.css"> <link rev="made" href="mailto:aamine@loveruby.net"> <title>Chapter 6 variable and constant</title></head> <body> <h1>Chapter 6 variable and constant</h1> <h2>Outline of this chapter</h2> <h3>Variable of Ruby</h3> <p>Many kinds of a variable and considerable constants exist in Ruby as follows. Let's arrange it from scope large. </p> <ul> <li>Global variable</li> <li>Constant</li> <li>Class variable</li> <li>Instance variable</li> <li>Local variable</li> </ul> <p>It has already explained the instance variable by 'Object' Chapter 2. Of the remainder this chapters</p> <ul> <li>Global variable</li> <li>Class variable</li> <li>Constant</li> </ul> <p>It explains [nitsuite]. Moreover, the remaining local variable is spoken thirdly. </p> <h3>API related to variable</h3> <p>An analytical object of this chapter is <code>variable.c</code>. First of all, I will introduce API that becomes an entry point there. </p> <pre class="emlist">
VALUE rb_iv_get(VALUE obj, char *name) VALUE rb_ivar_get(VALUE obj, ID name) VALUE rb_iv_set(VALUE obj, char *name, VALUE val) VALUE rb_
ivar_set(VALUE obj, ID name, VALUE val)
</pre> <p>This is access API of the instance variable that has already been explained. [Deichiou] [no] of definition [gaaru] had it in <code>variable.c</code>. </p> <pre class="emlist">
VALUE rb_cv_get(VALUE klass, char *name) VALUE rb_cvar_get(VALUE klass, ID name) VALUE rb_cv_set(VALUE klass, char *name, VALUE val) VALUE rb_cvar_set(VALUE klass, ID name, VALUE val)
</pre> <p>Class variable access API. Because the class variable is the one belonging to the class, the class is taken in the argument. Apparently, there seems to be a pattern named <code>rb_Xv</code> and <code>rb_Xvar</code> in variable access API. The difference is a type of the variable identifier, and the function name is short, and the function name is long long <code>(char*)</code> ..it is easy to use it.. long the user. one <code>(ID)</code> for in comparatively</p> <pre class="emlist">
VALUE rb_const_get(VALUE klass, ID name) VALUE rb_const_get_at(VALUE klass, ID name) VALUE rb_const_set(VALUE klass, ID name, VALUE val)
</pre> <p>Constant access API. Because the constant also belongs to the class, the class is taken in the argument. A super-class also traces <code>rb_const_get()</code>, and <code>rb_const_get_at()</code> is not traced. In a word, only <code>klass</code> of the argument is examined. </p> <pre class="emlist">
struct global_entry *rb_global_entry(ID name) VALUE rb_gv_get(char *
name) VALUE rb_gvar_get(struct global_entry *ent) VALUE rb_gv_set
(char *name, VALUE val) VALUE rb_gvar_set(struct global_entry *ent, VALUE val)
</pre> <p>And, it is global variable access API in the end. It is different for a moment from other variables the use of <code>struct global_entry</code>. The reason that becomes it so is spoken in mounting. </p> <h3>Point of this chapter</h3> <p>It is "Where how is the variable memorized?" becoming the maximum point to tell the story of the variableIt is ,in a word, a data structure. </p> <p>It is secondarily behavior of the reference. Variable..constant..all..succeed to..see..worth..peculiarity..strong..such..so..become..mount..amusing..specification..compared with..match..think..hesitate..end.</p> <h2>Class variable</h2> <p>The class variable is a variable that belongs to the class. It is possible to access it from both the class and the instance. It is a static variable said with Java and C++. However, "Class" of "Instance" saying is information that exists in the evaluation machine and doesn't have as such now. Therefore, it is the same as there is no access range from C level. It narrows the focus only to the storage form of the variable here and I will see. </p> <h3>Reference</h3> <p>API that refers to the class variable is <code>rb_cvar_get()</code>. And, the shortened version again Shorting there is <code>rb_cv_get()</code>, too and the function name long <code>ID</code> takes <code>char *</code> in the argument. Let's see <code>rb_cvar_get()</code> because it is thought that it is near the inside or more to take <code>ID</code>. </p> <p class="caption">- <code>rb_cvar_get()</code></p> <pre class="longlist">
1508 VALUE 1509 rb_cvar_get(klass, id) 1510 VALUE klass; 1511 ID id; 1512 { 1513 VALUE value; 1514 VALUE tmp; 1515 1516 tmp = klass; 1517 while (tmp) { 1518 if (RCLASS(tmp)-&gt;iv_tbl) { 1519 if (st_lookup(RCLASS(tmp)-&gt;iv_
tbl,id,&amp;value)) { 1520 if (RTEST(ruby_verbose)) { 1521 cvar_override_
check(id, tmp); 1522 } 1523 return value; 1524 } 1525 } 1526 tmp = RCLASS(tmp)-&gt;super; 1527 } 1528 1529 rb_name_error(id,"uninitialized class variable %s in %s", 1530 rb_id2name(id), rb_class2name(klass)); 1531 return Qnil; /* not reached */ 1532 } (variable.c)
</pre> <p>Refer to class variable <code>id</code> of <code>klass</code> for this function. </p> <p>The function that does <code>rb_raise()</code> ,in a word, error processing has already written that you may basically disregard it. Similarly, because it is a function where <code>rb_name_error()</code> that has come out this time generates the exception, too, it is possible to disregard it. You may think that it basically generates all exceptions by the function that ends by <code>_ error</code> in <code>ruby</code>. </p> <p>Sequentially tracing a super-class of <code>klass</code> when it cuts down as such all It is understood only that do not retrieve <code>iv_tbl</code>. I want you to think, "What?" in the place in which it is said ……<code>Iv_tbl</code> must be a table of the instance variable. Then, the class variable is actually memorized in the table of the instance variable. </p> <p>This can be done because even the prefix of the variable is included in an equivalent judgment when <code>ID</code> is made. The reason for <code>"@var"</code> and <code>"@@var"</code> is that it becomes another <code>ID</code> then of <code>rb_intern()</code>. ,in a word,Moreover, the class variable named <code>@var</code> should be not able to be referred to very because the kind of the variable is decided only by the prefix at the Ruby level. It goes well even if these kind of things are done. </p> <h2>Constant</h2> <p>I want the member of <code>struct RClass</code> to recall it here though it is abrupt. It is : by being in <code>struct RClass</code> except <code>basic</code>. </p> <ul> <li><code>VALUE super</code></li> <li><code>struct st_table *iv_tbl</code></li> <li><code>struct st_table *m_tbl</code></li> </ul> <p>[No], it is three. Then, to the idea</p> <ol> <li>The constant belongs to the class. </li> <li>It doesn't seem that the table only for the constant is in <code>struct RClass</code>. </li> <li>The class variable ..<code>iv_tbl</code>.. cohabited. </li> </ol> <p>Then, the constant …… also :. </p> <h3>Substitution</h3> <p> <code>Rb_const_set()</code> is a function to substitute the value for the constant. <code>Val</code> is set in constant <code>id</code> of class <code>klass</code>. </p> <p class="caption">- <code>rb_const_set()</code></p> <pre class="longlist">
1377 void 1378 rb_const_set(klass, id, val) 1379 VALUE klass; 1380 ID id; 1381 VALUE val; 1382 { 1383 mod_av_set(klass, id, val, Qtrue); 1384 } (variable.c)
</pre> <p>It is almost transferred to <code>mod_av_set()</code>. </p> <p class="caption">- <code>mod_av_set()</code></p> <pre class="longlist">
1352 static void 1353 mod_av_set(klass, id, val, isconst) 1354 VALUE klass; 1355 ID id; 1356 VALUE val; 1357 int isconst; 1358 { 1359 char *dest = isconst ? "constant" : "class variable"; 1360 1361 if (!OBJ_TAINTED(klass) &amp;&amp; rb_safe_level() &gt;= 4) 1362 rb_raise(rb_
eSecurityError, "Insecure: can't set %s", dest); 1363 if (OBJ_FROZEN(klass)) rb_
error_frozen("class/module"); 1364 if (!RCLASS(klass)-&gt;iv_tbl) { 1365 RCLASS
(klass)-&gt;iv_tbl = st_init_numtable(); 1366 } 1367 else if (isconst) { 1368 if (st_
lookup(RCLASS(klass)-&gt;iv_tbl, id, 0) || 1369 (klass == rb_cObject &amp;&amp; st_
lookup(rb_class_tbl, id, 0))) { 1370 rb_warn("already initialized %s %s", dest, rb_id2
name(id)); 1371 } 1372 } 1373 1374 st_insert(RCLASS(klass)-&gt;iv_tbl, id, val); 1375 } (variable.c)
</pre> <p>The exception check and warning are disregarded this time. Concretely with <code>rb_raise()</code> <code>Rb_error_frozen()</code> and <code>rb_warn()</code> are disregarded. Then, the remainder is only this. </p> <p class="caption">- <code>mod_av_set()</code>(Only an important part :. )</p> <pre class="longlist">
if (!RCLASS(klass)-&gt;iv_tbl) { RCLASS(klass)-&gt;iv_tbl = st_init_numtable(); }
st_insert(RCLASS(klass)-&gt;iv_tbl, id, val);
</pre> <p>Clearly from here, the constant ..instance variable table.. cohabits still. In a word <code>struct RClass</code> To <code>iv_tbl</code></p> <ol> <li>Instance variable of class</li> <li>Class variable</li> <li>Constant</li> </ol> <p>[San] kind comes to drink and to become mixed and to be memorized. </p> <h3>Reference</h3> <p>The storage form of the constant has been understood above. The head will be switched this time and the constant specification be paid to attention. </p> <h4><code>rb_const_get()</code></h4> <p>Function <code>rb_const_get()</code> that refers to the constant is read. Refer to constant <code>id</code> of class <code>klass</code> for this function. </p> <p class="caption">- <code>rb_const_get()</code></p> <pre class="longlist">
1156 VALUE 1157 rb_const_get(klass, id) 1158 VALUE klass; 1159 ID id; 1160 { 1161 VALUE value, tmp; 1162 int mod_retry = 0; 1163 1164 tmp = klass; 1165 retry: 1166 while (tmp) { 1167 if (RCLASS(tmp)-&gt;iv_tbl &amp;&amp; st_lookup(RCLASS(tmp)-&gt;iv_tbl,id,&amp;value)) { 1168 return value; 1169 } 1170 if (tmp == rb_cObject &amp;&amp; top_const_get(id, &amp;value)) return value; 1171 tmp = RCLASS(tmp)-&gt;super; 1172 } 1173 if (!mod_retry &amp;&amp; BUILTIN_TYPE(klass) == T_MODULE) { 1174 mod_retry = 1; 1175 tmp = rb_cObject; 1176 goto retry; 1177 } 1178 1179 /* Uninitialized constant */ 1180 if (klass &amp;&amp; klass != rb_
cObject) { 1181 rb_name_error(id, "uninitialized constant %s at %s", 1182 rb_
id2name(id), 1183 RSTRING(rb_class_path(klass))-&gt;ptr); 1184 } 1185 else { /
* global_uninitialized */ 1186 rb_name_error(id, "uninitialized constant %s",
rb_id2name(id)); 1187 } 1188 return Qnil; /* not reached */ 118
9 } (variable.c)
</pre> <p>It is obstructive for various reasons. <code>Rb_name_error()</code> in the latter half can be collectively at least first erased. It seems to have treated the module specially very much around of <code>mod_retry</code> at the center. Let's erase this for the time being. Then, it decreases it here. </p> <p class="caption">- <code>rb_const_get</code>(abridgment version)</p> <pre class="longlist">
VALUE rb_const_get(klass, id) VALUE klass; ID id; {
VALUE value, tmp; tmp = klass; while (tmp) { if (RCLASS(tmp)-&gt;iv_tbl &amp;&amp; st_lookup(RCLASS(tmp)-&gt;iv_tbl,id,&amp;value)) { return value; }
if (tmp == rb_cObject &amp;&amp; top_const_get(id, &amp;value)) return value; tmp = RCLASS(tmp)-&gt;super;
}
}
</pre> <p>If it is this, it understands at one view. While tracing a super-class of <code>klass</code> of the argument <code>Iv_tbl</code> is retrieved. In a word</p> <pre class="emlist">
class A Const = "ok" end class B &lt; A P(Const) # can be referred to. end </pre> <p>..saying.. It is a situation. </p> <p>It is <code>top_const_get()</code> only anxious. <code>Top</code> might be a meaning of "Top-level" because it has limited it with <code>rb_cObject</code>. The class at a top level is <code>Object</code> when confirming it to make sure. It is the same meaning as "The class becomes <code>C</code> in the class sentence that defines <code>C</code>", and "The class of top-level : <code>Object</code>. "</p> <pre class="emlist">
# The class of top-level is Object. class A # The class is A. class B # The class is B. end end </pre> <p>It can be expected that <code>top_const_get()</code> seems to do a special operation in a word by a top-level limitation. </p> <h4><code>top_const_get()</code></h4> <p>Let's see the <code>top_const_get()</code>. Constant <code>id</code> is retrieved, it writes in <code>klassp</code>, and it returns it. </p> <p class="caption">- <code>top_const_get()</code></p> <pre class="longlist">
1102 static int 1103 top_const_get(id, klassp) 1104 ID id; 1105 VALUE *klassp; 1106 { 1107 /* pre-defined class */ 1108 if (st_lookup(rb_class_tbl, id, klassp)) return Qtrue; 1109 1110 /* autoload */ 1111 if (autoload_tbl &amp;&amp; st_lookup(autoload_tbl, id, 0)) { 1112 rb_autoload_load(id); 1113 *klassp = rb_const_get(rb_cObject, id); 1114 return Qtrue; 1115 } 1116 return Qfalse; 1117 } (variable.c)
</pre> <p> <code>Rb_class_tbl</code> has come out by 'Class and module' Chapter 4. It is a table that memorizes the class of top-level. For instance, <code>String</code> and <code>Array</code> etc. of the built-in class are registered here. Therefore, when the constant of top-level is retrieved, this table is not looked for and it is insufficient. </p> <p>After that, it is a function it is as follows related to the auto load. The constant of top-level can register the library automatically loaded when it is referred for the first time. For instance, it uses it in this way. </p> <pre class="emlist">
Autoload(:VeryBigClass, "verybigclass") VeryBigClass is defined during #. </pre> <p>When <code>VeryBigClass</code> is referred for the first time, the library when writing so If <code>require</code> is done, and <code>VeryBigClass</code> is defined in that, <code>verybigclass</code> is what and either can execute continuation. It is effective when using it when the library is too large and it takes time for loading. </p> <p>It is <code>rb_autoload_xxxx()</code> to process this auto load. The auto load is not spoken in this book any further. It is because there seems very to be nature of the specification very in one of these days. </p> <h4>Class on the outside?</h4> <p>By the way, the code in which the constant of the class on the outside is retrieved might gone to where. The constant is sure to retrieve the direction of the outside first of all, and, next, to retrieve the direction of a super-class. </p> <p>Actually, it is a part where it cannot explain it yet. The class on the outside changes by the place of the program. In a word, it depends on the context of the program. Therefore, it is not possible to treat if an internal state of the evaluation machine is not thought by matching it. To be specific, it is <code>ev_const_get()</code> of <code>eval.c</code> that even the class on the outside has treated. Keri will be applied to the story of the constant thirdly. </p> <h2>Global variable</h2> <h3>Introduction</h3> <p>The global variable can be accessed from anywhere. It is not to have to limit all the accesses when saying oppositely. What you may be settled with it, and not check if there is one table because it doesn't belong to where either. Therefore, mounting is very easy. </p> <p>The reason for a free variable is still that it is installed for a difficult to say gimmick in the global variable of Ruby in there are a little a lot of codes. It is only a global variable that provides such a function. </p> <ul> <li>The hook of the access can be done. </li> <li>The alias can be defined by the <code>alias</code> sentence. </li> </ul> <p>Let's explain easily. </p> <h4>Variable alias</h4> <pre class="emlist">
alias $newname $oldname </pre> <p>It comes to be able to use <code>$newname</code> thereafter by this instead of <code>$oldname</code>. <p><code>Alias</code> of the variable is chiefly prepared for "Sign variable" measures. The sign variable is a variable named <code>$=</code> or <code>$0</code> succeeded to from Perl. <code>$=</code> decides whether to do the case sensitivity at the character-string comparison. <code>$0</code> shows the Ruby program name of the main. Besides this, there are some a sign variables, and remembering for the person who doesn't know Perl etc. because the name part is anyway one character is serious. Then, a comprehensible a little more alias is applied. </p> <p>The sign variable is not recommended to begin with now, and it is moved to a peculiar method of a suitable one after another module etc. though it says. It is atmosphere to which the function seems to be abolished in <code>$=</code> etc.2.0. </p> <h4>Hook</h4> <p>The hook of substitution and the reference to the variable can be done in the global variable. </p> <p>Either must though the hook is put from the Ichi ..floatage Ruby.. level To prepare the special variable for the system like <code>$KCODE</code> at C level, I think that I wanted to use it. <code>$KCODE</code> can strictly substitute only a specific character string <code>"EUC"</code> or <code>"UTF8"</code> in the variable in which the character string encoding that the interpreter treats at that time is put. However, it is possible to substitute it even by <code>"e"</code> or <code>"u"</code> in it because it is troublesome. </p> <pre class="emlist">
#"EUC" and "u" $KCODE = "NONE" (default) and "e" $KCODE = P($KCODE) # p($KCODE) p($KCODE) #"UTF8"
</pre> <p>I think that it is understood to be able to do this easily if the hook is put on substitution. By the way, K of <code>$KCODE</code> seems to be K of the Chinese character. </p> <p>Oh dear as for <code>alias</code>, it is a trivial function because it doesn't use the global variable of the hook for [roku] to begin with. The function not to use wants to end suitably, and to use the page to analyze the parser and the evaluation machine. I want to progress the following explanations because of this by 85% at the time of each throw giving. </p> <h3>Data structure</h3> <p>It was said that the point when the mechanism of the variable was seen was a storage form. I want you to understand the structure used for the global variable firmly first of all. </p> <p class="caption">- Data structure of global variable</p> <pre class="longlist">
21 static st_table *rb_global_tbl; 334 struct global_entry { 335 struct global_variable *var; 336 ID id; 337 }; Reference..counter..variable..value..variable..reference..use..
function..variable..substitution..use..function..variable..mark..
function.
331 struct trace_var *trace; 332 }; (variable.c)
</pre> <p> <code>Rb_global_tbl</code> is the main table. All global variables are memorized in this table with no distinction. Variable identifier to say nothing of key to table <code>(ID)</code>. And, <code>struct global_entry</code> and <code>struct global_variable</code> express one global variable in the value by the set (Figure 1). </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_variable_gvar.jpg" alt="(gvar)"><br>Figure 1: Image when global variable table is executed</p> <p>The purpose of the structure's that expresses the variable having divided into two is to mount of <code>alias</code>. If <code>alias</code> is set, it is the same from two <code>global_entry</code> <code>Struct global_variable</code> is indicated. </p> <p>Moreover, member <code>counter</code> of <code>struct global_variable</code> is a reference counter needed at that time. It has already explained the concept of the reference count by the preceding chapter 'Garbage collection'. It is +1 to trying the reference in the future when easily reviewing as for the counter It does. It is -1 when becoming already unnecessary as for the counter It does. Because no one has needed it any longer when the count vanishes, you may <code>free()</code> it. </p> <p>After that, further when the hook is defined at the Ruby level at the end This is not spoken though the list of <code>sturct trace_var</code> is stored by member <code>trace</code> of <code>struct global_variable</code>. Each <code>struct trace_var</code> is omitted. </p> <h3>Reference</h3> <p>If only the reference is seen, the global variable is roughly understood. The function for the reference is <code>rb_gv_get()</code> and <code>rb_gvar_get()</code>. </p> <p class="caption">- <code>rb_gv_get() rb_gvar_get()</code></p> <pre class="longlist">
716 VALUE 717 rb_gv_get(name) 718 const char *name; 719 { 720 struct global_entry *entry; 721 722 entry = rb_global_entry(global_id(name)); 723 return rb_gvar_get(entry); 724 } 649 VALUE 650 rb_gvar_get(entry) 651 struct global_entry *entry; 652 { 653 struct global_variable *var = entry-&gt;var; 654 return (*var-&gt;getter)(entry-&gt;id, var-&gt;data, var); 655 } (variable.c)
</pre> <p>It is understood somehow tub loincloth [sareteiruga] and to try to do a substantial content to <code>rb_global_entry()</code>. <code>Global_id()</code> might convert <code>char *</code> into <code>ID</code>, and is incidentally <code>ID</code> of the global variable it or be a checked function. <code>(*var-&gt;getter)(...)</code>It is a function call that uses [hamochiron] function pointer <code>var-&gt; getter</code>. When <code>p</code> was made a function pointer, the function was able to be called by <code>(*p) (arg)</code>. </p> <p>The main plot is <code>rb_global_entry()</code>. </p> <p class="caption">- <code>rb_global_entry()</code></p> <pre class="longlist">
351 struct global_entry* 352 rb_global_entry(id) 353 ID id; 354 { 355 struct global_entry *entry; 356 357 if (!st_lookup(rb_global_tbl, id, &amp;entry)) { 358 struct global_variable *var; 359 entry = ALLOC(struct global_entry); 360 st_add_direct(rb_global_tbl, id, entry); 361 var = ALLOC(struct global_variable); 362 entry-&gt;id = id; 363 entry-&gt;var = var; 364 var-&gt;counter = 1; 365 var-&gt;data = 0; 366 var-&gt;getter = undef_getter; 367 var-&gt;setter = undef_setter; 368 var-&gt;marker = undef_marker; 369 370 var-&gt;block_trace = 0; 371 var-&gt;trace = 0; 372 } 373 return entry; 374 } (variable.c)
</pre> <p>(And, register) This processing is only opening <code>st_lookup()</code>, and the following code makes a new entry It is. There is <code>rb_global_entry()</code>'s not returning <code>NULL</code> because the entry is automatically made when referring in a word for the first time. </p> <p>The purpose of such a mechanism is to speed up chiefly. When <code>struct global_entry</code> is acquired, and the variable is referred correspondence (<code>Rb_gv_get()</code> is used), Perth is made only to take the value from the entry when the global variable is found. </p> <p>Well, the continuation of the code a little more. The function pointer named <code>undef_xxxx</code> is set in <code>var-&gt; getter</code> etc.<code>Undef</code> ,in a word, the global variable might still be a meaning named <code>setter/getter/marker</code> in the undefined state that is (undefined). </p> <p>Only warning is put out in <code>undef_getter()</code> and <code>nil</code> is returned. The reason for the global variable is that it is possible to refer without defining it. Because <code>undef_setter()</code> is interesting for a moment, let's see. </p> <p class="caption">- <code>undef_setter()</code></p> <pre class="longlist">
385 static void 386 undef_setter(val, id, data, var) 387 VALUE val; 388 ID id; 389 void *data; 390 struct global_variable *var; 391 { 392 var-&gt;getter = val_getter; 393 var-&gt;setter = val_setter; 394 var-&gt;marker = val_marker; 395 396 var-&gt;data = (void*)val; 397 } (variable.c)
</pre> <p>Only in hurrying back of <code>val_getter()</code> of the value from <code>entry-&gt; data</code>, <code>val_setter()</code> is a function only of putting the value in <code>entry-&gt; data</code>. The treatment of special of undefined specially is treatable like this (Figure 2) by the registration of the handler. It is a good way. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_variable_gaccess.jpg" alt="(gaccess)"><br>Figure 2: Substitution and reference to global variable</p> <hr> <p>The point of an opinion, an impression, and a mis-plant etc. are <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fmailto%3Aaamine%40loveruby.net&wb_lp=JAEN&wb_dis=2">[mine**] Aoki Thank you very much even for &lt; aamine@loveruby.net &gt;</a>. </p> <p> <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fdirect.ips.co.jp%2Fdirectsys%2Fgo_x_TempChoice.cfm%3Fsh_id%3DEE0040%26amp%3Bspm_id%3D1%26amp%3BGM_ID%3D1721&wb_lp=JAEN&wb_dis=2">It is possible to reserve ..direct ..'Ruby source code complete explanation'.. IMPRESS it.. and to buy it (Fly to the book introduction page. )</a> </p> <p>Copyright (c) 2002-2004 Minero Aoki, All rights reserved.</p> </body> </html>
<script src="http://rep.excite-webtl.jp/urchin.js" type="text/javascript"></script>
<script type="text/javascript">
_udn="excite-webtl.jp";
urchinTracker();
</script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-400370-52");
pageTracker._initData();
pageTracker._trackPageview();
</script>
