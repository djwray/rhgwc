<SCRIPT LANGUAGE="JavaScript">
<!--
var originalUrl="http://i.loveruby.net/ja/rhg/book/thread.html";
var originalLp ="JAEN";
var originalDis="";
if (self.parent.excite_header.display) {
self.parent.excite_header.display.wb_url.value = originalUrl;
self.parent.excite_header.display.wb_lp.value = originalLp;
}
//-->
</SCRIPT>
<SCRIPT LANGUAGE="JavaScript">
<!--
if (top.excite_header)
{
// ok
}
else
{
top.location.href = "http://www.excite-webtl.jp/world/english/web/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fthread.html&wb_lp=JAEN&wb_dis=";
}
//-->
</SCRIPT>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP"> <head><base href=http://i.loveruby.net/ja/rhg/book/thread.html> <meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"> <meta http-equiv="Content-Language" content="ja-JP"> <link rel="stylesheet" type="text/css" href="rhg.css"> <link rev="made" href="mailto:aamine@loveruby.net"> <title>Chapter 19 Thread</title></head> <body> <h1>Chapter 19 Thread</h1> <h2>Outline</h2> <h3>Ruby interface</h3> <p>Incidently, I think that it doesn't show the code that actually uses the thread with Ruby still neatly. I will introduce [ichiou] though it is not the wonderful one. </p> <pre class="emlist">
Thread.fork { while true puts 'forked thread' end }
while true puts 'main thread' end </pre> <p>If this program is executed, [natte] is neatly output to [guchamaze] ..<code>"Forked thread"</code> and <code>"Main thread"</code>... </p> <p>There is variously control method also in things except making two or more threads of course nothing but. It is prepared, and following API can be used to say nothing of commonsense primitiveness named <code>Mutex</code>, <code>Queue</code>, and <code>Monitor</code> to operate the thread though there is no <code>synchronize</code> reserved word like Java. </p> <p class="caption">- Thread API</p> <table> <tr><td><code>Thread.pass</code><td><td>Someone moves execution to other threads. <td></tr> <tr><td><code>Thread.kill(th)</code><td><td>Thread <code>th</code> is ended. <td></tr> <tr><td><code>Thread.exit</code><td><td>The thread is ended. <td></tr> <tr><td><code>Thread.stop</code><td><td>The thread is stopped temporarily. <td></tr> <tr><td><code>Thread#join</code><td><td>It is waited that the thread ends. <td></tr> <tr><td><code>Thread#wakeup</code><td><td>The thread that stops temporarily is caused. <td></tr> </table> <h3><code>Ruby</code> thread</h3> <p>Because thread actually moves sequentially at a little time though "Everyone moves all together" is a polite fiction. It is necessary to move sequentially still still if there are threads of several or more of CPU if it devises it as such with the machine of multi-CPU to be exact though it is possible to move at the same time by two. </p> <p>There are roughly separately two kinds of the techniques because someone should switch the thread somewhere to produce the thread in a word. It is a kernel level thread and a user level thread. This is a difference of making the thread from the kernel like the character reading both or making it from the user level. If it is a kernel level, two or more threads can be moved at the same time by making the best use of multi CPU. </p> <p>Then, if it says whether very the thread of <code>ruby</code>, this is a user level thread. And (Therefore,), the thread that can move at the same time is strictly limited only with one. </p> <h3>Is it preemptive?</h3> <p>Let's speak the feature of the <code>ruby</code> thread a little more in detail. There is a point "Whether it is ..preemptive.. (preemptive) or not?" when doing as another aspect concerning the thread. </p> <p>Thread..mechanism..preemptive..say..the..thread..use..thread..switch..specification..do..without permission..thread..switch.It becomes impossible to control the timing of the thread switch if this is seen oppositely. </p> <p>On the other hand, the thread doesn't change in a thread mechanism not preemptive as long as using the thread doesn't say, "You may pass the control right to the following thread" specifying it. Moreover, it is in the clear understanding of can a changeable place when the thread that is if it sees oppositely. </p> <p>It is also in ..this distinction.. process, and is "It is great. " ..: of preemptive in that case... For instance, the process doesn't change when there is a bug in a certain program and it falls into an infinite loop. It is not suitably in a word because one user program can stop the entire system. Because it is [demotte], and ..Windows 3.1.. basis was MS-DOS, Windows 95 is preemptive though the process switch was not preemptive. Therefore, the system is solider. Therefore, Windows 95 becomes a story "It is great" from 3.1. </p> <p>Then, when it says whether very the thread of <code>ruby</code>, it is preemptive, and C level is not preemptive at the Ruby level. When the code of C is written in a word, timing into which the thread changes can be specified almost surely. </p> <p>Why do it become it so?A moderate attitude is needed also for use though the thread is certainly convenient. That is, the code should correspond to the thread (The MultiThreading should be safe). All libraries of C used should be ,in a word, the MultiThreading correspondences at C level if keeping preemptive. </p> <p>However, there are actually still a lot of thread one of the library of C not safe. When the number of libraries that can be used by indispensably doing the thread correspondence though it has a hard time with great pains and the enhancing library was made easy to write is decreased, it is not significant. Therefore, it is not preemptive, and, because, a rational choice at C level for <code>ruby</code>. </p> <h3>System of management</h3> <p>If C level is not preemptive, the <code>ruby</code> thread has been understood. It is voluntarily [shuhana] when moving in a word to some degree as for execution rightThen, I want you to think that the thread exactly executing it now starts stopping executing. To whom should the following pass the execution right?It is and, to begin with, it is useless to the thread ahead of that not to know how to be expressed internally of <code>ruby</code>. I will see the variable and the data type to manage the thread. </p> <p class="caption">- Structure to manage thread</p> <pre class="longlist">
864 typedef struct thread * rb_thread_t; 865 static rb_thread_t curr_thread = 0; 866 static rb_thread_t main_thread; 7301 struct thread { 7302 struct thread *next, *prev; (eval.c)
</pre> <p> <code>Struct thread</code> was squeezed from a certain reason only to an important part now because it was very large. It is thought that <code>rb_thread_t</code> is connected from <code>rb_thread_t</code> the name of the member and the type named this <code>next</code> and <code>prev</code> by the interactive link list though there are only two because of this. Moreover, not an actually free, interactive list but both ends are connected. It is ,in a word, a toroidal. Here is a big point. When <code>main_thread</code> and <code>curr_thread</code> of the static variable are added, the entire data structure is shown in figure picture 1. </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_thread_thread.jpg" alt="(thread)"><br>Figure 1: Data structure that manages thread</p> <p> <code>Main_thread</code> (main thread) is a thread that exists when the program starts ,in a word," thread. Naturally, <code>curr_thread</code> : It is a thread that is moving at <code>current thread</code> ,in a word, present. The value of <code>curr_thread</code> changes fast though the value of <code>main_thread</code> doesn't change while the process is operating. </p> <p>When the list forms a ring thus, it becomes easy to work to choose "The following thread". It only has to haul in the <code>next</code> link only. A thread all the levels only that it can be moved equally. </p> <h3>..the switch of the thread..</h3> <p>By the way, what is the thread to begin with?Or, can you say that the thread changes if it does very?</p> <p>This is a fiendishly difficult problem. When it is like looking like something ..something ..the program.... with the object, and the one understood from "Feeling" in the usual suitability is asked, it is not answered that it is refreshing. Especially, the thread and the process are embarrassed when it is asked very much how where is different. </p> <p>Still, it is possible to say to some degree if it says within the realistic range. The one necessary for the thread is a context of execution. It was <code>ruby_frame</code>, <code>ruby_scope</code>, and <code>ruby_class</code>, etc. as having seen by us if it was said the context in <code>ruby</code>. Moreover, the substance of <code>ruby_frame</code> is secured after the stack of the machine, and the machine stack is also necessary for <code>ruby</code> because there might be a stack area that the enhancing library uses as the context of the Ruby program. The register of CPU is also indispensable at it and the end. It is element of which these various contexts compose thread, and it is switch of thread to switch this againOr, it is said context switch (context switch). </p> <h3>Method of context switch</h3> <p>It becomes a story how to switch the context. <code>Ruby_scope</code> It is easy to change <code>ruby_class</code>. The area is secured for the heap and it only has to save it honestly. The register of CPU manages to become it, too. It is because it writes and it is possible to return it of preservation when <code>setjmp()</code> is used. Both of the area for that are prepared in <code>rb_thread_t</code>. </p> <p class="caption">- <code>struct thread</code>(part)</p> <pre class="longlist">
7301 struct thread { 7302 struct thread *next, *prev; 7303 jmp_buf context; 7315 struct FRAME *frame; /* ruby_frame */ 7316 struct SCOPE *
scope; /* ruby_scope */ 7317 struct RVarmap *dyna_vars; /* ruby_dyna_vars */ 7318 struct BLOCK *block; /* ruby_block */ 73
19 struct iter *iter; /* ruby_iter */ 7320 struct tag *tag; /* prot_tag */ 7321 VALUE klass; /* ruby_
class */ 7322 VALUE wrapper; /* ruby_wrapper */ 7323 NODE *cref; /* ruby_cref */ 7324 7325 int flags; /* scope_vmode / rb_trap_immediate / raised */ 7326 7327 NODE *node; /* rb_current_node */ 7328 7329 int tracing; /* tracing */ 7330 VALUE errinfo; /* $! */ 7331 VALUE last_status; /* $? */ 7332 VALUE last_line; /* $_ */ 7333 VALUE last_match; /* $~ */ 7334 7335 int safe; /* ruby_safe_level */ (eval.c)
</pre> <p>There is a member who seems to correspond to <code>ruby_frame</code> and <code>ruby_scope</code> like this. There is <code>jmp_buf</code> to preserve the register, too. </p> <p>Well, the problem is a machine stack. It might be good if it does very to substitute this secretly. </p> <p>Be to rewrite the pointer that specifies the position of the stack (point) directly that it is the most obedient compared with the mechanism. It is usually in the register of CPU. Anyway, it is somewhere though it is when one general register is secured for that if there is a reserved register. I will call this pointer a stack pointer because I am troublesome as follows. It is natural to stack another area if this is changed. However, it is very serious that this method naturally secures portability because it should deal with CPU and each OS. </p> <p>Then, substituting the machine stack is mounted in <code>ruby</code> by a considerable violence means. It is said that the stack pointer is useless, and the destination of the indication of the stack pointer is changed. It is only changed to do a little because the stack has already been seen to be able to be fiddled directly in the garbage collector. The place where the stack is preserved is neatly in <code>struct thread</code>, too. </p> <p class="caption">- <code>struct thread</code>(part)</p> <pre class="longlist">
7310 int stk_len; /* length */ of stack 7311 Int stk_max; /* size */ of memory allocated in stk_ptr 7312 VALUE*stk_ptr; /* copy */ of stack 7313 VALUE*stk_pos; /* Position of stack */
(eval.c) </pre> <h3>Those who advance it about explanation</h3> <p>The point is brought together in three points though it spoke variously above. </p> <ul> <li>When</li> <li>To which thread</li> <li>Very</li> </ul> <p>The context is switched or [dearu]. It becomes the point of this chapter as it is. It speaks by using a passage from each this three points in the following. </p> <h2>Trigger</h2> <p>The thread is when it changes the first point first of all. In other words, the cause into which the thread changes variously follows it. </p> <h3>I/O waiting</h3> <p>For instance, you are sure move other threads meanwhile because it seems that it takes a considerable time to read when it tries to call <code>IO#gets</code> and <code>IO#read</code> and to read something. In a word, the compulsion switch is needed here. It is C interface of <code>getc</code> as follows. </p> <p class="caption">- <code>rb_getc()</code></p> <pre class="longlist">
1185 int 1186 rb_getc(f) 1187 FILE *f; 1188 { 1189 int c; 1190 1191 if (!READ_DATA_PENDING(f)) { 1192 rb_thread_wait_fd(fileno(f)); 1193 } 1194 TRAP_BEG; 1195 c = getc(f); 1196 TRAP_END; 1197 1198 return c; 1199 } (io.c)
</pre> <p> <code>READ_DATA_PENDING(f)</code> is a macro that checks whether there are still contents of the buffer of the file. Because it is possible to move at waiting time 0 when there are contents of the buffer, it reads at once. Because it takes time when it is empty, <code>rb_thread_wait_fd()</code> is called. This is an indirect factor of the thread switch. </p> <p>It is unpalatable if there is not "Immediately" factor if it is said, <code>rb_thread_wait_fd()</code> is "Indirectly" either. What is it?Let's see in <code>rb_thread_wait_fd()</code>. </p> <p class="caption">- <code>rb_thread_wait_fd()</code></p> <pre class="longlist">
8047 void 8048 rb_thread_wait_fd(fd) 8049 int fd; 8050 { 8051 if (rb_thread_critical) return; 8052 if (curr_thread == curr_thread-&gt;next) return; 8053 if (curr_thread-&gt;status == THREAD_TO_KILL) return; 8054 8055 curr_thread-&gt;status = THREAD_STOPPED; 8056 curr_thread-&gt;fd = fd; 8057 curr_thread-&gt;wait_for = WAIT_FD; 8058 rb_thread_schedule(); 8059 } (eval.c)
</pre> <p>There is <code>rb_thread_schedule()</code> in the last line. This function is "Immediate cause. "It is a function that becomes the nucleus of mounting the thread of <code>ruby</code>, and the selection of the following thread and the switch are done. </p> <p>It is because it knows the thread is scheduled the word (scheduling) beforehand when why this function is such a role is understood is said for the author. It is possible to notice as follows because it remembered now even if it doesn't know. </p> <p>And, the control not only is moved to other threads in this case but also I stop. Moreover, it is addition "Reading ends" a clear time limit. Therefore, it is necessary to tell <code>rb_thread_schedule()</code> the demand. It is around of its a variety of substitutions for the member of <code>curr_thread</code>. The reason for the stop is put in <code>wait_for</code> and information used when causing it is put in <code>fd</code> respectively. </p> <h3>Another thread waiting</h3> <p><code>Rb_thread_schedule()</code> can find the point where the thread changes oppositely this time because it is if it understands when the thread changes according to the timing of <code>rb_thread_schedule()</code>. Then, it was discovered that it scanned by the function named <code>rb_thread_join()</code>. </p> <p class="caption">- <code>rb_thread_join()</code>(part)</p> <pre class="longlist">
8227 static int 8228 rb_thread_join(th, limit) 8229 rb_thread_t th; 8230 double limit; 8231 { 8243 curr_thread-&gt;status = THREAD_STOPPED; 8244 curr_thread-&gt;join = th; 8245 curr_thread-&gt;wait_for = WAIT_JOIN; 8246 curr_thread-&gt;delay = timeofday() + limit; 8247 if (limit &lt; DELAY_INFTY) curr_thread-&gt;wait_for | = WAIT_TIME; 8248 rb_thread_schedule(); (eval.c)
</pre> <p>This function is substance of <code>Thread#join</code>, and <code>Thread#join</code> is a method of waiting for the thread of the receiver to end. Certainly, moving other threads is obtaining and exists if there is waiting time. The second the switch reason in this was found. </p> <h3>Waiting at time</h3> <p>In addition, <code>rb_thread_schedule()</code> was found to the function named <code>rb_thread_wait_for()</code>. This (Ruby) is substance such as <code>sleep</code>. </p> <p class="caption">- <code>rb_thread_wait_for</code>(abridgment version)</p> <pre class="longlist">
8080 void 8081 rb_thread_wait_for(time) 8082 struct timeval time; 8083 { 8084 double date; 8124 date = timeofday() + (double)time.tv_sec + (double)time.tv_usec*1e-6; 8125 curr_thread-&gt;status = THREAD_STOPPED; 8126 curr_thread-&gt;delay = date; 8127 curr_thread-&gt;wait_for = WAIT_TIME; 8128 rb_thread_schedule(); 8129 } (eval.c)
</pre> <p> <code>Timeofday()</code> returns the time as of now. <code>Date</code> indicates time when waiting time cuts because it adds the value of <code>time</code> to it. In a word, this : It is specification "I want to stop until becoming specific time". </p> <h3>Switch by timeout</h3> <p>All some operations were done from the Ruby level above, and as a result it caused the thread switch. In a word, when it is up to here, the Ruby level becomes not preemptive. On condition that..single-mindedly..calculate..program..thread..run.Then, it is necessary to throw away the execution right voluntarily when moving to some degree. Then, do stop when it moves very?Let's speak it as follows. </p> <h4><code>setitimer</code></h4> <p>It looked for calling <code>rb_thread_schedule()</code> in addition though every time every time the same, dull nature was done. Then, it is found this time in a strange point. It is here. </p> <p class="caption">- <code>catch_timer()</code></p> <pre class="longlist">
8574 static void 8575 catch_timer(sig) 8576 int sig; 8577 { 8578 #if !defined(POSIX_SIGNAL) &amp;&amp; !defined(BSD_SIGNAL) 8579 signal(sig, catch_timer); 8580 #endif 8581 if (!rb_thread_critical) { 8582 if (rb_trap_immediate) { 8583 rb_
thread_schedule(); 8584 } 8585 else rb_thread_pending = 1; 8586 } 8587 } (eval.c)
</pre> <p>This might be integral though seem the signal relation what. When it was chased to use this function <code>catch_timer()</code>, it was used around here. </p> <p class="caption">- <code>rb_thread_start_0()</code>(part)</p> <pre class="longlist">
8620 static VALUE 8621 rb_thread_start_0(fn, arg, th_arg) 8622 VALUE (*fn)(); 8623 void *arg; 8624 rb_thread_t th_arg; 8625 { 8632 #if defined(HAVE_SETITIMER) 8633 if (!thread_init) { 8634 #ifdef POSIX_SIGNAL 8635 posix_signal(SIGVTALRM, catch_timer); 8636 #else 863
7 signal(SIGVTALRM, catch_timer); 8638 #endif 8639 8640 thread_init = 1; 8641 rb_thread_start_timer(); 8642 } 8643 #endif (eval.c)
</pre> <p><code>Catch_timer()</code> seems to be ,in a word, a signal handler of <code>SIGVTALRM</code>. </p> <p>What kind of signal here <code>SIGVTALRM</code> is becomes a problem. This is a signal sent when the system call named <code>setitimer</code> is actually used. Because therefore, <code>HAVE_SETITIMER</code> is checked immediately before<code>Setitimer</code> is a system call told OS to send signals by abbreviating SET Interval TIMER at regular intervals. </p> <p>Then, when the <code>setitimer</code> is called, it is <code>rb_thread_start_timer()</code> that it neglects and there is [hato] [i] also in , a coincidence at the end of this list. </p> <p>When everything is brought together, it becomes the following plots. It sends signals with <code>setitimer</code> at regular intervals. It is obtained with <code>catch_timer()</code>. Then, <code>Rb_thread_schedule()</code> is called and the thread is switched. It is perfect. <p>However, only when the signal is this because it is the one generated at any time when, C level becomes. Then, I want you to see the code of <code>catch_timer()</code> again. </p> <pre class="emlist">
if (rb_trap_immediate) { rb_thread_schedule(); }
else rb_thread_pending = 1;
</pre> <p>The condition that it is only <code>rb_trap_immediate</code> the <code>rb_thread_schedule()</code> has adhered. This is a point. <code>Rb_trap_immediate</code> shows "Whether the signal is immediately processed or not?" as shown in the name, and is usually an imitation. It is only a period that this it truly becoming it very limited while I/O is done by a single thread. It is enclosed with <code>TRAP_BEG</code> and <code>TRAP_END</code> on the source code. </p> <p>On the other hand, when it is an imitation, let's chase this because <code>rb_thread_pending</code> is set. This variable is used in the following place. </p> <p class="caption">- <code>CHECK_INTS</code>-<code>HAVE_SETITIMER</code></p> <pre class="longlist">
73 #if defined(HAVE_SETITIMER) &amp;&amp; !defined(__BOW__) 74 EXTERN int rb_thread_pending; 75 # define CHECK_INTS do {\ 76 if (!rb_prohibit_interrupt) {\ 77 if (rb_trap_pending) rb_trap_exec();\ 78 if (rb_thread_pending &amp;
&amp; !rb_thread_critical)\ 79 rb_thread_schedule();\ 80 }\ 81 } while (0) (rubysig.h)
</pre> <p><code>Rb_thread_pending</code> is checked, and <code>rb_thread_schedule()ed in </code><code>CHECK_INTS</code> like this. When you receive <code>SIGVTALRM</code> in a word The thread changes when <code>rb_thread_pending</code> truly becomes, and <code>CHECK_INTS</code> passes as follows that. </p> <p>Up to now, this <code>CHECK_INTS</code> had appeared in various points. For instance, it is <code>rb_eval()</code>, <code>rb_call0()</code>, and <code>rb_yield_0()</code>. It is likely to gather in nature and an important function because <code>CHECK_INTS</code> is not significant if it doesn't put it on the place in which it passes regularly. </p> <h4>tick</h4> <p>It has understood from this when there is <code>setitimer</code>. However, how do you do when there is no <code>setitimer</code>?The definition of <code># else</code> side of <code>CHECK_INTS</code> of just seeing now is actually an answer. </p> <p class="caption">- <code>CHECK_INTS</code>-<code>not HAVE_SETITIMER</code></p> <pre class="longlist">
84 EXTERN int rb_thread_tick; 85 #define THREAD_TICK 500 86 #define CHECK_INTS do {\ 87 if (!rb_prohibit_interrupt) {\ 88 if (rb_trap_pending) rb_trap_exec();\ 89 if (!rb_thread_critical) {\ 90 if (rb_thread_tick-- &lt;= 0) {\ 91 rb_thread_tick = THREAD_TICK;\ 9
2 rb_thread_schedule();\ 93 }\ 94 }\ 95 }\ 96 } while (0) (rubysig.h)
</pre> <p><code>Rb_thread_tick</code> decreases whenever <code>CHECK_INTS</code>'s passing. It <code>rb_thread_schedule()s it when </code>becoming 0. It is a mechanism that the thread changes when times' <code>CHECK_INTS</code> of <code>THREAD_TICK(=500)</code> passing in a word. </p> <h2>Scheduling</h2> <p>To which thread do the second point of the point to be switch?It is <code>rb_thread_schedule()</code> to bear this decision single-handed. </p> <h3><code>rb_thread_schedule()</code></h3> <p>Everyone and ..important function of <code>ruby</code>.. this fellow are ..deca.. ..saying.. .. These 220-line or more <code>rb_thread_schedule()</code> exists. Let's divide thoroughly. </p> <p class="caption">- <code>rb_thread_schedule()</code>([**katachi])</p> <pre class="longlist">
7819 void 7820 rb_thread_schedule() 7821 { 7822 rb_thread_t next; /* OK */ 7823 rb_thread_t th; 7824 rb_thread_t curr; 7825 int found = 0; 7826 7827 fd_set readfds; 7828 fd_set writefds; 7829 fd_set exceptfds; 7830 struct timeval delay_tv, *delay_ptr; 7831 double delay, now; /* OK */ 7832 int n, max; 7833 int need_select = 0; 7834 int select_timeout = 0; 7835 7836 rb_thread_pending = 0; 7837 if (curr_thread == curr_thread-&gt;next 7838 &amp;&amp; curr_
thread-&gt;status == THREAD_RUNNABLE) 7839 return; 7840 7841 next = 0; 7842 curr = curr_thread; /* starting thread */ 7843 7844 while (curr-&gt;status == THREAD_KILLED) { 7845 curr = curr-&gt;prev; 7846 } /*…… It is decision ……*//*…… context switch of ……*//
*…… that prepares the variable used with select as for the thread that does select if necessary and starts ……*//*
…… next ……*/. 8045 } (eval.c)
</pre> <p>(A) It returns at once without doing anything when there is only one thread. Therefore, the story after this is thought from assumption that two or more threads are sure to exist. </p> <p>(B) Initialization of ..continuation.. variable. You may think the initialization of it because it includes even <code>while</code>. Because <code>curr</code> traces <code>prev</code>, it is alive (<code>Status = THREAD_KILLED</code>) The last thread is set. It is because a lot of loops "It is ended to start as follows of <code>curr</code> and to treat <code>curr</code>" come out when whether it is" is said why. </p> <p>After that, the sentence named ..<code>select</code>.. [nantara] , is seen. First of all, I will prepare <code>select</code> here because I depend on <code>select</code> for the thread switch of <code>ruby</code> very much. </p> <h3><code>select</code></h3> <p> <code>Select</code> is a system call to wait until the reading and writing of a certain file can be prepared. The prototype is a long ages. </p> <pre class="emlist">
int select(int max, fd_set *readset, fd_set *writeset, fd_set *exceptset, struct timeval *timeout);
</pre> <p>Sets of <code>fd</code> to be checked are put in the variable of the <code>fd_set</code> type. The first argument <code>max</code> is "(maximum value of <code>fd</code> that exists in <code>fd_set</code>) +1. "<code>Timeout</code> is waiting time of <code>select</code>. It waits indefinitely if <code>timeout</code> is <code>NULL</code>. Only it checks without waiting for as much as one second and it returns soon if the value of <code>timeout</code> is 0. When using it, the return value is spoken. </p> <p> <code>Fd_set</code> is spoken in detail. <code>Fd_set</code> can be operated by the following macros. </p> <p class="caption">- Operation of <code>fd_set</code></p> <pre class="longlist">
fd_set set; FD_ZERO(&set) /* initialization */ FD_SET(fd, &set) It is truth */ if fd is in the set. /* */ that adds file descriptor fd to the set
</pre> <p> <code>Fd_set</code> is a bit typically array, and when you want to check n file descriptor The n bit stands (Figure 2). </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_thread_fdset.jpg" alt="(fdset)"><br>Figure 2: Fd_set</p> <p>I will show the usage example of easy <code>select</code>. </p> <p class="caption">- Usage example of <code>select</code></p> <pre class="longlist">
#include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; int main(int argc, char **argv) {
char *buf[1024]; fd_set readset; FD_ZERO(&amp;readset); /* Readset is initialized */ FD_SET(STDIN_FILENO, &readset); /* */ that puts stdin in set Select(STDIN_FILENO + 1, &readset, NULL, NULL, NULL); read(STDIN_
FILENO, buf, 1024); /* */ that succeeds without delay Exit(0);
}
</pre> <p>The system call is assumed to be a success without fail in this code and there is no error check at all. I want you to see only the flow named <code>FD_ZERO→FD_SET→select</code><code></code><code></code>. This <code>select</code> call waits for reading <code>stdin</code> because the fifth argument <code>timeout</code> of <code>select</code> is made <code>NULL</code> through all eternity. For the <code>select</code> to have ended is to be able to read without waiting in the following <code>read</code> at all. If <code>print</code> is placed on the way, movement might be understood better. Refer to append a detailed a little more example of the code moreover CD-ROM to <code>doc/select.html</code> ..put \footnote:attachment CD-ROM... <code></code></p> <h3>Preparation for <code>select</code></h3> <p>Then, it will return to the code of <code>rb_thread_schedule()</code>. Because a code of each waiting reason for the thread here has diverged, the contents are shortened and shown. </p> <p class="caption">- <code>Rb_thread_schedule()</code> - <code>select</code> preparation</p> <pre class="longlist">
7848 again: /* Initialization of select related variable */
7849 max = -1; 7850 FD_ZERO(&amp;readfds); 7851 FD_ZERO(&amp;writefds); 7852 FD_ZERO(&amp;exceptfds); 7853 delay = DELAY_INFTY; 7854 now = -1.0; 7855 7856 FOREACH_THREAD_FROM(curr, th) { 7857 if (!found &amp;&amp; th-&gt;
status &lt;= THREAD_RUNNABLE) { 7858 found = 1; 7859 } 7860 if (th-&gt;status != THREAD_STOPPED) continue; 7861 if (th-&gt;wait_for &amp; WAIT_JOIN) { /*…… Join waiting ……*/
7866 } 7867 if (th-&gt;wait_for &amp; WAIT_FD) { /*…… I/O waiting ……*/
7871 } 7872 if (th-&gt;wait_for &amp; WAIT_SELECT) { /*…… Select waiting ……*/
7882 } 7883 if (th-&gt;wait_for &amp; WAIT_TIME) { /*…… Waiting at time ……*/
7899 } 7900 } 7901 END_FOREACH_FROM(curr, th); (eval.c) </pre> <p>Standing out even if it is unpleasant is a said <code>FOREACH</code> macro. This two are defined in the way as follows. </p> <p class="caption">- <code>FOREACH_THREAD_FROM</code></p> <pre class="longlist">
7360 #define FOREACH_THREAD_FROM(f,x) x = f; do { x = x-&gt;next; 7361 #define END_FOREACH_FROM(f,x) } while (x != f) (eval.c)
</pre> <p>Let's develop plainly. </p> <pre class="emlist">
th = curr; do { th = th-&gt;next; {
.....
}
} while (th != curr);
</pre> <p>It seems to mean a toroidal list of the thread variable <code>th</code> use at that time to the end of the processing of <code>curr</code> at the hauling in end from the following of <code>curr</code>. In a little saying as …… with something to think of [itere-ta] of Ruby, will too much imagination?</p> <p>A necessary thread of select checks whether by using a strange loop slightly ..this.. when returning continuously the code here. <code></code>Because <code>select</code> can wait for all reading, writing, exceptions, and time as seen a little while ago at a dash, I think that it is understood to be able to integrate I/O waiting and waiting at time into one <code>select</code>. Moreover, there is <code>select</code> waiting in the foregoing paragraph though it did not explain, too. There is a method named <code>IO.select</code> also in the library of Ruby, and when it is C level, it <code>Rb_thread_select()</code> can be used. Therefore, it is necessary to execute the <code>select</code> at the same time. If <code>fd_set</code> is synthesized, two or more <code>select</code> can be finished at the same time. </p> <p>It is only waiting for <code>join</code>. peel off ..the remainder..This code is [ichiou] [mi]. </p> <p class="caption">- Preparation-<code>join</code> waiting of <code>rb_thread_schedule()</code> - <code>select</code></p> <pre class="longlist">
7861 if (th-&gt;wait_for &amp; WAIT_JOIN) { 7862 if (rb_thread_dead
(th-&gt;join)) { 7863 th-&gt;status = THREAD_RUNNABLE; 7864 found = 1; 7865 } 7866 } (eval.c)
</pre> <p>The meaning of <code>rb_thread_dead()</code> is clear from the name. It is judged whether the thread of the argument has ended. </p> <h3><code>Select</code> is called. </h3> <p>It turns out whether <code>select</code> is necessary even for here, and can prepare the <code>fd_set</code> if necessary. Then, <code>select</code> is called if necessary. It is possible to compare and to start at once Call <code>select</code> even if there is <code>(THREAD_RUNNABLE)</code> thread. That because the priority level might be high there is a thread in which the I/O waiting etc. have already already ended. However, it is specified for <code>select</code> that it returns at once in that case, and checks whether to complete I/O. </p> <p class="caption">- <code>rb_thread_schedule()</code>-<code>select</code></p> <pre class="longlist">
7905 /* Delay is converted into timeval. * 7908 delay_tv.tv_sec = 0;
7909 delay_tv.tv_usec = 0; 7910 delay_ptr = &amp;delay_tv; 7911 } 7912 else if (delay == DELAY_INFTY) { 7913 delay_ptr = 0; 7914 } 7915 else { 7916 delay_tv.tv_sec = delay; 7917 delay_tv.tv_usec = (delay - (double)delay_tv.tv_sec)*1e6; 7918 delay_ptr = &amp;delay_tv; 7919 } 7920 7921 n = select(max+1, &amp;readfds, &amp;writefds, &amp;exceptfds, delay_ptr); 7922 if (n &lt; 0) { /*…… It interrupted the signal etc. ……*/. 7944 } 7945 if (select_timeout &amp;&amp; n == 0) { /*…… Wanting time-out doing ……*/
7960 } 7961 if (n &gt; 0) { /*…… Normal termination ……*/
7989 } 7990 The time waiting ended by the thread /* somewhere. 7991 */ that turns loop again to specify thread 7992 if (Found && delay = DELAY_INFTY) 7993 Goto again;
7994 } (eval.c) </pre> <p>The first half of the block as written in the comment. Because <code>delay</code> is <code>usec</code> to becoming of it possible to start either of thread as follows, it is converted into the <code>timeval</code> form. </p> <p><code>Select</code> is actually called in the latter half, and it diverges as a result. Because this code was long, it divided again. When it interrupts the signal, it returns first again or is an error or it is 2 of the remainder significant because it is either. </p> <h4>Time-out</h4> <p>When <code>select</code> does the time-out, the thread of waiting of waiting at time or <code>select</code> might be able to be started. It looks for the thread that can start by checking it. <code>THREAD_RUNNABLE</code> is put up when found. </p> <h4>Normal termination</h4> <p>It is either whether I/O be able to be prepared or the <code>select</code> waiting ended that <code>select</code> ended normally. It looks for the thread in which <code>fd_set</code> is checked and waiting ends. <code>THREAD_RUNNABLE</code> is put up when found. </p> <h3>The following thread has been decided. </h3> <p>The thread that starts finally next is decided considering all the current information. It only has to choose suitably from among that because all things that the one and waiting that was able to be started from the origin ended etc. must be <code>RUNNABLE</code>. </p> <p class="caption">- The <code>rb_thread_schedule()</code>-following thread is decided. </p> <pre class="longlist">
7996 FOREACH_THREAD_FROM(curr, th) { 7997 if (th-&gt;status == THREAD_TO_
KILL) { /*(A)*/ 7998 next = th; 7999 break; 8000 } 8001 if (th-&gt;status == THREAD_RUNNABLE &amp;&amp; th-&gt;stk_ptr) { 8002 if (!
next || next-&gt;priority &lt; th-&gt;priority) /*(B)*/ 8003 next = th; 8004 } 8005 } 8006 END_FOREACH_FROM(curr, th); (eval.c)
</pre> <p>(A) When there is a thread that is about to end at any moment, the order is spent by priority and it is ended. </p> <p>(B) The fellow who seems to be able to run is found. However, it seems to consider the value of <code>priority</code>. This member is revokable in <code>Thread#priority Thread#priority =</code> from the Ruby level. Especially, <code>ruby</code> has not changed. </p> <p>How do it become it if <code>next</code> is not set in a word when the following thread is not found as long as here even ends?Waiting is sure to end in any of the thread of waiting at time and I/O waiting because it has already done <code>select</code>. It remains and, and, the waiting doesn't end in it not is only by the thread waiting about [ruha] [hoka] because there is no thread that can already be started. It is ,in a word, dead lock condition (dead lock). </p> <p>It is very difficult to detect the dead lock condition generally though the dead lock condition can happen of course also excluding this. Especially, <code>Mutex</code> etc. in case of <code>ruby</code> Complete detection is impossible near because it is mounted at the Ruby level. </p> <h3>The thread is switched. </h3> <p>Next, the thread that had to start was decided. I/O and <code>select</code> were checked. The control is only moved to the aimed thread. However, the end of <code>rb_thread_schedule()</code> and the code of the thread switch will start the paragraph being renewed. </p> <h2>Context switch</h2> <p>The last third point is thread switch, and context switch (context switch). Here is a point where the thread of <code>ruby</code> is the most interesting. </p> <h3>Basic route</h3> <p>Then, let's go from the <code>rb_thread_schedule()</code> end. The story of a paragraph here goes because it is troublesome in concise form to one's heart's content. </p> <p class="caption">- <code>rb_thread_schedule()</code>(context switch)</p> <pre class="longlist">
if (THREAD_SAVE_CONTEXT(curr)) { return; }
rb_thread_restore_context(next, RESTORE_NORMAL);
</pre> <p>Some the contents are developed and it doesn't understand <code>THREAD_SAVE_CONTEXT()</code> if it doesn't think. </p> <p class="caption">- <code>THREAD_SAVE_CONTEXT()</code></p> <pre class="longlist">
7619 #define THREAD_SAVE_CONTEXT(th) \ 7620 (rb_thread_save_context(th),thread_
switch(setjmp((th)-&gt;context))) 7587 static int 7588 thread_switch(n) 7589 int n; 7590 { 7591 switch (n) { 7592 case 0: 7593 return 0; 7594 case RESTORE_FATAL: 7595 JUMP_TAG(TAG_FATAL); 7596 break; 7597 case RESTORE_INTERRUPT: 7598 rb_interrupt(); 7599 break; /*…… The abnormality system is variously processed ……*/. 7612 case RESTORE_NORMAL: 7613 default: 7614 break; 7615 } 7616 return 1; 7617 } (eval.c)
</pre> <p>It becomes it so when three are matched in a word and it develops. </p> <pre class="emlist">
rb_thread_save_context(curr); switch (setjmp(curr-&gt;context)) { case 0: break; case RESTORE_FATAL: ....
case RESTORE_INTERRUPT: ....
/*…… Processing of abnormality system ……*/
case RESTORE_NORMAL: default: return; }
rb_thread_restore_context(next, RESTORE_NORMAL); </pre> <p>By both of <code>setjmp()</code> the return value and <code>rb_thread_restore_context()</code> It is obviously doubtful that <code>RESTORE_NORMAL</code> appears. It can be expected that it <code>longjmp()s in </code><code>rb_thread_restore_context()</code>, and <code>setjmp()</code> and <code>longjmp()</code> might correspond. And, when you imagine meaning from the name of the function</p> <pre class="emlist">
..... longjmp
</pre> <p>It might be an outline flow. However, to have to note here has not been to have concluded the class of this <code>setjmp()</code> and <code>longjmp()</code> in this thread. <code>Setjmp()</code> is used to preserve my context, and when returning to the context of the following thread, <code>longjmp()</code> is used. In a word, the ream ring of following <code>setjmp()</code>/<code>longjmp()</code> is made (Figure 3. )</p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_thread_setjmploop.jpg" alt="(setjmploop)"><br>Figure 3: This backstitching with chain of <code>setjmp</code></p> <p>Because CPU circumference can return by <code>setjmp()</code>/<code>longjmp()</code>, the remaining context is a machine stack to the Ruby stack. The save is <code>rb_thread_save_context()</code>, and the return is <code>rb_thread_restore_context()</code>. I will sequentially see. </p> <h3><code>rb_thread_save_context()</code></h3> <p>Then, from <code>rb_thread_save_context()</code> that first preserves the context. </p> <p class="caption">- <code>rb_thread_save_context()</code>(abridgment version)</p> <pre class="longlist">
7539 static void 7540 rb_thread_save_context(th) 7541 rb_thread_t th; 7542 { 7543 VALUE *pos; 7544 int len; 7545 static VALUE tval; 7546 7547 len = ruby_stack_length(&amp;pos); 7548 th-&gt;stk_len = 0; 7549 th-&gt;stk_pos = (rb_gc_stack_start&lt;pos)?rb_gc_stack_start 7550 :
rb_gc_stack_start - len; 7551 if (len &gt; th-&gt;stk_max) { 7552 REALLOC_N(th-&gt;stk_ptr, VALUE, len); 7553 th-&gt;stk_max = len; 7554 } 7555 th-&gt;stk_len = len; 7556 FLUSH_REGISTER_WINDOWS; 7557 MEMCPY(th-&gt;stk_ptr, th-&gt;stk_pos, VALUE, th-&gt;stk_len); /*………… Omission …………*/
}
(eval.c)
</pre> <p>The latter half was omitted only by single-mindedly substituting and rolling up the global variable such as <code>ruby_scope</code> to <code>th</code> because it was not interesting. It tries to copy the machine stack of <code>th-&gt; stk_ptr</code> previously wholly in the part put here of the remainder. </p> <p>An up-to-date address of the stack is written in <code>pos</code> of the argument though it is first <code>ruby_stack_length()</code>, and length is returned. The range of the stack is specified by using this value, and the address on the bottom side is set in <code>th-&gt; stk_ptr</code>. It has diverged what because there is a stack postponed under the stack postponed up (Figure 4). </p> <p class="image"> <img src="http://i.loveruby.net/ja/rhg/book/images/ch_thread_twodirection.jpg" alt="(twodirection)"><br>Figure 4: Stack postponed and stack postponed below</p> <p>Then, it only has to secure the memory previously and to copy the stack of <code>th-&gt; stk_ptr</code>. The memory for <code>th-&gt; stk_max</code> is secured and only length <code>len</code> is copied. </p> <p>Because it explained <code>FLUSH_REGISTER_WINDOWS</code> by 'Garbage collection' Chapter 5, it might already be good. It is a macro (Substance is an assembler) that drops the cash of the stack area to the memory. When the entire stack is targeted, it is necessary to call. </p> <h3><code>rb_thread_restore_context()</code></h3> <p>And, it is a function to return, and <code>rb_thread_restore_context()</code> in the end as for the thread. </p> <p class="caption">- <code>rb_thread_restore_context()</code></p> <pre class="longlist">
7635 static void 7636 rb_thread_restore_context(th, exit) 7637 rb_thread_t th; 7638 int exit; 7639 { 7640 VALUE v; 7641 static rb_thread_t tmp; 7642 static int ex; 7643 static VALUE tval; 7644 7645 if (!th-&gt;stk_ptr) rb_bug("unsaved context"); 7646 Machine..stack..below..postpone.Machine..stack..up..postpone.
/* Omission …… global variable is returned */. 7677 tmp = th; 7678 ex = exit; 7679 FLUSH_REGISTER_WINDOWS; 7680 MEMCPY(tmp-&gt;stk_pos, tmp-&gt;stk_ptr, VALUE, tmp-&gt;stk_len); 7681 7682 tval = rb_lastline_get(); 7683 rb_lastline_set(tmp-&gt;last_line); 7684 tmp-&gt;last_line = tval; 7685 tval = rb_backref_get(); 7686 rb_backref_set(tmp-&gt;last_match); 7687 tmp-&gt;last_match = tval; 7688 7689 longjmp(tmp-&gt;context, ex); 7690 } (eval.c)
</pre> <p>It is an other party to whom argument <code>th</code> returns execution. Becoming a nucleus : with <code>MEMCPY()</code> in the latter half It is <code>longjmp()</code>. The nearer the end it is <code>MEMCPY()</code>, the better. From this operation It is because the stack between <code>longjmp()</code> breaks. </p> <p>There are <code>rb_lastline_set()</code> and <code>rb_backref_set()</code> yet. This is a return of <code>$_</code> and <code>$~</code>. These two variables exist in the habit of the local variable and one local variable slot has only the number of threads by the thread also because it is local. The reason for indispensable for this place is that the destination of the return actually is a stack. Because it is a local variable, the slot area is secured by <code>alloca()</code>. </p> <p>Length ..stack of a present thread.. overwrites the stack frame of function <code>(rb_thread_restore_context)</code> exactly executing it now from a switch previous thread momentarily of the copy when it is short when the stack is simply written and it returns it though the basis is good above. That is, the content of argument <code>th</code> breaks. Therefore, it is necessary to extend the stack as there is not this. It is <code>stack_extend()</code> to do it in the first half. </p> <p class="caption">- <code>stack_extend()</code></p> <pre class="longlist">
7624 static void 7625 stack_extend(th, exit) 7626 rb_thread_t th; 7627 int exit; 7628 { 7629 VALUE space[1024]; 7630 7631 memset(space, 0, 1); /* prevent array from optimization */ 7632 rb_thread_restore_context(th, exit); 7633 } (eval.c)
</pre> <p>One Kbyte's worth of a local variable (It is put on the machine stack area) is secured and the stack is extended by force. However, the expanding stack shrinks again when <code>return</code> is done from <code>stack_extend()</code> though it is natural. Therefore, at once then and there It tries to call <code>rb_thread_restore_context()</code>. </p> <p>By the way, to complete the work of <code>rb_thread_restore_context()</code> is to become a call of <code>longjmp()</code>, and it never never returns when calling it once. Naturally, The call of <code>stack_extend()</code> never returns, too. Therefore, It is not necessary to think about variety besides the processing after it returns from <code>stack_extend()</code> in <code>rb_thread_restore_context()</code>. </p> <h3>Problem</h3> <p>The above is mounting of the thread switch of <code>ruby</code>. It is not light no matter how it thinks. <code>In large quantities..in large quantities..finally..stack..extend..function..call..roll up..die..heavy..express..problem.</code><code></code><code></code>However, the only instead, there is not a system call call of OS dependence and either the assembler is register window relation of Sparc. If it is this, portability is certainly high. </p> <p>There is a problem ..the other... There is a possibility that the code that uses the pointer that indicates the stack area doesn't move because it is allocated at the address where the stack of all threads is the same. Tcl/Tk actually splendidly puts away [hama] in this, and a limited access has been evaded from the main thread by doing reluctantly in the Tcl/Tk interface of Ruby. </p> <p>There is suitably not compatibility with native threads of course either. It is likely not to move well if the <code>ruby</code> thread is not moved on specific native threads alone. It is necessary to note it because something and the thread move in Win32 though the thread is used when it is UNIX and the library rolled up is still few. <hr> <p>The point of an opinion, an impression, and a mis-plant etc. are <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fi.loveruby.net%2Fja%2Frhg%2Fbook%2Fmailto%3Aaamine%40loveruby.net&wb_lp=JAEN&wb_dis=2">[mine**] Aoki Thank you very much even for &lt; aamine@loveruby.net &gt;</a>. </p> <p> <a href="http://www.excite-webtl.jp/world/english/web/body/?wb_url=http%3A%2F%2Fdirect.ips.co.jp%2Fdirectsys%2Fgo_x_TempChoice.cfm%3Fsh_id%3DEE0040%26amp%3Bspm_id%3D1%26amp%3BGM_ID%3D1721&wb_lp=JAEN&wb_dis=2">It is possible to reserve ..direct ..'Ruby source code complete explanation'.. IMPRESS it.. and to buy it (Fly to the book introduction page. )</a> </p> <p>Copyright (c) 2002-2004 Minero Aoki, All rights reserved.</p> </body> </html>
<script src="http://rep.excite-webtl.jp/urchin.js" type="text/javascript"></script>
<script type="text/javascript">
_udn="excite-webtl.jp";
urchinTracker();
</script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-400370-52");
pageTracker._initData();
pageTracker._trackPageview();
</script>
